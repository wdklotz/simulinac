""" 
Dynac_conversion v0.17 converts YML input file (simuIN.yml) into DYNAC_INPUT.in
file used for Dynac v6r18 software which is written in Fortran.

Works with simulinac v7.1.3a3.

The parametes are taken from the lattice generated by module factory and PARAMs from setutil.

The following parameters are required for Dynac input file.
Y - Variable is imported and already converted into the right units, ready to be used by Dynac.
N - Variable is imported however the units are not yet converted.
M - Variable is missing and defined as a Macro.
H - Hardcoded.
R - Removed as the card that requires it is not called.

    alphax  (mm/mrad)   Y     frequency           (Hz)      Y
    betax   (mm/mrad)   Y     proton_rest_mass    (MeV)     Y
    emitx   (mm.mrad)   Y     injection_energy    (MeV)     Y
    alphay  (mm/mrad)   Y     beam_current        (mA)      R
    betay   (mm/mrad)   Y     number_of_particles           H
    emity   (mm.mrad)   Y     tof_time_adjustment (deg)     H
    aplhaz  (deg/keV)   H
    betaz   (deg/keV)   Y
    emitz   (keV*deg)   Y

        Drift space
    length      (cm)     Y
    
        Quadruple
    field_length            (cm)    Y
    pole_tip_field          (kG)    Y
    radius_to_the_pole_tips (cm)    Y
    
        Cavity (RFGH)
    cell_length         (cm)        Y
    t                               H
    tp                              H
    electric_field      (MV/m)      Y
    rf_phase            (deg)       Y
    tpp                             H
    frequency           (MHz)       Y
    attenuation_factor              H

The following cards are invoked from Dynac:

GEBEAM - Generate random cloud of particles.
INPUT  - Define the reference (synchronous) particle.
EMIPRT - Select location of print beam characteristics.
REJECT - Set limits beyond which particles are rejected.
EMITGR - Particle plots in X-X', X-Y, Y-Y' and Z-Z'.
QUADRUPO - Magnetic quadruple, field strength in kG.
DRIFT - Drift space.
CAVSC - Single symmetrical accelerating "gaps" e.g. DTL.
WRBEAM - Print particle coordinates to file.
ENVEL - Envelope plots for X, Y, PHASE and ENERGY.
PROFGR - Particles plots in X-Z and Y-Z; bunch profiles in X, Y, Z, X', Y' and Z'.
STOP - End simulation; this card is mandatory.

To DO:

- TTF optimization

"""

import scipy.constants as C
import math
import elements as ELM
from lattice_generator import factory as factory
from setutil import PARAMS

### Graph Scales ###
 
# Graph 1
x = 0.9
xp = 5

# Graph 2
y1 = 0.4
yp = 20

# Graph 3
x = 1
y = 1

# Graph 4
z =  50
zp = 1

### Particle Loss Conditions ### 
# Contains limits beyond which particles are rejected.

# ifw = (0, 1, 10, 11)
# wdisp = Energy (MeV)
# wphas = Phase (deg)
# wx = X-position (cm)
# wy = Y-position (cm)
# rlim = Radius (cm)

ifw = 11        
wdisp = 50      # (MeV)
wphas = 4000    # (deg)
wx = 0.1       # (cm)
wy = 0.1        # (cm)
rlim = 0.1      # (cm)

### Hardcoded Parameters ###
# The following parameters are not imported and hardcoded a specific value.

alphaz = 0

particles = 3000
tof_time_adjustment = 0 
attenuation_factor1 = 1

t1= 0.8
tp1 = 0.0961
tpp1= 0.0021465

### Missing Parameters ###
# Parameters which are not taken from the simulinac.

### Load Parameters ### 
# Imports all the parameters and converts them to the correct units apart from the accelerating 
# and transport elements which are imported later on as thier parameters are not global.

c = C.c
pi = C.pi
frequency = PARAMS['frequenz']
proton_rest_massMeV = C.value('proton mass energy equivalent in MeV')
electron_mass = C.value('electron mass energy equivalent in MeV')

alphax = (PARAMS['alfax_i'])
betax = (PARAMS['betax_i'])
emitx = (PARAMS['emitx_i'])*1E06

alphay = (PARAMS['alfay_i'])
betay = (PARAMS['betay_i'])
emity = (PARAMS['emity_i'])*1E06

betaz = (1/proton_rest_massMeV)*(360/2*pi) 
emitz = proton_rest_massMeV*(PARAMS['emitw_i'])*(360/2*pi) 

proton_rest_mass = PARAMS['proton_mass']
injection_energy  = PARAMS['injection_energy']
rf_phase1 = (PARAMS['phisoll'])

### Generate m4 Macro File ###
def print_macro():
    
    file = open("Macros.in", "w") 
    file.write("_ALPHX = ") 
    file.write(str(alphax))
    file.write("\n_BETAX = ")
    file.write(str(betax)) 
    file.write("\n_EMITX = ")
    file.write(str(emitx))
    file.write("\n_ALPHY = ") 
    file.write(str(alphay)) 
    file.write("\n_BETAY = ")
    file.write(str(betay))
    file.write("\n_EMITY = ")
    file.write(str(emity))
    file.write("\n_ALPHZ = ") 
    file.write(str(alphaz)) 
    file.write("\n_BETAZ = ")
    file.write(str(betaz)) 
    file.write("\n_EMITZ = ")
    file.write(str(emitz))
    file.write("\n\n_FREQUENCY = ")
    file.write(str(frequency))
    file.write("\n_PROTON_REST_MASS = ")
    file.write(str(proton_rest_mass))
    file.write("\n_INJECTION_ENERGY = ")
    file.write(str(injection_energy))
    file.write("\n_PARTICLES = ")
    file.write(str(particles))
    file.write("\n_TOF_TIME_ADJUSTMENT = ")
    file.write(str(tof_time_adjustment))
    
    file.close()
    
### Generate DYNAC Input File ###
def print_begining(frequency, alphax, betax, emitx, alphay, betay, emity, alphaz, betaz, emitz, proton_rest_mass, injection_energy, particles, tof_time_adjustment):

    file.write("GEBEAM\n")      # Invoke GEBEAM card
    file.write("2 1\n")
    file.write(str(frequency))
    file.write("\n")
    file.write(str(particles))
    file.write("\n0. 0.0 0.  0.0 0. 0.\n")
    file.write(str(alphax))
    file.write(" ")
    file.write(str(betax))
    file.write(" ")
    file.write(str(emitx)) 
    file.write("\n")
    file.write(str(alphay))  
    file.write(" ")
    file.write(str(betay)) 
    file.write(" ")
    file.write(str(emity)) 
    file.write("\n")
    file.write(str(alphaz)) 
    file.write(" ")
    file.write(str(betaz)) 
    file.write(" ")
    file.write(str(emitz))
    file.write("\n")

    file.write("INPUT\n")       # Invoke INPUT card
    file.write(str(proton_rest_mass))
    file.write(" 1. 1\n")
    file.write(str(injection_energy))
    file.write(" ")
    file.write(str(tof_time_adjustment))
    file.write("\n")
    
    file.write("EMIPRT\n0\n")   # Invoke EMIPRT card
    
    file.write("REJECT\n")      # Invoke REJECT card
    file.write(str(ifw))
    file.write(" ")
    file.write(str(wdisp))
    file.write(" ")
    file.write(str(wphas))
    file.write(" ")
    file.write(str(wx))
    file.write(" ")
    file.write(str(wy))
    file.write(" ")
    file.write(str(rlim))
    file.write("\n")
   
    file.write("EMITGR\n")           # Invoke EMITGR card       
    file.write("SimuLinac BEAM AT INPUT \n") # Title
    file.write("0 5\n")
    file.write("1. 60. 1. 60. 1. 1.  600. 0.60\n") # Graph Scales
    
    file.write(";MEBT begin\n")
    
def print_QFH(field_length, pole_tip_field, radius_to_the_pole_tips):
    
    file.write("QUADRUPO\n  ")       # Invoke QUADRUPO card  
    file.write(str(field_length)) 
    file.write(" -")
    file.write(str(pole_tip_field)) 
    file.write(" ")
    file.write(str(radius_to_the_pole_tips)) 
    file.write("\n")
    
def print_QDH(field_length, pole_tip_field, radius_to_the_pole_tips):
    
    file.write("QUADRUPO\n  ")      # Invoke QUADRUPO card  
    file.write(str(field_length)) 
    file.write(" ")
    file.write(str(pole_tip_field)) 
    file.write(" ")
    file.write(str(radius_to_the_pole_tips)) 
    file.write("\n")
    
def print_RFGH(number_of_RFQH, energy, beta, cell_length, t, tp, s, sp, quad_length, quad_strength, electric_field, rf_phase, accumulated_length, tpp, frequency_MHz, attenuation_factor):
    
    file.write("CAVSC\n  ")         # Invoke CAVSC card  
    file.write(str(number_of_RFQH)) 
    file.write(" ")
    file.write(str(energy)) 
    file.write(" ")
    file.write(str(beta))
    file.write(" ")
    file.write(str(cell_length))
    file.write(" ")
    file.write(str(t))
    file.write(" ")
    file.write(str(tp))
    file.write(" ")
    file.write(str(s))
    file.write(" ")
    file.write(str(sp))
    file.write(" ")
    file.write(str(quad_length))
    file.write(" ")
    file.write(str(quad_strength))
    file.write(" ")
    file.write(str(electric_field))
    file.write(" ")
    file.write(str(rf_phase))
    file.write("\n   ")
    file.write(str(accumulated_length))
    file.write(" ")
    file.write(str(tpp))
    file.write(" ")
    file.write(str(frequency_MHz))
    file.write(" ")
    file.write(str(attenuation_factor))
    file.write("\n")
    
def print_D(length):
    
    file.write("DRIFT\n  ")     # Invoke QUADRUPO card  
    file.write(str(length))
    file.write("\n")
    
def print_end():
    
    file.write(";DTL1 end\n")
    
    file.write("EMITGR\n")       # Invoke EMITGR card   
    file.write("SimuLinac BEAM AT OUTPUTT \n") # Title
    file.write("0 5\n")
    file.write(str(x))
    file.write(" ")
    file.write(str(xp))
    file.write(" ")
    file.write(str(y))
    file.write(" ")
    file.write(str(yp))
    file.write(" ")
    file.write(str(x))
    file.write(" ")
    file.write(str(y1))
    file.write(" ")
    file.write(str(z))
    file.write(" ")
    file.write(str(zp))
    file.write("\n")
   
    file.write("ENVEL\n")           # Invoke ENVEL card  
    file.write("Beam from RFQ output to DTL1 output\n")
    file.write("1\n")
    file.write("0. 15.\n")
    file.write("1. 1. 30. 60.\n")
    
    file.write("PROFGR\n")          # Invoke PROFGR card 
    file.write("BEAM AT DTL 1 OUTPUT\n")
    file.write("0  0\n")
    file.write("1. 1. 40. 0\n")
    file.write("WRBEAM\n")
    file.write("simulinac_out.dst\n")
    file.write("0 100\n")
    file.write("STOP")
    
### START ###
if __name__ == '__main__':
    
    lattice = factory('yml/simuIN.yml')
    sections = lattice.get_sections()
    
    file = open("DYNAC_INPUT.in", "w") 
    file.write("simulinac\n") 
    print_begining(frequency, alphax, betax, emitx, alphay, betay, emity, alphaz, betaz, emitz, proton_rest_mass, injection_energy, particles, tof_time_adjustment)
    
    number_of_RFQH = 0
    i = 0
    for section in sections:
        for node in section.seq:
            
            if isinstance(node,ELM.QD): 
                field_length = (lattice.seq[i].length)*100  #(cm)
                pole_tip_field = (node['Bpole'])*10         #(kG)
                radius_to_the_pole_tips = (lattice.seq[i].aperture)*100 #(cm)
                print_QFH(field_length, pole_tip_field, radius_to_the_pole_tips)
                i = i + 1
                continue
                
            elif isinstance(node,ELM.QF):
                field_length = (lattice.seq[i].length)*100   #(cm)
                pole_tip_field = (node['Bpole'])*10          #(kG)
                radius_to_the_pole_tips = (lattice.seq[i].aperture)*100 #(cm)
                print_QDH(field_length, pole_tip_field, radius_to_the_pole_tips)
                i = i + 1
                continue
                
            elif isinstance(node,ELM.RFC):
                number_of_RFQH = number_of_RFQH + 1   # dummy variable, not used in DYNAC
                energy = 70                           # (MeV) dummy variable, not used in DYNAC
                beta = 0.07318                        # dummy variable, not used in DYNAC
                cell_length =(lattice.seq[i].gap)*100 # (cm)
                t = t1                                # (TTF as in codes SUPERFISH or PARMILA)  
                tp = tp1                              # (derivative of t, as in codes SUPERFISH or PARMILA)
                s = 0.5652                            # dummy variable, not used in DYNAC
                sp = 0.0259                           # dummy variable, not used in DYNAC
                quad_length = 3.5                     # (cm) dummy variable, not used in DYNAC
                quad_strength = 0.                    # (kG/cm) (dummy variable, not used in DYNAC)
                electric_field = lattice.seq[i].EzAvg # (MV/m)
                rf_phase = rf_phase1                  # RF phase in the middle of the gap (deg)
                accumulated_length = 26.63257         # (cm) dummy variable, not used in DYNAC
                tpp =  tpp1                           # second derivative of t
                frequency_MHz = (lattice.seq[i].freq)*1E-06 # (MHz)
                attenuation_factor =  attenuation_factor1   
                print_RFGH(number_of_RFQH, energy, beta, cell_length, t, tp, s, sp, quad_length, quad_strength, electric_field, rf_phase, accumulated_length, tpp, frequency_MHz, attenuation_factor)
                i = i + 1
                continue
                
            elif isinstance(node,ELM.D):
                drift_length = (lattice.seq[i].length)*100 #(cm)
                print_D(drift_length)
                i = i + 1
                continue  
            else:
                i = i + 1
           
    
    print_end()
    file.close() 
    print_macro()





