""" 
Dynac_conversion v0.18 converts YAML input file (simuIN.yml) into dynac.in for Dynac v6r19.

Works with simulinac v7.1.3a3.

The parametes are taken from the lattice generated by module factory and PARAMs from setutil.

The following parameters are required for Dynac input file.
Y - Variable is imported and already converted into the right units, ready to be used by Dynac.
N - Variable is imported however bu must be converted to DYNAV units
M - Variable is missing and defined as a Macro.
H - Hardcoded.
R - Removed as the card that requires it is not called.

    alphax  (mm/mrad)   Y     frequency           (Hz)      Y
    betax   (mm/mrad)   Y     proton_rest_mass    (MeV)     Y
    emitx   (mm.mrad)   Y     injection_energy    (MeV)     Y
    alphay  (mm/mrad)   Y     beam_current        (mA)      R
    betay   (mm/mrad)   Y     number_of_particles           H
    emity   (mm.mrad)   Y     tof_time_adjustment (deg)     H
    aplhaz  (deg/keV)   H
    betaz   (deg/keV)   N
    emitz   (keV*deg)   N

        Drift space
    length      (cm)     Y
    
        Quadruple
    field_length            (cm)    Y
    pole_tip_field          (kG)    Y
    radius_to_the_pole_tips (cm)    Y
    
        Cavity (RFGH)
    cell_length         (cm)        Y
    t                               H
    tp                              H
    e_field      (MV/m)      Y
    rfphdeg            (deg)       Y
    tpp                             H
    frequency           (MHz)       Y
    attenuation_factor              H

The following cards are invoked from Dynac:

GEBEAM - Generate random cloud of particles.
INPUT  - Define the reference (synchronous) particle.
EMIPRT - Select location of print beam characteristics.
REJECT - Set limits beyond which particles are rejected.
EMITGR - Particle plots in X-X', X-Y, Y-Y' and Z-Z'.
QUADRUPO - Magnetic quadruple, field strength in kG.
DRIFT - Drift space.
CAVSC - Single symmetrical accelerating "gaps" e.g. DTL.
WRBEAM - Print particle coordinates to file.
ENVEL - Envelope plots for X, Y, PHASE and ENERGY.
PROFGR - Particles plots in X-Z and Y-Z; bunch profiles in X, Y, Z, X', Y' and Z'.
STOP - End simulation; this card is mandatory.

To DO:

- TTF optimization

"""

import scipy.constants as C
import math
import elements as ELM
from lattice_generator import factory as factory
from setutil import PARAMS, WConverter, waccept
from Ez0 import SFdata
from copy import copy


def call_INTRO(arg):
    file = arg['file']
    file.write("ALCELI\n") 
    
def call_FIELD(arg):
    ATT           =   arg['attenuation']
    FH            =   arg['frequency']
    cavlen        =   arg['cavlen']/2.     # (m) 1/2 cavity length
    sfdata        =   SFdata(arg['sfdata_file'])
    sfdtable      =   sfdata._Ez0_tab
    file_tbl_name =   'field.txt'
    
    tmp = []
    for p in sfdtable:
        if abs(p.z) > cavlen*1.e2: continue  # trimm 1/2-interval to 1/2-cavlen
        tmp.append(p)
    sfdtable = tmp
    field =   [[p.z*1.e-2,p.Ez*1.e6] for p in sfdtable]   # m, V/m conversion
    # interpolate end-points
    x1= field[0][0]
    x2= field[1][0]
    y1= field[0][1]
    y2= field[1][1]
    dx = -cavlen-x1
    x3 = x1+dx
    y3 = (x3-x1)*(y2-y1)/(x2-x1)+y1
    field.insert(0,(x3,y3))      # [-interval
    field.append((-x3,y3))       # ]-interval
    # write field-file
    with open(file_tbl_name,'w') as field_table:
        field_table.write('{}\n'.format(FH))
        for p in field:
            field_table.write('{:10.4} {:10.4}\n'.format(p[0],p[1]))
        
    file = arg['file']
    file.write("FIELD\n") 
    file.write('{}\n'.format(file_tbl_name))
    file.write('{} ; ATT\n'.format(ATT))
    
def call_GEBEAM(arg):
    LAW    =   2
    ITWISS =   1
    FH     =   arg['frequency']
    IMAX   =   arg['nbparticles']
    ALPHAX =   arg['alphax']
    BETAX  =   arg['betax']
    EMITX  =   arg['emitx']
    ALPHAY =   arg['alphay']
    BETAY  =   arg['betay']
    EMITY  =   arg['emity']
    ALPHAZ =   arg['alphaz']
    BETAZ  =   arg['betaz']
    EMITZ  =   arg['emitz']
    CENTRE =   [0., 0., 0., 0., 0., 0.]
    
    file = arg['file']
    file.write('GEBEAM\n')
    file.write('{} {} ; LAW ITWISS\n'.format(LAW,ITWISS))
    file.write('{} {} ; FH IMAX\n'.format(FH,IMAX))
    file.write('{} {} {} {} {} {} ; CENTRE\n'.format(*CENTRE))
    file.write('{} {} {} ; ALPHAX BETAX EMITX\n'.format(ALPHAX,BETAX,EMITX))
    file.write('{} {} {} ; ALPHAY BETAY EMITY\n'.format(ALPHAY,BETAY,EMITY))
    file.write('{} {} {} ; ALPHAZ BETAZ EMITZ\n'.format(ALPHAZ,BETAZ,EMITZ))

def call_INPUT(arg):
    UEM     =  arg['m0c2']
    ATM     = 1.
    Q       = 1.
    ENEDEP  = arg['tkIN']    # tkIN [Mev]
    TOF     = 0.

    file = arg['file']
    file.write('INPUT\n')
    file.write('{} {} {} ; UEM ATM Q\n'.format(UEM,ATM,Q))
    file.write('{} {} ; ENEDEP TOF\n'.format(ENEDEP,TOF))

def call_REJECT(arg):
    IFW=     arg['ifw']
    WDISP=   arg['wdisp'] 
    WPHAS=   arg['wphas'] 
    WX=      arg['wx'] 
    WY=      arg['wy'] 
    RLIM=    arg['rlim']

    file = arg['file']
    file.write('REJECT\n')
    file.write('{} {} {} {} {} {} ; IFW WDISP WPHAS WX WY RLIM\n'.format(IFW, WDISP, WPHAS, WX, WY, RLIM))

def call_REFCOG(arg):
    ISHIFT=    arg['ishift']
    
    file = arg['file']
    file.write('REFCOG\n')
    file.write('{} ; ISHIFT\n'.format(ISHIFT))

def call_EMIPRT(arg):
    IEMQESG   = 1

    file = arg['file']
    file.write('EMIPRT\n')
    file.write('{} ; IEMQESG\n'.format(IEMQESG))
    
def call_EMITGR(title,arg,limits):
    TITLE    = title
    IDWDP    = 0
    RMSMTP   = 5
    XLIM1    = limits[0]
    YLIM1    = limits[1] 
    XLIM2    = limits[2] 
    YLIM2    = limits[3] 
    XLIM3    = limits[4] 
    YLIM3    = limits[5] 
    XLIM4    = limits[6]
    YLIM4    = limits[7]

    file = arg['file']
    file.write('EMITGR\n')
    file.write('{}\n'.format(TITLE))
    file.write('{} {} ; IDWDP RMSMTP\n'.format(IDWDP,RMSMTP))
    file.write('{} {} {} {} {} {} {} {} ; XLIM1,...YLIM4\n'.format(XLIM1,YLIM1,XLIM2,YLIM2,XLIM3,YLIM3,XLIM4,YLIM4))

def call_QUAD(arg):
    XL    = arg['eff_length']
    BQ    = arg['pole_field']
    RG    = arg['bore_radius']

    file = arg['file']
    file.write('QUADRUPO\n')
    file.write('{} {} {} ; XL BQ RG\n'.format(XL,BQ,RG))

def call_BUNCHER(arg):
    PV=      arg['pv']
    PDP=     arg['pdp']
    PHARM=   arg['pharm']
    PRLIM=   arg['prlim']
    
    file = arg['file']
    file.write('BUNCHER\n')
    file.write('{} {} {} {} ; PV PDP PHARM PRLIM\n'.format(PV,PDP,PHARM,PRLIM))

def call_CAVNUM(arg):
    IDUM      = arg['number']
    DUMMY     = 0.0
    DPHASE    = arg['dphase']
    FFIELD    = 0.0
    INTRVL    = arg['intrvl']
    IELEC     = 1    # protons Erest > 1 MeV
    
    file = arg['file']
    file.write('CAVNUM\n')
    file.write('{} ; IDUM\n'.format(IDUM))
    file.write('{} {} {} {} {} ; DUMMY DPHASE FFIELD INTRVL IELEC\n'.format(DUMMY, DPHASE, FFIELD, INTRVL, IELEC))
    
def call_CAVSC(arg):
    ETCELL  = arg['ETCELL']
    
    file = arg['file']
    file.write('CAVSC\n')
    file.write('{} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} ; ETCELL\n'.format(*ETCELL))

def call_DRIFT(arg):
    LD  = arg['length']
    
    file = arg['file']
    file.write('DRIFT\n')
    file.write('{} ; LD\n'.format(LD))
    
def call_ALCELI(arg):    
    file = arg['file']
    file.write(";ALCELI begin\n")
    number_of_RFQH = 0
    limits = [1., 5., 1., 5., 1., 1.,  20., 1.]
    i = 0
    for section in sections:
        for node in section.seq:
            
            if isinstance(node,(ELM.QF,ELM.QD)):
                # call_EMITGR('{}'.format(i),arg,limits)
                field_length = (node.length)*100                 #(cm)
                pole_tip_field = (node['Bpole'])*10              #(kG)
                radius_to_the_pole_tips = (node.aperture)*100    #(cm)
                if isinstance(node,ELM.QD):
                    pole_tip_field = -pole_tip_field
                params = dict(
                    file=file,
                    eff_length=field_length,
                    pole_field=pole_tip_field,
                    bore_radius=radius_to_the_pole_tips
                    )
                call_QUAD(params)
                i = i + 1
                # call_EMITGR('{}'.format(i),arg,limits)
                continue
                
            elif isinstance(node,ELM.RFC):
                number_of_RFQH = number_of_RFQH + 1   # dummy variable, not used in DYNAC
                energy = 0.                           # (MeV) dummy variable, not used in DYNAC
                beta = 0.                             # dummy variable, not used in DYNAC
                cell_length = node.length*100         # (cm)
                t = arg['t1']                         # TTF   as in codes SUPERFISH or PARMILA
                tp = arg['tp1']                       # TTF'  as in codes SUPERFISH or PARMILA
                tpp =  arg['tpp1']                    # TTF'' as in codes SUPERFISH or PARMILA
                s = 0.                                # dummy variable, not used in DYNAC
                sp = 0.                               # dummy variable, not used in DYNAC
                quad_length = 0.                      # (cm) dummy variable, not used in DYNAC
                quad_strength = 0.                    # (kG/cm) (dummy variable, not used in DYNAC)
                e_field =  +node.EzAvg                # (MV/m)
                rfphdeg =  +math.degrees(node.phis)   # (deg) RF phase in the middle of the gap
                accumulated_length = 0.               # (cm) dummy variable, not used in DYNAC
                frequency_MHz = node.freq*1E-06       # (MHz)
                attenuation = arg['attenuation']      # attenuation E-field   (1 usually)
                etcell = [
                    number_of_RFQH,
                    energy,
                    beta,
                    cell_length,
                    t,
                    tp,
                    s,
                    sp,
                    quad_length,
                    quad_strength,
                    e_field,
                    rfphdeg,
                    accumulated_length,
                    tpp,
                    frequency_MHz,
                    attenuation
                    ]
                # call_CAVSC(dict(file=file, ETCELL=etcell))
                cavnum_par = dict(
                    file   = file,
                    number = number_of_RFQH,
                    dphase = rfphdeg,
                    ffield = attenuation,
                    intrvl = 6
                    )
                call_CAVNUM(cavnum_par)
                i = i + 1
                # call_EMITGR('{}'.format(i),arg,limits)
                continue
                
            elif isinstance(node,ELM.D):
                drift_length = (lattice.seq[i].length)*100 #(cm)
                call_DRIFT(dict(file=file,length=drift_length))
                i = i + 1
                # call_EMITGR('{}'.format(i),arg,limits)
                continue  
            else:
                i = i + 1
    file.write(";ALCELI end\n")

def call_FINISH(arg):
    file = arg['file']
    file.write("STOP\n")
    file.close()

if __name__ == '__main__':
    # lattice
    lattice  = factory('yml/simuIN.yml')
    sections = lattice.get_sections()
    waccept(lattice.first_gap)
        
    #Hardcoded Parameters
    # The following pararg['title']ameters are not imported and hardcoded a specific value.
    particles           = 3000
    tof_time_adjustment = 0 
    attenuation_factor  = 1.0
    c                   = C.c
    pi                  = C.pi    
    m0c2                = C.value('proton mass energy equivalent in MeV')
    t1                  = 0.83
    tp1                 = 4.9e-2
    tpp1                = 4.9e-3
    
    # Parameter import
    # Imports all the parameters and converts them to the correct units apart from the accelerating 
    # and transport elements which are imported later on as thier parameters are not global.
    frequency = PARAMS['frequenz']
    alphax    = PARAMS['alfax_i']
    betax     = PARAMS['betax_i']      # mm/mrad - DYNAC units
    emitx     = PARAMS['emitx_i']*1E06 # mm*mrad - DYNAC units
    alphay    = PARAMS['alfay_i']
    betay     = PARAMS['betay_i']
    emity     = PARAMS['emity_i']*1E06 # mm*mrad - DYNAC units
    emitw     = PARAMS['emitw_i']      # mm/mrad - DYNAC units
    rfphdeg   = PARAMS['phisoll']
    tkIN      = PARAMS['injection_energy'] # MeV
    conv      = WConverter(tkIN)
    alphaz    = 0.
    # alphaz    = -0.21
    emitz     = 180.e3/pi*m0c2*emitw # deg*keV - DYNAC units
    try:
        phi0  = math.degrees(conv.zToDphi(PARAMS['z0']))  # deg: z --> phase
        betaz = phi0**2/emitz                             # deg/keV - DYNAC units
    except KeyError:
        betaz = 1.
    # emitz    = 629.6 # deg*keV - DYNAC units
    # betaz    = 0.033 # deg/keV - DYNAC units
    limits_i = [1., 5., 1., 5., 1., 1.,  40., 0.5]
    # limits_f = limits_i
    limits_f = [1., 5., 1., 5., 1., 1.,  40., 0.5]
    file     = open("dynac.in", "w") 

    dyn_params = dict(
                sfdata_file=      'SF_WDK2g44.TBL',
                file=             file,
                lattice=          lattice,
                sections=         sections,
                frequency=        frequency, 
                alphax=           alphax,
                betax=            betax,
                emitx=            emitx,
                alphay=           alphay,
                betay=            betay,
                emity=            emity,
                alphaz=           alphaz,
                betaz=            betaz,
                emitz=            emitz,
                m0c2=             m0c2,
                tkIN=             tkIN,
                rfphdeg=          rfphdeg,
                nbparticles=      particles,
                tog=              tof_time_adjustment,
                attenuation=      attenuation_factor,
                speedl=           c,
                pi=               pi,
                t1=               t1,
                tp1=              tp1,
                tpp1=             tpp1,
                # REJECT
                ifw=              1,
                wdisp=            100,  # MeV
                wphas=            1000, # deg
                wx=               5,    # cm
                wy=               5,    # cm
                rlim=             5,    # cm
                # REFCOG
                ishift=           1,
                # cavities
                cavlen=           PARAMS['gap'] # m lentgh of cavities
                )
        # generate dynac.in
    call_INTRO (dyn_params)
    call_FIELD  (dyn_params)
    call_GEBEAM(dyn_params)
    call_INPUT (dyn_params)
    # call_REJECT(dyn_params)
    call_REFCOG(dyn_params)
    call_EMIPRT(dyn_params)
    call_EMITGR('IN',dyn_params,limits_i)
    call_ALCELI(dyn_params)
    call_EMITGR('OUT',dyn_params,limits_f)
    call_FINISH(dyn_params)





