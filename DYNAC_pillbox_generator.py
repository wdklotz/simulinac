__version__='v10.23.3b'
""" 
DYNAC_lattice-generator
converts YAML input file (simuIN.yml) into dynacIN for dynacv7r1.

Works with simulinac v7.1.3a3.

The parametes are taken from the lattice generated by module factory and PARAMs from setutil.

The following parameters are required for Dynac input file.
Y - Variable is imported and already converted into the right units, ready to be used by Dynac.
N - Variable is imported however bu must be converted to DYNAV units
M - Variable is missing and defined as a Macro.
H - Hardcoded.
R - Removed as the card that requires it is not called.

    alphax  (mm/mrad)   Y     frequency           (Hz)      Y
    betax   (mm/mrad)   Y     proton_rest_mass    (MeV)     Y
    emitx   (mm.mrad)   Y     injection_energy    (MeV)     Y
    alphay  (mm/mrad)   Y     beam_current        (mA)      R
    betay   (mm/mrad)   Y     number_of_particles           H
    emity   (mm.mrad)   Y     tof_time_adjustment (deg)     H
    aplhaz  (deg/keV)   H
    betaz   (deg/keV)   N
    emitz   (keV*deg)   N

        Drift space (D)
    length                 (cm)     Y
    
        Quadruple (QF/QD)
    field_length            (cm)    Y
    pole_tip_field          (kG)    Y
    radius_to_the_pole_tips (cm)    Y
    
        Cavity (RFG)
    cavlen              (cm)        Y
    t                               H
    tp                              H
    e_field             (MV/m)      Y
    dphase              (deg)       Y  sign change!
    tpp                             H
    frequency           (MHz)       Y
    attenuation_factor              H

The following cards are invoked from Dynac:

GEBEAM - Generate random cloud of particles.
INPUT  - Define the reference (synchronous) particle.
EMIPRT - Select location of print beam characteristics.
REJECT - Set limits beyond which particles are rejected.
EMITGR - Particle plots in X-X', X-Y, Y-Y' and Z-Z'.
QUADRUPO - Magnetic quadruple, field strength in kG.
DRIFT - Drift space.
CAVSC - Single symmetrical accelerating "gaps" e.g. DTL.
WRBEAM - Print particle coordinates to file.
ENVEL - Envelope plots for X, Y, PHASE and ENERGY.
PROFGR - Particles plots in X-Z and Y-Z; bunch profiles in X, Y, Z, X', Y' and Z'.
STOP - End simulation; this card is mandatory.
"""
import sys
from colorama import Fore, Style
import scipy.constants as C
import math
import elements as ELM
import setutil as util
from lattice_generator import factory
from Ez0 import SFdata
from copy import copy
import pprint, inspect

def PRINT_PRETTY(obj):
    file = inspect.stack()[0].filename
    print(F'DEBUG_ON[{file}] ==> ',end="")
    pprint.PrettyPrinter(width=200,compact=True).pprint(obj)
def PASS(obj):
    pass
DEB = dict(OFF=PASS,ON=PRINT_PRETTY)
DEBUG_ON  = DEB.get('ON')
DEBUG_OFF = DEB.get('OFF')

active_field_map = "@#&%^*$"
output_base_dir = 'dynac/ALCELI/'

def call_INTRO(arg):
    file = arg['file']
    file.write("ALCELI\n")
def call_FIELD_T(arg):     #TODO
    """
    E.Tanke's Vorschlag:
        ...das SF-Feld mehrfach zu wiederholen funktioniert fuer ALCELI nicht wegen unabhaengiger pillboxes.
    """

    def shift(field, z0):
        f = [[p[0] + z0, p[1]] for p in field]
        return f

    # ATT = arg['attenuation']
    ATT           = 1.
    FH            = arg['frequency']
    cavlen        = arg['cavlen']*.5    #(m) 1/2 cavity length
    EzPeak        = 1.  # Mv/m
    sfdata        = SFdata(arg['sfdata_file'])
    sfdtable      = sfdata._Ez0_tab
    table_file_name = 'dynacEz_field.txt'

    tmp = []
    for p in sfdtable:
        if abs(p.z) > (cavlen + 1.e-4) * 1.e2: continue
        tmp.append(p)
    sfdtable = tmp
    field = [[p.z * 1.e-2, p.Ez * EzPeak * 1.e6] for p in sfdtable[1:]]  # z[m], EzPeak[V/m]

    z0 = field[-1][0]
    field0 = shift(field, z0)
    field = field0
    z0 = 2 * z0
    for i in range(9):
        field0 = shift(field0, z0)
        field = field + field0

    # write field-file
    for i in field:
        print('{:10.5}[m] {:10.5}[V/m]'.format(i[0], i[1]))
    with open(table_file_name, 'w') as field_table:
        field_table.write('{}\n'.format(FH))
        for p in field:
            field_table.write('{:10.4} {:10.4}\n'.format(p[0], p[1]))
        field_table.write('{:10.4} {:10.4}\n'.format(0., 0.))

    file = arg['file']
    file.write("FIELD\n")
    file.write('{}\n'.format(table_file_name))
    file.write('{} ; ATT\n'.format(ATT))
def call_FIELD(arg):
    """
    SF-field table on intervall -cavlen <= z <= +cavlen. 
    Field maximum is at z=0 and normalized to EzPeak Mv/m.   #TODO  z=0?
    """
    ATT           = arg['attenuation']
    FH            = arg['frequency']
    cavlen        = arg['cavlen'] *.5  # (m) 1/2 cavity length
    cav_cnt       = arg['cav_cnt']
    sfdata        = arg['sfdata'] 
    sfdtable      = sfdata._Ez0_tab_scaled   # normed to EzPeak
    table_file_name = f'dynacEz_field_{cav_cnt}.txt' 

    tmp = []
    for p in sfdtable:
        # if p.z < 0. or p.z > cavlen*1.e2: continue  # trimm 1/2-interval to 1/2-cavlen
        if abs(p.z) > (cavlen + 1.e-4) * 1.e2: continue
        tmp.append(p)
    sfdtable = tmp
    z0 = sfdtable[0].z
    field = [[(p.z - z0)*1.e-2, p.Ez*1.e6] for p in sfdtable]  # z[m], EzPeak[V/m]

    # interpolate end-points
    # x1= field[0][0]
    # x2= field[1][0]
    # y1= field[0][1]
    # y2= field[1][1]
    # dx = -cavlen-x1
    # x3 = x1+dx
    # y3 = (x3-x1)*(y2-y1)/(x2-x1)+y1
    # field.insert(0,(x3,y3))      # [-interval
    # field.append((-x3,y3))       # ]-interval

    # write field-file
    # for i in field:
    #     print('{:10.5}[m] {:10.5}[V/m]'.format(i[0],i[1]))

    with open(output_base_dir + table_file_name, 'w') as field_table:
        field_table.write('{}\n'.format(FH))
        for p in field:
            field_table.write('{:10.4} {:10.4}\n'.format(p[0], p[1]))
        field_table.write('{:10.4} {:10.4}\n'.format(0., 0.))

    file = arg['file']
    file.write("FIELD\n")
    file.write('{}\n'.format(table_file_name))
    file.write('{} ; ATT\n'.format(ATT))
def call_GEBEAM(arg):
    LAW    = 2
    ITWISS = 1
    FH     = arg['frequency']
    IMAX   = arg['nbparticles']
    ALPHAX = arg['alphax']
    BETAX  = arg['betax']
    EMITX  = arg['emitx']
    ALPHAY = arg['alphay']
    BETAY  = arg['betay']
    EMITY  = arg['emity']
    ALPHAZ = arg['alphaz']
    BETAZ  = arg['betaz']
    EMITZ  = arg['emitz']
    CENTRE = [0., 0., 0., 0., 0., 0.]

    file = arg['file']
    file.write('GEBEAM\n')
    file.write('{} {} ; LAW ITWISS\n'.format(LAW, ITWISS))
    file.write('{} {} ; FH IMAX\n'.format(FH, IMAX))
    file.write('{} {} {} {} {} {} ; CENTRE\n'.format(*CENTRE))
    file.write('{} {} {} ; ALPHAX BETAX EMITX\n'.format(ALPHAX, BETAX, EMITX))
    file.write('{} {} {} ; ALPHAY BETAY EMITY\n'.format(ALPHAY, BETAY, EMITY))
    file.write('{} {} {} ; ALPHAZ BETAZ EMITZ\n'.format(ALPHAZ, BETAZ, EMITZ))
def call_INPUT(arg):
    UEM    = arg['m0c2']
    ATM    = 1.
    Q      = 1.
    ENEDEP = arg['tkIN']  # tkIN [Mev]
    TOF    = 0.

    file = arg['file']
    file.write('INPUT\n')
    file.write('{} {} {} ; UEM ATM Q\n'.format(UEM, ATM, Q))
    file.write('{} {} ; ENEDEP TOF\n'.format(ENEDEP, TOF))
def call_REJECT(arg):
    IFW = arg['ifw']
    WDISP = arg['wdisp']
    WPHAS = arg['wphas']
    WX = arg['wx']
    WY = arg['wy']
    RLIM = arg['rlim']

    file = arg['file']
    file.write('REJECT\n')
    file.write('{} {} {} {} {} {} ; IFW WDISP WPHAS WX WY RLIM\n'.format(IFW, WDISP, WPHAS, WX, WY, RLIM))
def call_REFCOG(arg):
    ISHIFT = arg['ishift']

    file   = arg['file']
    file.write('REFCOG\n')
    file.write('{} ; ISHIFT\n'.format(ISHIFT))
def call_EMIPRT(arg):
    IEMQESG = 1

    file = arg['file']
    file.write('EMIPRT\n')
    file.write('{} ; IEMQESG\n'.format(IEMQESG))
def call_EMITGR(title, arg, limits):
    TITLE  = title
    IDWDP  = 0
    RMSMTP = 5
    XLIM1  = limits[0]
    YLIM1  = limits[1]
    XLIM2  = limits[2]
    YLIM2  = limits[3]
    XLIM3  = limits[4]
    YLIM3  = limits[5]
    XLIM4  = limits[6]
    YLIM4  = limits[7]

    file = arg['file']
    file.write('EMITGR\n')
    file.write('{}\n'.format(TITLE))
    file.write('{} {} ; IDWDP RMSMTP\n'.format(IDWDP, RMSMTP))
    file.write(
        '{} {} {} {} {} {} {} {} ; XLIM1,...YLIM4\n'.format(XLIM1, YLIM1, XLIM2, YLIM2, XLIM3, YLIM3, XLIM4, YLIM4))
def call_PROFGR(title, arg):
    IDWDP    = arg['idwdp']
    ISCALE   = arg['iscale']
    XLIM     = arg['xlim']
    YLIM     = arg['ylim']
    ZLIM     = arg['zlim']
    DISTMIN  = arg['distmin']

    file = arg['file']
    file.write('PROFGR\n')
    file.write('{}\n'.format(title))
    file.write('{} {} ; IDWDP ISCALE\n'.format(IDWDP, ISCALE))
    file.write('{} {} {} {} ; XLIM YLIM ZLIM DISTMIN\n'.format(XLIM, YLIM, ZLIM, DISTMIN))
def call_QUAD(arg):
    XL = arg['eff_length']
    BQ = arg['pole_field']
    RG = arg['bore_radius']

    file = arg['file']
    file.write('QUADRUPO\n')
    file.write('{} {} {} ; XL BQ RG\n'.format(XL, BQ, RG))
def call_BUNCHER(arg):
    PV = arg['pv']
    PDP = arg['pdp']
    PHARM = arg['pharm']
    PRLIM = arg['prlim']

    file = arg['file']
    file.write('BUNCHER\n')
    file.write('{} {} {} {} ; PV PDP PHARM PRLIM\n'.format(PV, PDP, PHARM, PRLIM))
def call_CAVNUM(arg):
    IDUM   = arg['number']
    DUMMY  = 0.0
    DPHASE = arg['dphase']
    FFIELD = arg['ffield']
    INTRVL = arg['intrvl']
    IELEC = 1  # protons E0-rest > 1 MeV

    file = arg['file']
    file.write('CAVNUM\n')
    file.write('{} ; IDUM\n'.format(IDUM))
    file.write('{} {} {} {} {} ; DUMMY DPHASE FFIELD INTRVL IELEC\n'.format(DUMMY, DPHASE, FFIELD, INTRVL, IELEC))
def call_CAVSC(arg):
    ETCELL = arg['ETCELL']

    file = arg['file']
    file.write('CAVSC\n')
    file.write('{} {} {} {} {} {} {} {} {} {} {} {} {} {} {} {} ; ETCELL\n'.format(*ETCELL))
def call_DRIFT(arg):
    LD = arg['length']

    file = arg['file']
    file.write('DRIFT\n')
    file.write('{} ; LD\n'.format(LD))
def call_ALCELI(arg):
    file = arg['file']
    file.write(";ALCELI begin\n")
    limits = [1., 5., 1., 5., 1., 1., 20., 1.]
    node_cnt, cav_cnt, quad_cnt = 0,0,0
    global active_field_map

    for node in lattice.seq:
        if isinstance(node, (ELM.QF, ELM.QD)):
            node_cnt += 1
            quad_cnt += 1
            element = util.ELEMENTS[node.label]
            DEBUG_OFF(element)
            field_length            = (node.length) * 100    # (cm)
            pole_tip_field          = element['Bpole'] * 10  # (kG)
            radius_to_the_pole_tips = (node.aperture) * 100  # (cm)
            if isinstance(node, ELM.QD):
                pole_tip_field = -pole_tip_field
            params = dict(
                file        = file,
                eff_length  = field_length,
                pole_field  = pole_tip_field,
                bore_radius = radius_to_the_pole_tips
            )
            call_QUAD(params)
            # call_EMITGR('{}'.format(node_cnt),arg,limits)
            continue

        elif isinstance(node, ELM.RFG):
            node_cnt += 1
            cav_cnt += 1
            element = util.ELEMENTS[node.label]
            DEBUG_OFF(element)

            energy        = 0.            # (MeV) dummy DYNAC variable
            beta          = 0.            # dummy DYNAC variable
            cavlen        = node.gap*100. # (cm)
            t             = arg['t1']     # TTF   as in codes SUPERFISH or PARMILA
            tp            = arg['tp1']    # TTF'  as in codes SUPERFISH or PARMILA
            tpp           = arg['tpp1']   # TTF'' as in codes SUPERFISH or PARMILA
            s             = 0.            # dummy DYNAC variable
            sp            = 0.            # dummy DYNAC variable
            quad_length   = 0.            # (cm) dummmy DYNAC variable
            quad_strength = 0.            # (kG/cm) dummy DYNAC variable
            EzAvg         = node.EzAvg             # (MV/m)
            EzPeak        = element['EzPeak']      # (MV/m)
            dphase        = node.phisoll           #(radians) RF phase in gap center
            dphase        = math.degrees(+dphase)  #(deg) change phase sign
            accumu_length = cavlen + 0.4           # (cm) dummy DYNAC variable   #TODO what needed for?
            gap_frequency = node.freq*1E-06        # (MHz)

            sfdata = node.SFdata
            DEBUG_OFF(sfdata)
            if sfdata == None:
                pass                        #TODO simulate a constant field!
            elif sfdata == active_field_map:
                pass
            else:
                active_field_map = sfdata
                gap_field_params = dict(
                    file       = file,
                    cavlen     = cavlen,       # (cm)
                    EzAvg      = EzAvg,        # (MV/m)
                    EzPeak     = EzPeak,       # (MV/m)
                    frequency  = gap_frequency,# (MHz)
                    attenuation= 1.,
                    sfdata     = sfdata,
                    cav_cnt    = cav_cnt,
                    )
                call_FIELD(gap_field_params)

            # call_CAVSC(dict(file=file, ETCELL=gap_field_params))
            cavnum_params = dict(
                file      = file,
                number    = cav_cnt,   # dummy DYNAC variable
                dphase    = dphase,
                intrvl    = 6,
                ffield    = 0.
            )
            call_CAVNUM(cavnum_params)
            
            # call_EMITGR('{}'.format(node_cnt),arg,limits)
            continue

        elif isinstance(node, ELM.D):
            element = util.ELEMENTS[node.label]
            DEBUG_OFF(element)

            drift_length = (node.length) * 100  # (cm)
            if element['type'] == "D": 
                node_cnt += 1
                call_DRIFT(dict(file=file, length=drift_length))
            # call_EMITGR('{}'.format(node_cnt),arg,limits)
            continue

        elif isinstance(node, ELM.MRK):
            # node_cnt += 1
            element = util.ELEMENTS[node.label]
            DEBUG_OFF(element)

        elif isinstance(node, ELM.RFC, ELM.GAP):
            print("Nothig implemented fot RFC or GAP. Use RFG for DYNAC!")
            print("Nothig implemented fot RFC or GAP. Use RFG for DYNAC!")
            print("Nothig implemented fot RFC or GAP. Use RFG for DYNAC!")
            sys.exit(1)

        else:
            pass

    file.write(";ALCELI end\n")
    print(f"nodes {node_cnt}, quadrupoles {quad_cnt}, cavities {cav_cnt}")
def call_WRBEAM(dst_file, arg):
    file = arg['file']
    file.write("WRBEAM\n")
    file.write("{}\n".format(dst_file))
    file.write("{}  {}   ;IREC IFLAG\n".format(0,100))
def call_FINISH(arg):
    file = arg['file']
    file.write("STOP\n")
    file.close()

if __name__ == '__main__':
    args = sys.argv
    # lattice
    IN_file = args[1] if len(args) >1 else 'unittests/simuIN.yml'
    lattice = factory(IN_file)
    util.waccept(lattice.first_gap)

    # Parameters: these are hardcoded to a specific value.
    particles           = 3000
    tof_time_adjustment = 0 
    attenuation_factor  = 1.0
    c                   = C.c
    pi                  = C.pi    
    m0c2                = C.value('proton mass energy equivalent in MeV')
    t1                  = 0.83
    tp1                 = 4.9e-2
    tpp1                = 4.9e-3

    # Parameter: import all the parameters and convert them to the correct units apart from the accelerating 
    # and transport elements which are imported later.
    alphax    = util.PARAMS['alfax_i']
    betax     = util.PARAMS['betax_i']      # mm/mrad - DYNAC units
    emitx     = util.PARAMS['emitx_i']*1E06 # mm*mrad - DYNAC units
    alphay    = util.PARAMS['alfay_i']
    betay     = util.PARAMS['betay_i']
    emity     = util.PARAMS['emity_i']*1E06 # mm*mrad - DYNAC units
    emitw     = util.PARAMS['emitw']        # mm/mrad - DYNAC units
    tkIN      = util.PARAMS['injection_energy'] # MeV
    freq      = lattice.first_gap.freq
    conv      = util.WConverter(tkIN,freq)
    alphaz    = 0.
    # alphaz    = -0.21
    emitz     = 180.e3/pi*m0c2*emitw # deg*keV - DYNAC units
    try:
        phi0 = math.degrees(conv.zToDphi(util.PARAMS['z0']))  # deg: z --> phase
        betaz = phi0 ** 2 / emitz  # deg/keV - DYNAC units
    except KeyError:
        betaz = 1.
    # emitz    = 629.6 # deg*keV - DYNAC units
    # betaz    = 0.033 # deg/keV - DYNAC units
    limits_i = [1., 1., 1., 1., 1., 1., 10., 1.]
    # limits_f = limits_i
    limits_f = [1., 1., 1., 1., 1., 1., 10., 1.]
    # file = open("out_dynac/dynacIN", "w")
    file = open(output_base_dir+"dynacIN.in", "w")

    # dyn_params: those needed by DYNAC
    dyn_params = dict(
        file      = file,
        lattice   = lattice,
        frequency = freq,    #TODO comes from each node?
        alphax    = alphax,
        betax     = betax,
        emitx     = emitx,
        alphay    = alphay,
        betay     = betay,
        emity     = emity,
        alphaz    = alphaz,
        betaz     = betaz,
        emitz     = emitz,
        m0c2      = m0c2,
        tkIN      = tkIN,
        # dphase     = dphase,   #TODO comes from each node?
        nbparticles = particles,
        tog         = tof_time_adjustment,
        # attenuation = attenuation_factor,    #TODO not here?
        speedl    = c,
        pi        = pi,
        t1        = t1,
        tp1       = tp1,
        tpp1      = tpp1,
        # REJECT
        ifw       = 1,
        wdisp     = 100,  # MeV
        wphas     = 1000,  # deg
        wx        = 5,  # cm
        wy        = 5,  # cm
        rlim      = 5,  # cm
        # REFCOG
        ishift    = 1,
        # cavities
#        cavlen = util.PARAMS['gap'],  # m lentgh of cavities  #TODO comes from each node
        # PROFGR
        idwdp     = 0,
        iscale    = 1,
        xlim      = 0.5,  # cm
        ylim      = 0.5,  # cm
        zlim      = 7.,  # deg
        distmin   = 0.01
    )
    # generate dynacIN.in
    call_INTRO(dyn_params)
    call_GEBEAM(dyn_params)
    call_INPUT(dyn_params)
    # call_REJECT(dyn_params)
    call_REFCOG(dyn_params)
    call_EMIPRT(dyn_params)
    call_EMITGR('IN', dyn_params, limits_i)
    # call_FIELD(dyn_params)    #TODO not ere anymore - now called in call_ALCELI
    call_ALCELI(dyn_params)
    call_EMITGR('OUT', dyn_params, limits_f)
    call_PROFGR('OUT', dyn_params)
    call_WRBEAM("dynacIN_out.dst",dyn_params) 
    call_FINISH(dyn_params)

    print('Reminder: '+Fore.RED+"You need a valid input-file for simu.py. Did you run simu.py first?")
    print(Style.RESET_ALL+'Generated new input files: '+file.name)