       BLOCK DATA
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       COMMON/RADIA/TRT,RMOY,XINTF,CRAE
       data CRAE,XINTF /2.81793910e-13,.86967/
       DATA VL,XMAT,RPEL,QST/2.99792458E10,938.27231,28.17938E-14,1./
       DATA H /.040484004,.092121499,.138873510,.178145981,
     1  .207816048,.226283180,.232551553,.226283180,
     2  .207816048,.178145981,.138873510,.092121499,
     3  .040484004/
       DATA T /-.984183055,-.917598399,-.801578091,
     1  -.642349339,-.448492751,-.230458316,0.,
     2  .230458316,.448492751,.642349339,.801578091,
     3  .917598399,.984183055/
       DATA H1 /-.990575473,-.950675522,-.880239154,
     1          -.781514004,-.657671159,-.512690537,
     2          -.351231763,-.178484181,  0.,
     3           .178484181, .351231763,.512690537,
     4           .657671159, .781514004,.880239154,
     5           .950675522, .990575473/
       DATA T1 /.024148303,.055459529,.085036148,
     1          .111883847,.135136368,.154045761,
     2          .168004102,.176562705,.179446470,
     3          .176562705,.168004102,.154045761,
     4          .135136368,.111883847,.085036148,
     5          .055459529,.024148303/
       common/randu/ck(15),kmax
!       randu(j):contains the Chebitcheff coefficients Ck in table 20.
!       kmax is the total number of these coefficients(from 1)
       data (ck(j),j=1,7)/.98933556,-.68838689,.28191718,
     *       -.66389307E-01,.87406854E-02,-.59534602E-03,
     *       .16300617E-04/
!xx        data (ck(j),j=1,10)/.99927015,-.78398394,.44577741,
!xx     *        -.18252873,.51928922e-01,-.99821428e-02,
!xx     *        .1259644e-02,-.99460265e-04,.44427251e-05,
!xx     *        -.85528336e-07/
!xx        data (ck(j),j=1,12)/.99989097,-.79469098,.48376369,
!xx     *        -.23183581,.85333907e-01,-.23354050e-01,
!xx     *        .46284273e-02,-.64840101e-03,.62211306e-04,
!xx     *        -.38752189e-05,.14087289e-06,-.22650639e-08/
       data kmax/7/
       END
!> *******************************************************************
!! PROGRAM DYNAC
!! THIS SOFTWARE WAS ORIGINALLY PRODUCED BY CERN/PS, CEN/SACLAY
!!
!! @version V6R19
!! @date 14-Jul-2018
!!
!! @author the late P. LAPOSTOLLE  CONSULTANT (Paris, France)
!! @author          E. TANKE       ESS (Lund, Sweden)
!! @author          S. VALERO      CONSULTANT (Paris, France)
!!
!! Modified and maintained by :
!! - TANKE Eugene
!! - VALERO Saby
!< *******************************************************************
       PROGRAM dynac
       implicit real(8) (a-h,o-z)
       parameter(ncards=68,iptsz=1000002,maxcell1=4004)
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
!   pi2=pi*pi, sqpi=(pi/2)**3/2 , pwtpi=(2*pi)**3/2 ,sqpi2=sqrt(pi/2.)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DYN/TREF,VREF
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       logical acpt
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/CARAC/CARA(10)
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/compt1/ndtl,ncavmc,ncavnm
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/faisc/f(10,iptsz),imax,ngood
       common/tapes/in,ifile,meta,ierr
       COMMON/SHIF/DTIPH,SHIFT
       COMMON/TILT/TIPHA,TIX,TIY,SHIFW,SHIFP
       COMMON /BLOC21/ BE, APB(2), LAYL, LAYX, RABT
       real(8) LAYL, LAYX
       COMMON/PORO/IROT1,IROT2
       LOGICAL IROT1,IROT2
       common/etchas/fractx,fracty,fractl
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/davprt/shortl
       common/shortl/davprt
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/etcha3/ichxyz(iptsz)
       COMMON/DCSPA/IESP
       COMMON/TSTNT/intgct
       COMMON/TABSCH/IDEG,NN,PCHOIX
       COMMON/CMPTE/IELL
       common/cptemit/xltot(maxcell1),nbemit
       common/rfield/ifield
       common/posc/xpsc
       common/rander/ialin
       common/apel/iapel
       common/qskew/qtwist,iqrand,itwist,iaqu
       common/femt/iemgrw,iemqesg
!       common/mode/eflvl,rflvl
       common/aerp/vphase,vfield,ierpf
       common/blvl/bflvl
       common/rec/irec
       COMMON/HISTO/CENTRE(6)
       COMMON/GRPARM/GLIM(4,2),GLIM1(4,2),GLIM2(4,2),PATITL,
     *        ngraphs(100),idwdp,igrprm,ngrafs
       common/zones/frms(6),nzone
       LOGICAL CHASIT,SHIFT,ITVOL,IMAMIN
       LOGICAL ICHAES,IESP,ifield,ialin,itwist,iemgrw
       character cara*80,cmnt*80,text*80,patitl*80
       character davprt(maxcell1)*80
       character KLE(ncards)*8,kley*8
       character fdrft*12
       character titre*160
       character iitime*30
       COMMON/CESPCH/NCHGE,ICHSP,NPPI
       logical ichsp
       common/drfq/prfq(9)
       COMMON/ALIN/XL,YL,XPL,YPL
       COMMON/TRCMP/PCHOIXA
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       common/mcs/imcs,ncstat,cstat(20)
       COMMON/SECDR/ISEOR
       LOGICAL ISEOR
       COMMON/RAYSHY/IRAYSH
       common/trfq/icour,ncell
       common/newref/dephas,dewref,iref,irefw
       common/tofev/ttvols
       common/conti/irfqp
       logical irfqp
       common/rf1ptq/tvolt,avolt,fph,mlc,nceltot
       common/strip/atm,qs,atms,ths,qop,sqst(6),anp,nqst
       common/grot/rzot,izrot
       common/rfqwdst/rfqwfil,rfqirec,rfqiflg,iwcl(20),nrwc,iflgr
! allow plotting the beam after sector nsprint ******
       common/isector/nsector,nsprint
       common/mingw/mg
       common/xposi/xpost(10),xlce(2),xpax(2),iscx(2)
       common/fcont/ifcont
       common/paths/dpath
       character*(256) dpath
       logical ifcont,mg,ffound,fromrfq
!********************************************
! reservation for TRACE3D related stuff
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/t3dfld/fldctr(15),zend(15),T3D
       logical T3D,xiset
       character trace3h*128,trace3t*128,tif*128,tifa*128,tifb*128
!********************************************
       common/dmp/dmpdat(14)
       common/frmacc/fracc
       COMMON/ELQ/inisk
       common/files/mcselect,mc
       character mc*2
       LOGICAL mcselect
       INTEGER inisk,rfqiflg,rfqirec
       logical izrot,fracc
       common/disttype/bindst
       LOGICAL IRAYSH,cfound,bindst
       DATA KLE/'GEBEAM','INPUT','RDBEAM','ETAC','DRIFT',
     *          'QUADRUPO','SEXTUPO','QUADSXT','SOLENO','SOQUAD',
     *          'BMAGNET','CAVMC','CAVSC','FIELD','HARM',
     *          'BUNCHER','RFQCL','NEWF','NREF','SCDYNAC',
     *          'SCDYNEL','SCPOS','TILT','TILZ','CHANGREF',
     *          'TOF','REJECT','ZROT','ALINER','ACCEPT',
     *          'EMIT','EMITGR','COMMENT','WRBEAM','ENVEL',
     *          'CHASE','RWFIELD','RANDALI','TWQA','EMIPRT',
     *          'MMODE','RFQPTQ','STRIPPER','STEER','ZONES',
     *          'PROFGR','SECORD','RASYN','FDRIFT','FSOLE',
     *          'EGUN','COMPRES','STOP','REFCOG','FPART',
     *          'QUAELEC','QUAFK','CAVNUM','EDFLEC','EMITL',
     *          'RFKICK','FIRORD','DCBEAM','T3D','MHB',
     *          'BINDIST','EMITGRD','PROFGRD'/
        integer narg,i
        character txt*128,myarg(10)*128,infiln*128
        character myfile*256,ofeldf*256,ofelds*256,inarg*256
        character plane*10,shortl*80,wfile*80,rfqwfil*80
        print*,'DYNAC WITH PRINT STATEMENTS TO UNDERSTAND THE FLOW'   ! wdk
! by default read and write particle distributions as ASCII
        bindst=.false.        
!       character(LEN=*) status
!    in corresponds to dynac input file
        in=7
! ierr corresponds to i/o unit for errors        
        ierr=0
! if mg=.true., use MINGW on windows, which has a different result for
! ctime function than standard gfortran
! default is mg=.false. This can be set by giving mingw as argument on
! the command line
        mg=.false.
        mcselect=.false.
! get arguments from the command line
! format for dynac:
! dynac file1 [-h]
! where: -file1 is the input file, describing the beamline
!        -h  print help info
        narg=0
        DO
          call get_command_argument(narg, inarg, len, istat)
!          call GETARG(narg,inarg)
          larg=LEN_TRIM(inarg)
          if(larg.eq.0) exit
!          write(6,*) narg,larg,inarg(1:larg),len,istat
          narg=narg+1
          myarg(narg)=TRIM(inarg)
        ENDDO
!       INPUT ARGUMENTS:
! *******************************************************************
        ffound=.false.
        dpath=''
        myfile=''
        do i=2,narg
          txt=myarg(i)
          if(txt(1:1).ne.'-') then
! the input argument is the name of the input file
            write(6,2917)myarg(i)
2917        format('Input file in DYNAC: ',A)
            infiln=myarg(i)
! 7 or 'in' is the unit corresponding to the dynac input file
! describing the accelerator and/or transport line
            if(access(myarg(i),' ') == 0) then
              open(in,file=myarg(i),status='unknown')
              ffound=.true.
            else
              ffound=.false.            
            endif  
          else
            if(txt(1:3).eq.'-mc') then
! multiple instances of DYNAC will be run using multiple cores
              mcselect=.true.
              if(txt(4:4).ne.' ') then
                mc=txt(4:5)
              else
                mc=txt(5:6)
              endif
              write(6,*) '-mc selected with thread ',mc
            endif
            if(myarg(i).eq.'--pipe') then
! pipe the keywords and data (as opposed to reading the input file)
              write(6,*) 'Using piped data for input'
              ffound=.true.
              infiln='None, because --pipe option was used' 
              in=5
            endif
            if(myarg(i).eq.'-mingw') then
! if mg=.true., use MINGW on windows, which has a different result
! for ctime function than standard gfortran
              mg=.true.
              write(6,*) 'Using MINGW gfortran format on MSWindows'
            endif
            if(txt(1:2).eq.'-p') then
! path of where data files needed by dynac are stored follows this option
!             path=.true.
              lpath=LEN_TRIM(txt)
              dpath=txt(3:lpath)
!              write(6,3317) dpath
!3317          format('Input file path: ',A)
            endif
            if(myarg(i).eq.'-h') then
!     print out of help message, starting with DYNAC version
              WRITE(6,3101)
              write(6,*) 'Command format:'
              write(6,*)'dynacv6_0 [-h] [-mingw] [-p] [--pipe] ',
     *         '[-mcNN] [file1]'
              write(6,*) 'where file1 is the input file, describing ',
     *                   'the beamline'
              write(6,*) 'Optional arguments:'
              write(6,*) '-h will list the argument options (this ',
     *                   'list)'
              write(6,*) '-mingw will enable MINGW gfortran format',
     *                   ' on MSWindows'
              write(6,*) '-p can be used to specify the datafile path',
     *                   '. There should be no '
              write(6,*) '   space between -p and the path. This ',
     *                   'option is used by the'
              write(6,*) '   DYNAC GUI.'
              write(6,*) '--pipe can be used to pipe the DYNAC ',
     *                   'keywords and data'
              write(6,*) '       (as opposed to reading the input ',
     *                   'from file)'
              write(6,*) '--mcNN can be used when running multiple ',
     *                   'instances of DYNAC in parallel (multi-core)'
              write(6,*) '       NN is then to be used to specify ',
     *                   'the core or thread number'
              stop
            endif
          endif
        enddo
        if(.not.ffound) then
          write(ierr,*) 'Error: Input file name required'
          write(ierr,*) 'Defaulting to dynac.in'
          if(access('dynac.in',' ') == 0) then
            infiln='dynac.in'
            open(7,file=infiln,status='unknown')
          else
            write(ierr,*) 'dynac.in does not exist either'
            write(ierr,*) 'Type'
            write(ierr,*) 'dynacv6_0 -h'
            write(ierr,*) 'for syntax'
            stop
          endif
        endif
! *******************************************************************
!  OUTPUT FILES:
!
! 'dynac.long'  : print extensive computations information
!
! 'dynac.short' : print essentials of beam dynamics information
!
! 'dynac.print' : printout of the envelope and the emittance of the
!                 beam in the directions  x, y and z at each position
!                 of the optical and accelerating elements, as well as
!                 the number of good particles
!
! 'dynac.dmp'   : printout of cavity cell related data:
!                 cell number,synchronous phase (deg),relativistic
!                 beta (output), output energy (MeV),
!                 hor. emittance (mm.mrad, normalized),
!                 ver. emittance (mm.mrad, normalized),
!                 longitudinal emittance (ns.kev)
!
! 'beam_core.dst': print the coordinates of the particles kept by
!                  CHASE
!
! 'beam_remove.dst': print the coordinates of the particles
!                    removed by CHASE
!
! 'dynac_in_pr.dst': print of the coordinates of the particles at the
!                    input of the machine
!
! 'emit.plot'      : datafile used for the plots
!
! *************************************************************************************************
       lpath=LEN_TRIM(dpath)
!
       myfile='dynac.long'
       if(mcselect) myfile='mc'//mc//'dynac.long'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(16,file=myfile,status='unknown')
       myfile='dynac.short'
       if(mcselect) myfile='mc'//mc//'dynac.short'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(12,file=myfile,status='unknown')
       myfile='dynac.print'
       if(mcselect) myfile='mc'//mc//'dynac.print'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(71,file=myfile,status='unknown')
       myfile='dynac.dmp'
       if(mcselect) myfile='mc'//mc//'dynac.dmp'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(50,file=myfile,status='unknown')
       
       myfile='beam_core_L.dst'
       if(mcselect) myfile='mc'//mc//'beam_core_L.dst'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(61,file=myfile,status='unknown')
       myfile='beam_remove_L.dst'
       if(mcselect) myfile='mc'//mc//'beam_remove_L.dst'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(60,file=myfile,status='unknown')
       
       myfile='beam_core_H.dst'
       if(mcselect) myfile='mc'//mc//'beam_core_H.dst'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(63,file=myfile,status='unknown')
       myfile='beam_remove_H.dst'
       if(mcselect) myfile='mc'//mc//'beam_remove_H.dst'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(62,file=myfile,status='unknown')

       myfile='beam_core_V.dst'
       if(mcselect) myfile='mc'//mc//'beam_core_V.dst'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(65,file=myfile,status='unknown')
       myfile='beam_remove_V.dst'
       if(mcselect) myfile='mc'//mc//'beam_remove_V.dst'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(64,file=myfile,status='unknown')       
       
       myfile='dynac_in_pr.dst'
       if(mcselect) myfile='mc'//mc//'dynac_in_pr.dst'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(11,file=myfile,status='unknown')
       myfile='emit.plot'
       if(mcselect) myfile='mc'//mc//'emit.plot'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(66,file=myfile,status='unknown')
       myfile='lost_particles.data'
       if(mcselect) myfile='mc'//mc//'lost_particles.data'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(49,file=myfile,status='unknown')
       write(49,*) '# Element numb.   pos.      prt. inp.prt.     X',
     *             '            Xp           Y            Yp       ',
     *             '   PHASE         W       Q    loss'
       write(49,*) '#                 (m)       num. number      ',
     *             '(cm)         (mrad)       (cm)         (mrad)',                  
     *             '       (deg)        (MeV)        reason'
! ****************************************************************************************************
!*******files deactivated in the code
!
!     'emlg.data': print at each position of space charge computation:
!                  the length(m), the longitudinal emittance growth (ns.keV),
!                  the kinetic energy (MeV), the number of good particles
!
!     'emtr.data': print at each position of space charge computation:
!                  the length(m), the hor. and ver. normalized emittances (mm.mrad)
!
!     'chemlg.data': as 'emlg.data' but with CHASE
!
!     'chemtr.data': as 'emtr.data' but with CHASE
!
!     'ntxyz.data' : print at each position of space charge computation:
!             the coordinates of the particles in the 3D plane (x(cm), y(cm) and z(cm))
!             This file is rewound each time, only the last result is kept
!
!     'rms.size' :print at each position of space charge computation the RMS(m) of the bunch
!                  in x, y and z-direction
!
!     'egun_prtcl.data'   : print of the coordinates of the particle icont (see RDBEAM) along the DC EGUN
!
!     'champ_sol.data'    : plot  field in the solenoid
!   ****************************************************************************************
!  SV 24/08/2015
       myfile='cavdat.out'
       if(mcselect) myfile='mc'//mc//'cavdat.out'
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(13,file=myfile,status='unknown')
!old       open(14,file='emtr.data',status='unknown')
!omment       open(15,file='chemlg.data',status='unknown')
!omment       open(17,file='rms.size',status='unknown')
!omment       open(18,file='chemtr.data',status='unknown')
!omment       open(19,file='nxyz.data',status='unknown')
!omment       open(21,file='ntxyz.data',status='unknown')
!omment       open(49,file='egun_prtcl.data',status='unknown')
!   ****************************************************
!omment       write(14,7787)
!omment       write(18,7787)
!omment7787   format(4x,'N',6x,'length',5x,'emitx',5x,'emity')
!omment       write(13,7788)
!omment       write(15,7788)
!omment7788   format(4x,'N',6x,'length',5x,'emitz',6x,'energy',1x,'part.good')
!********************************************************
!  SV 24/10/2015
!c       write(13,99)
!c99     format(3x,'ncav',2x,'ncell',2x,'pos I(cm)',4x,'pos S(cm)',6x,
!c     *'L cell(cm)',5x,'W(Mev)',7x,'dw(Mev)',6x,'TOF(dg)',7x,'Ph RF(dg)'
!c     *,6x,'pos M(cm)',5x,'WM(Mev)',7x,'dwM(Mev)',6x,
!c     *'TOFM(dg)',5x,'PhM RF(dg)')
!**************************************************************************************
!    initialize constants
!    itout corresponds to TRACE3D input file
       itout=48
!
!   pi2=pi*pi, sqpi=(pi/2)**3/2 , pwtpi=(2*pi)**3/2 ,sqpi2=sqrt(pi/2.)
       PI=4.*ATAN(1.)
       pi2=pi*pi
       sqpi=(pi/2.)**(3./2.)
       pwtpi=(2.*pi)**(3./2.)
       sqpi2=sqrt(pi/2.)
       sq2pi=sqrt(2.*pi)       
! initialize the number of charge states to 1
       ncstat=1
! initialize the # of zones (see ZONES card) to zero
       izrot=.false.
       ofeldf=''
       ofelds=''
       icour=0
! initialize trace3d related stuff
! frequency indicator
       fid=1.
       T3D=.false.
       xiset=.false.
       kt3h=1
       trace3h(kt3h)=' $DATA'
       kt3t=0
! DONE:
!      DATA KLE/'GEBEAM','INPUT','RDBEAM','ETAC','DRIFT',
!     1*       'QUADRUPO',        ,         ,'SOLENO',         ,
!     2*        'BMAGNET',        ,'CAVSC'  ,'FIELD' ,         ,
!     3*        'BUNCHER',        ,'NEWF'   ,        ,'SCDYNAC',
!    11*                 ,'CAVNUM',         ,        ,
! TO LOOK AT:
!      DATA KLE/                ,        ,
!     1*                 ,'SEXTUPO','QUADSXT',        ,'SOQUAD',
!     2*                 ,         ,         ,        , 'HARM' ,
!     3*                 ,'RFQCL',           ,'NREF',        ,
!     4*        'SCDYNEL','SCPOS','TILT','TILZ','CHANGREF',
!     5*        'TOF','REJECT','ZROT','ALINER',
!     7*        'RWFIELD','RANDALI','TWQA','EMIPRT',
!     8*        'MMODE','RFQPTQ',        ,'STEER',
!     9*                ,        ,       ,'FDRIFT','FSOLE',
!    10*                         'REFCOG','FPART',       ,
!    11*        'QUAFK',         ,       ,       ,'RFKICK'
!
! IGNORE: 'ZONES','STOP','T3D','DCBEAM','FIRORD','COMMENT'
!         'EMIT','EMITGR','WRBEAM','ENVEL','REJECT','CHASE'
!         'ACCEPT','EMITL','EGUN','COMPRES','RASYN','SECORD'
!         'STRIPPER','EDFLEC','PROFGR','QUAELEC','CAVMC'
!         'EMITGRD','PROFGRD'
       fracc=.false.
       rfqiflg=0
       acpt=.false.
       irfqp=.false.
       inisk=0
       ttvols=0.
       iprf=1
       ncell=0
       nzone=0
!       eflvl=0.
!       rflvl=0.
       bflvl=0.
       nbemit=0
       iell=0
       imcs=0
       IFW=1
       WDISP=1000.
       WPHAS=400.*pi
       WX=100.
       WY=100.
       RLIM=140.
       NRTRE=0
       do i=1,6001
         prlab(i)="        "
       enddo
       do i=1,6
         centre(i)=0.
       enddo
       do i=1,maxcell1
         davprt(i)=""
       enddo
       DO i=1,iptsz
         ichas(i)=1
         ichxyz(i)=1
       ENDDO
       SHIFT=.FALSE.
       ICHAES=.FALSE.
       ISEOR=.FALSE.
       IRAYSH=.FALSE.
       ICONT=iptsz+5
       IPRIN=1
       NRRES=0
       NDTL=0
       NCAVNM=0
       NCAVMC=0
       NRBUNC=0
       DTIPH=0.
       icont=150000
       intgct=0
       itye=1000
       ierpf=0
       ialin=.false.
       itwist=.false.
       ichsp=.FALSE.
       iesp=.FALSE.
       itvol=.FALSE.
       imamin=.false.
       chasit=.false.
       ifield=.false.
       iemgrw=.false.
       idav=0
       davtot=0.
       iapel=1
       iaqu=1
       xpsc=.5
       FRACTX=1.
       FRACTY=1.
       FRACTL=1.
       ISCSP=0
       IFILE=11
       IMAX=0
! default for beams is to be bunched (not continuous)
       ifcont=.FALSE.
!   *******************************************************
       WRITE(6,3101)
       WRITE(16,3101)
       WRITE(12,3101)
3101   FORMAT('****** DYNAC V6R19, 14-Jul-2018 *******')
       write(16,*) 'Input file: ',infiln
       write(12,*) 'Input file: ',infiln
       text=' '
       call mytime(iitime)
       if (mg) then
! using old MINGW style gfortran format: 03/30/10 20:51:06 (10 is 2010)
         text(1:4)='    '
         if(iitime(1:2).eq.'01')text(5:7)='Jan'
         if(iitime(1:2).eq.'02')text(5:7)='Feb'
         if(iitime(1:2).eq.'03')text(5:7)='Mar'
         if(iitime(1:2).eq.'04')text(5:7)='Apr'
         if(iitime(1:2).eq.'05')text(5:7)='May'
         if(iitime(1:2).eq.'06')text(5:7)='Jun'
         if(iitime(1:2).eq.'07')text(5:7)='Jul'
         if(iitime(1:2).eq.'08')text(5:7)='Aug'
         if(iitime(1:2).eq.'09')text(5:7)='Sep'
         if(iitime(1:2).eq.'10')text(5:7)='Oct'
         if(iitime(1:2).eq.'11')text(5:7)='Nov'
         if(iitime(1:2).eq.'12')text(5:7)='Dec'
         text(8:8)=' '
         text(9:10)=iitime(4:5)
         text(11:13)=' 20'
         text(14:15)=iitime(7:8)
         text(16:19)=' at '
         text(20:27)=iitime(10:17)
       else
! standard gfortran format: Tue Mar 30 20:51:06 2010
         text(1:11)=iitime(1:11)
         text(12:15)=iitime(21:24)
         text(16:19)=' at '
         text(20:27)=iitime(12:19)
       endif
       write(6,789) text(1:27)
789    format('Started on ',A27)
       write(16,*) 'Started on ',text(1:27)
       write(12,*) 'Started on ',text(1:27)
       call cpu_time(exstrt)
!  Read title
       READ (in,3333) titre(1:80)
       WRITE(16,3334) titre(1:80)
       WRITE(12,3334) titre(1:80)
3333   FORMAT(A80)
3334   FORMAT(1x,A80)
! Read the input file and check for valid cards
       DO
         CFOUND=.false.
         READ (in,3333) cmnt(1:80)
         if (cmnt(1:1).eq.';') then
           write(16,3334) cmnt(1:80)
           cycle
         else
           kley=cmnt(1:8)
         endif
         DO I=1,ncards
           IF(KLEY.EQ.KLE(I)) THEN
             CFOUND=.true.
             exit
           ENDIF
         ENDDO
         IF(CFOUND) then
!*********************************************************************
!  GEBEAM    1  | INPUT    2  | RDBEAM   3  | ETAC    4  | DRIFT    5
!  QUADRUPO  6  | SEXTUPO  7  | QUADSXT  8  | SOLENO  9  | SOQUAD   10
!  BMAGNET   11 | CAVMC    12 | CAVSC    13 | FIELD   14 | HARM     15
!  BUNCHER   16 | RFQCL    17 | NEWF     18 | NREF    19 | SCDYNAC  20
!  SCDYNEL   21 | SCPOS    22 | TILT     23 | TILZ    24 | CHANGREF 25
!  TOF       26 | REJECT   27 | ZROT     28 | ALINER  29 | ACCEPT   30
!  EMIT      31 | EMITGR   32 | COMMENT  33 | WRBEAM  34 | ENVEL    35
!  CHASE     36 | RWFIELD  37 | RANDALI  38 | TWQA    39 | EMIPRT   40
!  MMODE     41 | RFQPTQ   42 | STRIPPER 43 | STEER   44 | ZONES    45
!  PROFGR    46 | SECORD   47 | RASYN    48 | FDRIFT  49 | FSOLE    50
!  EGUN      51 | COMPRES  52 | STOP     53 | REFCOG  54 | FPART    55
!  QUAELEC   56 | QUAFK    57 | CAVNUM   58 | EDFLEC  59 | EMITL    60
!  RFKICK    61 | FIRORD   62 | DCBEAM   63 | T3D     64 | MHB      65
!  BINDIST   66 | EMITGRD  67 | PROFGRD  68 |         69 |          70
!*********************************************************************
           IF(I.eq.1) then
! AFTER GEBEAM: Generates randomly the input beam
             write(16,*) 'TYPE CODE: GEBEAM **************'
             CALL MONTE
             write(16,*) '********************************'
           ELSEIF(I.eq.2) then
! AFTER INPUT: define the dynamics at input
! --- INPUT must be preceded by GEBEAM
! --- the reference (synchronous) particle is the c.o.g of the bunch
! --- ENTRY:
! ---- 1) uem, atm, qst
! ---    uem : unit of Rest mass in MeV
!  Examples:
!          proton:938.27231  MeV
!          H-    :939.3145   MeV
!          mesons:33.9093    MeV
!          pions :139.5685   MeV
!          kaons :493.667    MeV
!          electrons : 0.511 MeV
! --- atm : Atomic number
! --- qst : charge (unit of charge) of the reference
!
! ----  2) enedep,tof
! ---      enedep: Kinetic energy of the reference
! ---      tofini: Time of flight of the reference at input (sec)
             write(16,*) 'TYPE CODE: INPUT ***************'
             CALL ENTRE
             write(16,*) '********************************'
           ELSEIF(I.eq.3) then
!   AFTER RDBEAM: Read the input beam in the disk
             write(16,*) 'TYPE CODE: RDBEAM **************'
! --- ENTRY
! ---- 1) filen : filename of file containing the particle distribution
! ---- 2) iflag : flag type of distribution file
! ---     iflag = 0 particle coordinates x,xp,y,yp,z,zp with z in rad
! ---     iflag = 1 particle coordinates x,xp,y,yp,z,zp,q,m0 with z in rad
! ---     iflag = 2 particle coordinates x,xp,y,yp,z,zp,q with z in rad
! ---     iflag = 10 particle coordinates x,xp,y,yp,z,zp with z in ns
! ---     iflag = 11 particle coordinates x,xp,y,yp,z,zp,q,m0 with z in ns
! ---     iflag = 12 particle coordinates x,xp,y,yp,z,zp,q with z in ns
! ---     add 100 to the above iflg values to read a file that has Wref as
! ---     4th parameter on line 1
! ---- 3) freq, tof
! ---     freq: RF frquency (MHz)
! ---     tof: phase offset to be applied  to the beam (deg)
!
! ---- 4) uem, atm, qst
!         like ENTRY in type code INPUT
!
             myfile=''
             READ(in,'(a)') myfile
             lfile=LEN_TRIM(myfile)
             myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
             myfile(1:lpath)=dpath(1:lpath)
             myfile=TRIM(myfile)
             if(bindst) then
               write(16,*)'Opening binary distribution file: ',myfile
               open(55,file=myfile,status='unknown',
     *              form='unformatted')
             else  
               write(16,*)'Opening ASCII distribution file: ',myfile
               open(55,file=myfile,status='unknown')
             endif  
             CALL ADJRFQ
             write(16,*) '********************************'
           ELSEIF(I.eq.4) then
!   AFTER ETAC :possibility of a multiple charge state beam
             write(16,*) 'TYPE CODE: ETAC ****************'
             kt3h=kt3h+1
             trace3h(kt3h)='ERROR: ETAC not supported'
             CALL ETAC
             write(16,*) '********************************'
!  AFTER DRIFT : dl:drift length (cm),if dl is negatif no space charge effect
           ELSEIF(I.eq.5) then
             write(16,*) 'TYPE CODE: DRIFT ***************'
             READ(IN,*)DL
             kt3t=kt3t+1
             write(tif,6001) kt3t,kt3t,10.*DL
6001         format('  nt(',i4,')= 1, a(1,',i4,')=',f12.6)
             trace3t(kt3t)=tif
             call drift(DL)
             write(16,*) '********************************'
           ELSEIF(I.eq.6) then
!    AFTER QUADRUPO: quadrupole
!   BQUAD: field at pole tip (kG)
!   XLQUA: EFFECTIVE LENGHT (cm )
!   RG:    APERTURE RADIUS (cm)
             write(16,*) 'TYPE CODE: QUADRUPO ************'
             READ(IN,*)XLQUA,BQUAD,RG
             kt3t=kt3t+1
             write(tif,6002) kt3t,kt3t,10.*BQUAD/RG,XLQUA*10.
6002         format('  nt(',i4,')= 3, a(1,',i4,')= ',f9.5,' , ',f9.5)
             trace3t(kt3t)=tif
             call qalva(bquad,xlqua,rg)
             write(16,*) '********************************'
           ELSEIF(I.eq.7) then
!    AFTER SEXTUPO: sextupole
!     IMK2: IFLAG (see arg)
!     ARG = KS2 (cm-3) if IMK2 = 0, otherwise ARG = BSEX (kG)
!     XLSEX : EFFECTIVE LENGHT (CM )
!     RG :APERTURE RADIUS (CM)
             write(16,*) 'TYPE CODE: SEXTUPO *************'
             READ(IN,*)IMK2,ARG,XLSEX,RG
             call sextu(imk2,arg,xlsex,rg)
             write(16,*) '********************************'
           ELSEIF(I.eq.8) then
!    AFTER QUADSXT:
!       quadrupole associated with sextupole
!    IKSQ: IFLAG (see ARGS and ARGQ)
!    ARGS: strength of SEXTUPOLE
!      IKSQ = 0, then ARGS = KS2 (cm-3), otherwise ARGS = FIELD BS(kG)
!    ARGQ: strength of QUADRUPOLE
!     If IKSQ = 0, then ARGQ = K2 (cm-2), otherwise ARGQ = FIELD BQ(kG)
!    XLQUA : EFFECTIVE LENGHT OF THE LENS(cm)
!    RG : APERTURE RADIUS OF THE LENS (cm)
             write(16,*) 'TYPE CODE: QUADSXT *************'
             READ(IN,*)iksq,args,argq,xlqua,rg
             call qasex(iksq,args,argq,xlqua,rg)
             write(16,*) '********************************'
           ELSEIF(I.eq.9) then
!   AFTER SOLENO: solenoid
!     IMKS: IFLAG (see ARG)
!     ARG: IMKS = 0 then ARG is the strength K (cm-1), otherwise ARG is the field B (kG)
!     XLSOL : EFFECTIVE LENGHT (CM )
             write(16,*) 'TYPE CODE: SOLENO **************'
             READ(IN,*)IMKS,XLSOL,ARG
             call solnoid(imks,arg,xlsol)
             write(16,*) '********************************'
           ELSEIF(I.eq.10) then
!   AFTER SOQUAD: solenoid associated with quadrupole
! --IKSQ: IFLAG
! --ARGS: STRENGTH or FIELD OF SOLENOID
!     If IKSQ = 0 then ARGS = K (cm-1), otherwise ARGS = B(kG)
! --ARGQ: STRENGTH or FIELD of QUADRUPOLE
!     If IKSQ = 0 then ARGQ = K2 (cm-2), otherwise ARGQ = B(kG)
!    SIGN CONVENTIONS:
!     SOLENOID: K positive => rotate the transverse coordinates about the
!                             z-axis in the clockwise direction.
!     QUADRUPOLE: K2 positive => focusing in the H plane (x,z)
! --XLSOL : EFFECTIVE LENGHT OF THE LENS(cm)
! --RG : APERTURE RADIUS OF THE LENS (cm)
             write(16,*) 'TYPE CODE: SOQUAD **************'
             READ(IN,*) IKSQ,ARGS,ARGQ,XLSOL,RG
             call solquad(iksq,args,argq,xlsol,rg)
             write(16,*) '********************************'
           ELSEIF(I.eq.11) then
! AFTER BMAGNET (sign conventions as in the code TRANSPORT)
! NSECTOR: number of sectors dividing the bending magnet
! WEDGE BENDING MAGNET
!   ANGL : DEG  bend angle of the central trajectory
!   RMO  : CM   radius of curvature of the central trajectory
!   BAIM : KG   field of the bending magnet
!     BAIM = 0  the field is computed from the momentum of the reference
!               otherwise the momentum is computed from the field
!   XN   :      FIELD GRADIENT (dimensionless,TRANSPORT: n)
!   XB   :      NORMALIZED SECOND DERIVATIVE OF B (TRANSPORT : beta)
!   AP(1) = AP(2) CM vertical half aperture (only if IPOLE = 0)
! ENTRANCE FACE
!  PENT1 EK1 EK2 RAB1
!   PENT1: DEG   angle of pole face rotation  (deg)
!   RAB1 : CM    radius of curvature
!   EK1  :       integral related to the extent of the fringing field (TRANSPORT K1)
!   EK2  :       integral related to the extent of the fringing field (TRANSPORT K2)
!   AP(1) : CM   vertical half aperture
! EXIT FACE
!  PENT2 SK1 SK2  RAB2
!   PENT2: DEG   angle of pole face rotation
!   RAB2 : CM  radius of curvature
!   SK1  :     integral related to the extent of the fringing field
!   SK2  :     integral related to the extent of the fringing field
!   AP(2) : CM   vertical half aperture
!
!   SPACE CHARGE COMPUTATION is automatically provided in the routine
!   CAUTION: with several states charges in the beam, ONLY THE SCHEFF METHOD MUST BE USED in the bending magnet
! --------------------------------------------------------------------------------------------------------------
!   nsprint: allow plotting the beam after the sector number nsprint in file 13 ('emlg.data')
!cc        read(in,*) nsector,nsprint
             write(16,*) 'TYPE CODE: BMAGNET *************'
             read(in,*) nsector
             READ(IN,*)ANGL,RMO,BAIM,XN,XB
             READ(IN,*)PENT1,RAB1,EK1,EK2,APB(1)
             fprec=epsilon(apb(1))
! if apb(1) ne 0 and if ek1 = 0 the program inserts a default value of ek1 = 0.5
!             if(apb(1).ne.0..and.ek1.lt.0.) ek1=0.5
             if(abs(apb(1)).gt.fprec .and. ek1.lt.0.) ek1=0.5
             READ(IN,*)PENT2,RAB2,SK1,SK2,APB(2)
! if apb(2) ne 0 and  sk1 = 0 the program inserts a default value of sk1 = 0.5
!             if(apb(2).ne.0..and.sk1.lt.0.) sk1=0.5
             if(abs(apb(2)).gt.fprec .and. sk1.lt.0.) sk1=0.5
! trace3d
! edge
             kt3t=kt3t+1
             write(tif,6005) kt3t,kt3t,PENT1,10.*abs(RMO),
     *                       20.*APB(1),EK1,EK2
6005         format('  nt(',i4,')= 9, a(1,',i4,')=',f9.5,' , ',f9.2,
     *              ' , ',f9.2,' , ',f9.2,' , ',f9.2)
             trace3t(kt3t)=tif
! bend
             kt3t=kt3t+1
             write(tif,6006) kt3t,kt3t,ANGL,10.*abs(RMO)
6006         format('  nt(',i4,')= 8, a(1,',i4,')=',f9.5,' , ',f9.2,
     *              ' , 0 , 0 ')
             trace3t(kt3t)=tif
! edge
             kt3t=kt3t+1
             write(tif,6005) kt3t,kt3t,PENT2,10.*abs(RMO),
     *                       20.*APB(2),SK1,SK2
             trace3t(kt3t)=tif
!
!
             CALL aimalv(ANGL,RMO,BAIM,XN,XB,EK1,EK2,PENT1,RAB1,
     *                   SK1,SK2,PENT2,RAB2)
             write(16,*) '********************************'
           ELSEIF(I.eq.12) then
!   AFTER CAVMC: Multicell accelerating element
!           the electromagnetic field can be read:
!           in the file 'field.txt' in the form (z,E(z))
!           or from the type code: HARM in the form of a Fourier series expansion
             write(16,*) 'TYPE CODE: CAVMC ***************'
             CALL RESTAY
             write(16,*) '********************************'
           ELSEIF(I.eq.13) then
!   AFTER CAVSC: single cell accelerating element
!                The transit time factors describe the eletromagnetic field
             write(16,*) 'TYPE CODE: CAVSC ***************'
             CALL ETGAP
             write(16,*) '********************************'
           ELSEIF(I.eq.14) then
!  AFTER FIELD
! --- the axial field of the cavity is read from file in the form (z,E(z)) with a step size h in z
!     in the SUPERFISH format: z(m)  E(z) (V/m)
!  PART: the step size h may be divided in 'part' elements (with PART (= >) 1)
!  ATT:  the field E(z) is multiplied by ATT and converted in MV/cm
!
             write(16,*) 'TYPE CODE: FIELD  **************'
             write(16,*) 'ELECTRIC FIELD (z, E(z) ) '
!      get filename of input file of the electromagnetic field in the form (z,E(z))
             myfile=''
             READ(in,'(a)') myfile
!      check if file is already open
             iostats = int(FTELL(20))
             if(len_trim(dpath).ne.0) then
               lfile=LEN_TRIM(myfile)
               myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
               myfile(1:lpath)=dpath(1:lpath)
             endif
             myfile=TRIM(myfile)
             if(iostats.eq.-1) then
! file not yet open
               open(20,file=myfile,status='unknown')
               write(16,*) 'Opening field file: ',myfile
               ofeldf=myfile
             else
               if(ofeldf.ne.myfile) then
                 write(16,*) 'Closing field file: ',ofeldf
                 write(16,*) 'Opening field file: ',myfile
                 close(20)
                 open(20,file=myfile,status='unknown')
                 ofeldf=myfile
               endif
             endif
             read(in,*) att
!omment       write(16,*) ' partition of a step h: ',part,' field factor: ', att
!     conversion V/m (SUPERFISH) --> MV/cm
             att=1.e-08*att
             write(16,*) ' * Read the cavity field from ',myfile(1:80)
             call fieldcav(att)
             write(16,*) '********************************'
           ELSEIF(I.eq.15) then
! AFTER HARM: the field is read on the form of a Fourier series expansion
             write(16,*) 'TYPE CODE: HARM  ***************'
             write(16,*) 'ELECTRIC FIELD (Fourier series expansion)'
             call rharm
             write(16,*) '********************************'
           ELSEIF(I.eq.16) then
!  After BUNCHER: buncher as a single element
!      PV: Voltage
!      PDP: PHASE OF RF (deg)
!      PRLIM: aperture radius (cm)
!      PHARM: harmonic factor (bucher fq.)/(DTL freq.)
             write(16,*) 'TYPE CODE: BUNCHER *************'
             READ(IN,*) pv,pdp,pharm,prlim
             write(16,7777) pv,pdp,prlim
7777         format(' BUNCHER CAVITY ',/,' Voltage ',E12.5,' MV',/,
     X      ' RF Phase ',e12.5,' deg',' Aperture Radius ',e12.5,' cm')
             kt3t=kt3t+1
             write(tif,6007) kt3t,kt3t,pv,pdp,pharm
6007         format('  nt(',i4,')=10, a(1,',i4,')=',f9.5,' , ',f9.2,
     &              ' , 1 , 1 , ',f5.1)
             trace3t(kt3t)=tif
             pdp=pdp*pi/180.
             call bunparm(pv,pdp,pharm,prlim)
             write(16,*) '********************************'
           ELSEIF(I.eq.17) then
!   AFTER RFQCL (single cell of a RFQ)
             write(16,*) 'TYPE CODE: RFQCL DEPRECATED ****'
             write(16,*) 'Use RFQPTQ instead *************'
             write(ierr,*)  
             write(ierr,*)'TYPE CODE: RFQCL DEPRECATED ****'
             write(ierr,*)'Use RFQPTQ instead *************'
             STOP
           ELSEIF(I.eq.18) then
!  AFTER NEWF:define a new frequency (Hertz)
             IF (IMAX.EQ.0) THEN
               WRITE(16,*)' NEWF HAS TO BE PRECEEDED BY GEBEAM',
     *                    ' OR RDBEAM'
               stop
             ENDIF
             write(16,*) 'TYPE CODE: NEWF ****************'
             READ (IN,*) FH1
! record frequency change in view of trace3d file
             FH1=2.*PI*FH1
             fid=fh1/fh
! adjust beam current
             beamc=beamc*fh1/fh
!             rflvl=rflvl*fh1/fh
             fh=fh1
             WRITE(16,*)' NEW FREQUENCY : ',FH/(2.*PI),' Hertz'
           ELSEIF(I.eq.19) then
!   AFTER NREF: define a new syncronous particle
! ---- DEPHAS: the change of phase (DEG)
! ---- DEW   : the change of kinetic energy (see IREFW)
! ---- follow two falgs, IREF and IREFW
! ----  IF IREF=0: RELATIVE TO the previous synchronous particle
! ----  IF IREF=1: RELATIVE TO the previous COG
! ----  IF IREFW=0: DEWREF is in dW/W
! ----  IF IREFW=1: DEWREF is in dW (MeV)
             write(16,*) 'TYPE CODE: NREF ****************'
             read (in,*) dephas,dewref,iref,irefw
             CALL REFER
             write(16,*) '********************************'
           ELSEIF(I.eq.20) then
! AFTER SCDYNAC
!   ISCSP: METHOD FOR SPACE CHARGE COMPUTATIONS
!     ISCSP=1  HERSC METHOD
!     ISCSP=2  SCHERM METHOD
!     ISCSP=3  SCHEFF METHOD
             write(16,*) 'TYPE CODE: SCDYNAC *************'
             read(in,*) iscsp
!      sce10 =1 : call in quads,solenoids,accelarating elements
!      sce10 =2 : call in drifts,accelarating elements
!      sce10 =3 : call in quads,solenoids,drifts,accelarating elements
!      BEAM CURRENT IN ma
             READ(IN,*) BEAMC,sce10
             beame=beamc
             if(.not.xiset) then
               kt3h=kt3h+1
               write(tif,7001) BEAMC
7001           format(' XI= ',f9.4)
               trace3h(kt3h)=tif
               xiset=.true.
             endif
             if(iscsp.le.1) write(16,*) 'HERSC method  '
             if(iscsp.eq.2) write(16,*) 'SCHERM method  '
             if(iscsp.eq.3) write(16,*) 'SCHEFF method  '
             if(iscsp.gt.3) then
               write(ierr,*) 'Error in SCDYNAC iscsp: ',iscsp
               write(16,*) 'Error in SCDYNAC iscsp: ',iscsp
               stop
             endif
             WRITE(16,*)' Beam current : ',BEAMC,' mA'
             ECT=4.
             ICHAES=.TRUE.
             if(iscsp.le.1) then
!        initialise the routine HERSC
               if(iscsp.eq.1)ini=0
               if(iscsp.lt.1)ini=-1
               call hersc(ini)
               iscsp=1
             endif
!---  SCHERM, read third line as dummy
             if(iscsp.eq.2) read(in,*) idum
! --- SCHEFF
!      initialise the mesh of routine SCHEFF
             if(iscsp.eq.3) then
               call schfdyn
             endif
             fprec=epsilon(beamc)
             if (abs(beamc).le.fprec) ichaes=.FALSE.
             write(16,*) '********************************'
           ELSEIF(I.eq.21) then
!   AFTER SCDYNEL: space charge computations in the current position (i.e.bending magnet)
!     XTRANS is the acting lenght of the beam self-fields (cm)
             write(16,*) 'TYPE CODE: SCDYNEL *************'
             READ(IN,*) XTRANS
             CALL CESP(XTRANS)
             write(16,*) '********************************'
           ELSEIF(I.eq.22) then
! AFTER SCPOS : change the position of space charge computation in gaps or cavities
             write(16,*) 'TYPE CODE: SCPOS ***************'
             write(16,*) 'Space Charge Position'
             read(in,*) xpsc
             if(xpsc.ge.1.)xpsc=.5
             write(16,*) '********************************'
           ELSEIF(I.eq.23) then
!   AFTER TILT:rotation and shift of beam ellipsoid
!    ICG    : = 1 => REFERENCE PARTICLE IS THE C.O.G. OF THE BEAM
!    ICG    : = 0 => IT IS DISTINCT FROM THE C.O.G.
             write(16,*) 'TYPE CODE: TILT ****************'
             READ(IN,*)ICG
             READ(IN,*)TIPHA,TIX,TIY,SHIFW,SHIFP
             CALL TILTBM(ICG)
             write(16,*) '********************************'
           ELSEIF(I.eq.24) then
!   AFTER TILZ: tilt in the plane (x,z) around the c.o.g. of the upright ellipse
             write(16,*) 'TYPE CODE: TILZ ****************'
             READ(IN,*) TILTA
             call tiltz(TILTA)
             write(16,*) '********************************'
           ELSEIF(I.eq.25) then
!  AFTER CHANGREF: change of reference frame
            write(16,*) 'TYPE CODE: CHANGREF *************'
            CALL CHREFE
           ELSEIF(I.eq.26) then
! After TOF:
! ---  the T.O.F may be activated in the dynamics of bunchers, cavities and acc. gaps
! ---  Entry: indic and icor
! ---  indic = 0 : the T.O.F is activated, otherwise it is passive
! ---  icor = 0  : no adjustement on the phase offset, otherwise adjustments are automatically made on the phase offset
             write(16,*) 'TYPE CODE: TOF *****************'
             CALL rmami
             write(16,*) '********************************'
           ELSEIF(I.eq.27) then
!   AFTER REJECT: defining limits in X,X',Y,Y',Z,Z'
! ---- aperture of the Beam
! ----  WDISP: in half dispersion
! ------  IF IFW=0  ==> WDISP in (+-) dW/W
! ------  IF IFW=1  ==> WDISP in (+-) dW (MeV)
! ------  IF IFW=10 ==> wdisp = dW/W relative to REF
! ------  IF IFW=11 ==> wdisp = dW relative to REF
! ----  WPHAS: in half phase (+-) deg
! ----  WX   : in x-direction (+-) cm
! ----  WY   : in y-direction (+-) cm
! ----  RLIM : in radius (cm)
             write(16,*) 'TYPE CODE: REJECT **************'
             READ(IN,*) IFW,WDISP,WPHAS,WX,WY,RLIM
             if(ifw.eq.0) then
               WRITE(16,1050)WDISP,WPHAS,WX,WY,RLIM
               WRITE(16,*)'    Energy spread window w.r.t. COG'
             elseif(ifw.eq.1) then
               WRITE(16,1051)WDISP,WPHAS,WX,WY,RLIM
               WRITE(16,*)'    Energy spread window w.r.t. COG'
             elseif(ifw.eq.10) then
               WRITE(16,1050)WDISP,WPHAS,WX,WY,RLIM
               WRITE(16,*)'    Energy spread window w.r.t. reference'
             elseif(ifw.eq.11) then
               WRITE(16,1051)WDISP,WPHAS,WX,WY,RLIM
               WRITE(16,*)'    Energy spread window w.r.t. reference'
             else
               WRITE(16,*) 'Error in REJECT input:'
               WRITE(16,*) 'IFW=',ifw,' but should be 0, 1, 10 or 11'
               WRITE(ierr,*) 'Error in REJECT input:'
               WRITE(ierr,*) 'IFW=',ifw,' but should be 0, 1, 10 or 11'
               stop
             endif             
1050         FORMAT(5X,'*** BEAM SIZE LIMITS ',/,
     X       4X,' 1/2 dW/W    :',E12.5,'  1/2 PHASE(DEG) :'
     X       ,E12.5,/,4X,' 1/2 x (cm)  :',E12.5,
     X       '  1/2 y(cm)      :',E12.5,' RADIUS (cm) :',E12.5)
1051         FORMAT(5X,'*** BEAM SIZE LIMITS ',/,
     X       4X,' 1/2 dW (MeV):',E12.5,'  1/2 PHASE(DEG) :'
     X       ,E12.5,/,4X,' 1/2 x (cm)  :',E12.5,
     X       '  1/2 y(cm)      :',E12.5,' RADIUS (cm) :',E12.5)
! ---- convert WPHAS in rad
             WPHAS=WPHAS*PI/180.
             write(16,*) '********************************'
           ELSEIF(I.eq.28) then
! AFTER ZROT : beam rotation
!  The transverse coordinates x and y may be rotated through an
!  angle ZROTA(deg).The positive sense of ratation is clockwise
!  about the positive z axis
             write(16,*) 'TYPE CODE: ZROT ****************'
             READ(IN,*)ZROTA
             CALL ZROTAT(ZROTA)
             write(16,*) '********************************'
           ELSEIF(I.eq.29) then
!   after ALINER: ALIGNMENT errors IN X,X',Y,Y'
!     XL,YL (cm)    XPL,YPL (mrad)
             write(16,*) 'TYPE CODE: ALINER **************'
             read(in,*) XL,YL,XPL,YPL
             CALL ALINER
             write(16,*) '********************************'
           ELSEIF(I.eq.30) then
!    AFTER ACCEPT: Determination of the input acceptance for the structure
             write(16,*) 'TYPE CODE: ACCEPT **************'
             acpt=.true.
             CALL ACCEPT
             acpt=.false.
             write(16,*) '********************************'
           ELSEIF(I.eq.31) then
!    AFTER EMIT  Print emittance data in the file 'dynac.short'
             write(16,*) 'TYPE CODE: EMIT ****************'
             CALL emiprt(0)
           ELSEIF(I.eq.32) then
!    AFTER EMITGR: emittance plots
!    PLOTS IN XX', YY', XY AND ZZ'
             write(16,*) 'TYPE CODE: EMITGR **************'
             igrprm=0
             call ytzp
             write(16,*) '********************************'
           ELSEIF(I.eq.33) then
!    AFTER COMMENT
! allows for comments in the input data file
             write(16,'(a8)') kley
             READ (in,'(A)') cmnt(1:80)
             WRITE(16,'(A)')  cmnt(1:80)
           ELSEIF(I.eq.34) then
!   AFTER WRBEAM: prints coordinates of particles on output files
             write(16,*)'TYPE CODE: WRBEAM ***************'
!      irec:flag   irec=0 the phase is recentered with regard to the c.o.g
!                  irec<>0 the phase is not recentered around the c.o.g
             read(in,'(A)') wfile
             if(mcselect) wfile='mc'//mc//trim(wfile)
             write(16,'(A)') ' Particle distribution coordinates '//
     *                       'will be written to '//wfile
             read(in,'(A)') text
             read(text,*) irec,iflg
             if(iflg.ge.0) then
               fromrfq=.false. 
               call prbeam(iflg,wfile,fromrfq)
             else
! write beam to file after RFQ cells
               read(text,*) irec,iflg,rfqiflg
               if(rfqiflg.lt.0) then
! output for more than one individual cell
                 nrwc=-rfqiflg
                 read(text,*) irec,iflg,rfqiflg,(iwcl(i),i=1,nrwc)
                 write(16,'(A)') ' Do this after RFQ cell(s):'
                 write(16,*) (iwcl(i),i=1,nrwc)
               else
! output for one cell or all cells               
                 write(16,'(A)')' Do this after one or all RFQ cell(s)'
               endif  
               iflgr=-iflg
               rfqwfil=wfile
               rfqirec=irec
             endif                     
             write(16,*) '********************************'
           ELSEIF(I.eq.35) then
!   AFTER ENVEL: plot the longitudinal and the tranverse envelope of the beam
             write(16,*) 'TYPE CODE: ENVEL ***************'
             CALL PROFIL
             write(16,*) '********************************'
           ELSEIF(I.eq.36) then
!   AFTER CHASE:Temporary elimination of most distant particles for statistical purposes
             write(16,*) 'TYPE CODE: CHASE ***************'
             CALL CHASE
             write(16,*) '********************************'
           ELSEIF(I.eq.37) then
!  AFTER RWFIELD : rewinds the file 'field.txt'
             write(16,*) 'TYPE CODE: RWFIELD *************'
             rewind(20)
           ELSEIF(I.eq.38) then
!  AFTER RANDALI : generates random errors in alignments
!     XL,YL (cm)    XPL,YPL (mrad)
!     ilier = 0 stop the effects of the random misalignment
             write(16,*) 'TYPE CODE: RANDALI *************'
             read(in,*) ilier
             if(ilier.eq.0) then
               ialin=.false.
               write(16,*) '********************************'
             else
               ialin=.true.
               read(in,*) XL,YL,XPL,YPL
             endif
             write(16,*) '********************************'
           ELSEIF(I.eq.39) then
!  AFTER TWQA generates systematic or random twist of quadrupoles
!  QTWIST: rotation about Y axis (deg)
!  IQRAND: =0 systematic twist, otherwise random twist
             write(16,*) 'TYPE CODE: TWQA ****************'
             read(in,*) iqrand,qtwist
             itwist=.true.
             if(abs(qtwist).le.1.e-20) itwist=.false.
             write(16,*) '********************************'
           ELSEIF(I.eq.40) then
!  AFTER EMIPRT : print the beam characteristics to disk (unit 12, file='dynac.short')
! --- the beam characteristics are systematically printed after:
!       cavities, accelerating gaps, bunchers, electrons gun, rfq
!
!  IEMQESG :  =0  stop the prints for all optical lenses
!             =1  after all optical lenses apart from positive drifts
!             =2  after all optical lenses and positive drifts
!             =3  after quads, solen.,positive drifts and accel. elements
             write(16,*) 'TYPE CODE: EMIPRT **************'
             iemgrw=.true.
             read(in,*) iemqesg
             if(iemqesg.eq.0) iemgrw=.false.
           ELSEIF(I.eq.41) then
! AFTER MMODE: systematic or random error on the phase offset and on the level of the field
! ---          MMODE is only acting on  particles in the bunch  (no change of the reference)
! --- ENTRY: ierpf , vphase , vfield
! --- ierpf: flag
! ---   IF:  ierpf = 0  ===> stop the type code effects
! ---        ierpf = 1  ===> systematic error
! ---        ierpf > 1  ===> random error
! ---  vphase (deg): error added to the nominal phase offset
! ---  vfield (%)  : error added to the level of the electric field
! ---  (new phase offset) = (previous phase offset) + vphase
! ---  (new level of field) = (previous level of field) * (1.+ vfield/100)
             write(16,*) 'TYPE CODE: MMODE ***************'
             read(in,*) ierpf,vphase,vfield
             if(ierpf.eq.0) then
               vphase=0.
               vfield=0.
             endif
             if(ierpf.eq.1) write(16,4279) vphase,vfield
4279         format(2x,'systematic error on phase offset: ',e12.2,
     *       ' deg',/,2x,'systematic error on level of field: ',
     *       e12.5,' %')
             if(ierpf.gt.1) write(16,4290) vphase,vfield
4290         format(2x,'maximun randon error on phase offset: ',e12.2,
     *       ' deg',/, 2x,'maximum random error on level of field: ',
     *       e12.5,' %')
             vfield=vfield/100.
             write(16,*) '********************************'
           ELSEIF(I.eq.42) then
! --- AFTER RFQPTQ (RFQ per tutti quanti)
             write(16,*) 'TYPE CODE: RFQPTQ **************'
             write(6,*)
! -- ENTRIES:
! ---  ENTRY 1: input file 'myfile' contains the geometry of the RFQ (unit 27)
! ---  ENTRY 2: nceltot
!        nceltot: number of cells (may be less than the total number of cells)
! ---  ENTRY 3: tvolt avolt fph
! ---- tvolt: factor applied to intervane-voltage Vref of the synchronous particle (in %)
! ---- avolt: factor applied to intervane-voltage Vpart for particles (in %)
!        Vref = Vref(1 + tvolt/100)
!        Vpart = Vpart(1 + avolt/100)
! --- fph: factor applied to the phase at entrance of cells in the file myfile  in %)
!        (phase at entrance of cells)= (1 + fph/100) X (phase in myfile)
!  NOTE: fph is only available for cells of type = 0, type = 2 (type = E) or type = 5 (type R)
! --- pib > 0:  shift the particles at the entrance of the RFQ inside (+/-) pi w.r.t.the synchronous particle
! --- pib = 0: no action
!
!
! related files:
!
!     'rfq_list.data'  : list of parameters of the RFQ
!
!     'rfq_coeflist.data' list of coefficients
             myfile=''
             READ(in,'(A)') myfile
             lfile=LEN_TRIM(myfile)
             myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
             myfile(1:lpath)=dpath(1:lpath)
             myfile=TRIM(myfile)             
             write(16,*) 'RFQ input data file: ',myfile
             open(27,file=myfile,status='unknown')
             myfile='rfq_list.data'
             if(mcselect) myfile='rfq_list'//mc//'.data'
             lfile=LEN_TRIM(myfile)
             myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
             myfile(1:lpath)=dpath(1:lpath)
             myfile=TRIM(myfile)             
             open(70,file=myfile,status='unknown')
             myfile='rfq_coef.data'
             if(mcselect) myfile='mc'//mc//'rfq_coef.data'
             lfile=LEN_TRIM(myfile)
             myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
             myfile(1:lpath)=dpath(1:lpath)
             myfile=TRIM(myfile)             
             open(75,file=myfile,status='unknown')
             read(in,*) nceltot
             read(in,*) tvolt,avolt,fph,pib
             write(16,5279)nceltot,tvolt,avolt
5279         format(' RFQ number of cells: ',i5,/,
     *       '  factor on intervane voltage (reference):',e12.5,' %',
     *       /,'  factor on intervane voltage (bunch):',e12.5,' % ')
             tvolt=tvolt/100.
             avolt=avolt/100.
             fph=(1.+fph/100.)
             if(ichaes) then
               write(16,*)'***** beam current: ',beamc,' mA'
               if(iscsp.lt.3) then
                 write(ierr,*)'*** HERSC and SCHERM cannot be used in',
     *                      'the RFQ'
                 write(16,*)'*** HERSC and SCHERM cannot be used in',
     *                      'the RFQ'
                 stop
               endif
             endif
             call cpardyn(pib)             
             write(6,*)
             write(16,*) '****************************'
           ELSEIF(I.eq.43) then
! --- AFTER STRIPPER: stripper foils
! ---  ( based on the works of D.A. Eastham, ref.   )
! --- available for 'slow' hadron particles
! --- STRIPPER FOILS PARAMETERS:
! --- qs : charge (unit of charge)
! --- atms: atomic mass
! --- ths : thickness of the foils (g/cm**2)
! --- PARTICLES
!*2010-12-02 Use Baron formula for charge state distribution in case of carbon foils
! --- anp : atomic number of the projectile
! --- nqst: number of charge states after the stripper
! --- sqst: array holding the nsqt charge states
! --- qop : charge of particles after crossing the stripper foils (unit of charge)
! --- the atomic mass of particles (atm) is the one given in INPUT or in RDBEAM
             write(16,*) 'TYPE CODE: STRIPPER ************'
             read(in,*)qs,atms,ths,anp
             call stripp
             write(16,*) '********************************'
           ELSEIF(I.eq.44) then
!   AFTER STEER: thin steering element
!---- PARAMETERS ARE INTEGRATED FIELD fld, nvf
!     fld in units of (Tm) for magnetic steerer
!     fld in units of (kV*m/m) for electrostatic steerer
!     (Voltage * length / plate separation)
!     if nvf=0,  horizontal magnetic steerer
!     if nvf=1,  vertical magnetic steerer
!     if nvf=2,  horzontal electrostatic steerer
!     if nvf=3,  vertical electrostatic steerer
             write(16,*) 'TYPE CODE: STEER ***************'
             read(in,*) fld,nvf
             call steer(fld,nvf)
             write(16,*) '********************************'
!  start of writes in file '.short' for steerer
             idav=idav+1
             iitem(idav)=9
             dav1(idav,1)=fld
             dav1(idav,2)=float(nvf)
             dav1(idav,3)=davtot*10.
!  end daves
           ELSEIF(I.eq.45) then
!  AFTER ZONES: specify zones of different colours in the bunch
             write(16,*) 'TYPE CODE: ZONES ***************'
             init=1
             call area(init)
             write(16,*) '********************************'
           ELSEIF(I.eq.46) then
!  AFTER PROFGR: X-Z and Y-Z scatter plots,(X,Y,Z) and (Xp,Yp,Zp) profiles
             write(16,*) 'TYPE CODE: PROFGR **************'
             igrprm=0
             if (igrprm.eq.0) then
!        READ GRAPH TITLE
               READ(IN,6620) TEXT
6620           FORMAT(A)
! idwdp=0 cog=ref in XZ,YZ plots (for instance for Alvarez structure)
! idwdp=1 cog<>ref in XZ,YZ plots (for instance for IH structrure)
! iskale=0 vertical scale on profile plots is NOT a log scale
! iskale=1 vertical scale on profile plots IS a log scale
               READ(IN,*) idwdp,iskale
!        READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!        K=1 HOR. LIMIT , K=2 VERT. LIMIT
               READ(IN,*) GLIM(3,1),GLIM(3,2),GLIM(4,1),GLIM(4,2)
             endif
             call grcomp(text,iskale)
             write(16,*) '****************************'
           ELSEIF(I.eq.47) then
!  AFTER SECORD : second order matrix for optical lenses
             write(16,*) 'TYPE CODE: SECORD **************'
             write(16,*) ' SECOND ORDER IN BEAM TRANSPORT'
             ISEOR=.TRUE.
             write(16,*) '********************************'
           ELSEIF(I.eq.48) then
!  AFTER RASYN : Radiation exitation in bending magnets (only for electrons)
             write(16,*) 'TYPE CODE: RASYN ***************'
             write(16,*) ' SYNCHRTRON RADIATION IN BENDING MAGNET'
             IRAYSH=.TRUE.
             write(16,*) '********************************'
           ELSEIF(I.eq.49) then
!  AFTER FDRIFT : Divide a drift length in partial drifts (for space charge computations)
             write(16,*) 'TYPE CODE: FDRIFT **************'
!  XL    : Total drift length (cm)
!  NPART : number of partial drifts
!  IMIT  : if IMIT not equal zero,print emittance datas in the file 'short.txt'
             read(in,*) xl,npart,imit
             dl=xl/float(npart)
             write(16,*) ' total drift length : ',xl,
     *       ' cm divided in : ',npart,' drifts of : ',dl,' cm'
             call fdrift(xl,npart,imit)
             write(16,*) '********************************'
           ELSEIF(I.eq.50) then
!AFTER FSOLE: solenoid the magnetic field is read from disk in the form (z,B(z))
!              unities: z (m), B(z) kG
!   BCRET : coefficient multiplier, the magnetic is: B(z) * BCRET
!   sign field convention like in the code TRANSPORT
             write(16,*) 'TYPE CODE: FSOLE ***************'
             myfile=''
             READ(in,'(A)') myfile
!     unit 25 corresponds to an input file giving solenoid magnetic field(s) in the form (z,B(z))
!      check if file is already open
             iostats = int(FTELL(25))
             if(iostats.eq.-1) then
! file not yet open
               lfile=LEN_TRIM(myfile)
               myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
               myfile(1:lpath)=dpath(1:lpath)
               myfile=TRIM(myfile)
               open(25,file=myfile,status='unknown')
               write(16,*) 'Opening solenoid field file: ',
     *                     myfile
               ofelds=myfile
             else
               if(ofeldf.ne.myfile) then
                 write(16,*) 'Closing solenoid field file: ',ofelds
                 write(16,*) 'Opening solenoid field file: ',
     *                     myfile
                 close(25)
                 lfile=LEN_TRIM(myfile)
                 myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
                 myfile(1:lpath)=dpath(1:lpath)
                 myfile=TRIM(myfile)
                 open(25,file=myfile,status='unknown')
                 ofelds=myfile
               endif
             endif
             read(in,*)bcret,intgr
             write(16,990) intgr
990          format('*** SOLENOID WITH ARBITRARY MAGNETIC FIELD ',/,
     *        5x,'PARTITION IN: ',i4,' ELEMENTARY SOLENOIDS')
             call solfield(bcret,intgr)
             write(16,*) '********************************'
           ELSEIF(I.eq.51) then
! AFTER EGUN:
!     Only the SCHEFF routine is avalaible in the routine EGUN
!omment       ichaes=.false.
             write(16,*) 'TYPE CODE: EGUN ****************'
!     unit 22 corresponds to an input file giving egun field (z,E(z)) E(z) normalised
             myfile=''
             READ(in,'(A)') myfile
             lfile=LEN_TRIM(myfile)
             myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
             myfile(1:lpath)=dpath(1:lpath)
             myfile=TRIM(myfile)
             write(16,*) 'Egun field file: ',myfile
             open(22,file=myfile,status='unknown')
!  follows the particle ifpt (not active)
! not actived       read(in,*)ifpt
!    fmult: field factor
             read(in,*)fmult,indp
             if(.not.ichaes) indp=1
!  indp: number of space charge computations to be made in the EGUN
!   indp = 1 : 8 space charge computations. The EGUN field is divided in 16 elements
!   indp = 2 : 16 space charge computations.                          in 32 elements
!   indp = 3 : 32 space charge computations.                          in 64 elements
             if(ichaes) then
               write(16,3777)beamc
3777           format(7x,'Beam current  =',F10.4,'      mA')
               if(iscsp.lt.3) then
                 write(ierr,*)'*** HERSC and SCHERM cannot be used',
     *                      'with EGUN; use SCHEFF instead'
                 write(16,*)'*** HERSC and SCHERM cannot be used with',
     *                      'with EGUN; use SCHEFF instead'
                 stop
               endif
             endif
             call egun(fmult,indp)
             write(16,*) '********************************'
           ELSEIF(I.eq.52) then
! AFTER COMPRES
!  Do so by shifting particles belonging to the same bunch outside the (+/-) pib/2 (deg) window
!   w.r.t.the COG to inside the (+/-) pib/2 window w.r.t.the COG
             write(16,*) 'TYPE CODE: COMPRES *************'
! --- pib (deg)
             read(in,*) pib
             pib=pib/2.
             write(16,1890) pib
             call compress(pib)
1890         format('*** shift particles inside +/- ',e12.5, 'deg')
             write(16,*) '********************************'
           ELSEIF(I.eq.54) then
!   AFTER REFCOG:
!    ISHIFT  = 0: the synchronous particle and the cog are coinciding (shift = false)
!    ISHIFT  = 1: the synchronous particle and the cog are separated   (shift = true)
!    ISHIFT  = 2: at the start the TOF of synchronous particle  is the TOF of the cog
!                   after synchronous particle and cog are separated (shift = true)
!    (at the begining shift = false)
             write(16,*) 'TYPE CODE: REFCOG **************'
             read(in,*) ishift
             if(ishift.eq.0) then
               shift=.false.
               write(16,*)' Synchronous particle is the COG of the',
     *                    ' bunch'
               obref=vref/vl
               ogref=1./SQRT(1.-(obref*obref))
               otref=tref
               owref=XMAT*(ogref-1.)
               tcog=0.
               wcog=0.
               do ijp=1,ngood
                 wcog=wcog+f(7,ijp)
                 tcog=tcog+f(6,ijp)
               enddo
               wcog=wcog/float(ngood)
               tcog=tcog/float(ngood)
               gcog=wcog/xmat
               bcog=sqrt(gcog*gcog-1.)/gcog
               vref=bcog*vl
               tref=tcog
               fcpi=fh*180./pi
               write(16,5433)obref,owref,otref*fcpi,vref/vl,
     *           wcog-xmat,tref*fcpi,bcog,wcog-xmat,tcog*fcpi
5433           format(' old REF beta: ',e12.5,' energy: ',e14.7,
     *           ' MEV TOF: ',e12.5,' deg',
     *         /,' new REF beta: ',e12.5,' energy: ',e14.7,
     *           ' MEV TOF: ',e12.5,' deg',/,' COG     beta: ',
     *         e12.5,' energy: ',e14.7,' MeV TOF: ',e12.5,' deg')
!        write(16,*) 'old TTVOL (deg): ',ottvols*fcpi
!        write(16,*) 'new TTVOL (deg): ',ttvols*fcpi
             endif
             if(ishift.eq.1) then
               shift=.true.
               bref=vref/vl
               gref=1./SQRT(1.-(bref*bref))
               wref=XMAT*(gref-1.)
               tcog=0.
               wcog=0.
               do ijp=1,ngood
                 wcog=wcog+f(7,ijp)
                 tcog=tcog+f(6,ijp)
               enddo
               wcog=wcog/float(ngood)
               tcog=tcog/float(ngood)
               gcog=wcog/xmat
               bcog=sqrt(gcog*gcog-1.)/gcog
               fcpi=fh*180./pi               
               write(16,*)' Synchronous particle and COG of the ',
     *         'bunch are independent'
               write(16,5443) bref,wref,tref*fcpi,
     *                        bcog,wcog-xmat,tcog*fcpi
5443           format(' REF beta: ',e12.5,' energy: ',
     *          e14.7,' MeV TOF: ',e12.5,' deg',/,
     *         ' COG beta: ',e12.5,' energy: ',e14.7,
     *         ' MeV TOF: ',e12.5,' deg')     
             endif
             if(ishift.gt.1) then
               write(16,*)
               write(16,*)' Synchronous particle and COG of the ',
     *         'bunch are independent, but initially'
               write(16,*)' TOF and energy of the synchronous ',
     *         'particle are the ones of the bunch'
               shift=.true.
! --- the reference is the cog
               obref=vref/vl
               otref=tref
               ogref=1./SQRT(1.-(obref*obref))
               otref=tref
               owref=XMAT*(ogref-1.)
               wcog=0.
               tcog=0.
               do ijp=1,ngood
                 wcog=wcog+f(7,ijp)
                 tcog=tcog+f(6,ijp)
               enddo
               wcog=wcog/float(ngood)
               tcog=tcog/float(ngood)
               gcog=wcog/xmat
               bcog=sqrt(gcog*gcog-1.)/gcog
               vref=bcog*vl
               tref=tcog
               ottvols=ttvols
               if(itvol) ttvols=tref
               fcpi=fh*180./pi
!        write(16,5420)obref,otref*fcpi,obref,tref*fcpi
               write(16,5420)obref,owref,otref*fcpi,vref/vl,
     *                       wcog-xmat,tref*fcpi
5420           format(' old REF beta: ',e12.5,' energy: ',
     *          e14.7,' MeV TOF: ',e12.5,' deg',/,
     *         ' new REF beta: ',e12.5,' energy: ',
     *          e14.7,' MeV TOF: ',e12.5,' deg')
!               write(16,*) 'old ref. TOF (deg): ',ottvols*fcpi
!               write(16,*) 'new ref. TOF (deg): ',ttvols*fcpi
             endif
             write(16,*) '****************************'
           ELSEIF(I.eq.55) then
!   AFTER FPART:
! --- a given particle is followed in the accelerating elements
! --- ICONT : the number of the particle followed in accelerating elements
             write(16,*) 'TYPE CODE: FPART ***************'
             read(in,*) icont
             write(16,*) ' the particle:',icont,' is followed'
             write(16,*) '********************************'
           ELSEIF(I.eq.56) then
!    AFTER QUAELEC: electric quadrupole
!       VOLT: voltage at pole tip (kV)
!       XLQUA: effective length  (cm)
!       RS: radial distance of pole tip from axis (cm)
             write(16,*) 'TYPE CODE: QUALEC **************'
             READ(IN,*)XLQUA,VOLT,RS
             call qelec(volt,xlqua,rs)
             write(16,*) '********************************'
           ELSEIF(I.eq.57) then
!    AFTER QUAFK:  quadrupole (magnetic or electric)
!       ITYQU: ITYQU = 0 electric quadrupole , otherwise magnetic quadrupole
!       ARG: K2 (cm-2)
!       XLQUA: effective length  (cm)
!       RS: radial distance of pole tip from the axis (cm)
             write(16,*) 'TYPE CODE: QUAFK ***************'
             READ(IN,*)ITYQU,ARG,XLQUA,RS
             call qfk (ityqu,arg,xlqua,rs)
             write(16,*) '********************************'
           ELSEIF(I.eq.58) then
!    AFTER CAVNUM: numerical computation of multicell cavities
!           the electromagnetic field can be read:on the disk in the form (z,E(z))
!           or from the type code: HARM in the form of a Fourier series expansion
             write(16,*) 'TYPE CODE: CAVNUM **************'
             call cavnum
             write(16,*) '********************************'
           ELSEIF(I.eq.59) then
!     AFTER EDFLEC:  ELECTROSTATIC DEFLECTOR
! --- Input parameters
!   radial radius (cm)
!   bend angle (deg)
!   radii: vertical (radial) radii of curvature (cm)
             write(16,*) 'TYPE CODE: EDFLEC **************'
             call e_deflec
             write(16,*) '********************************'
           ELSEIF(I.eq.60) then
!    AFTER EMITL  Print emittance datas in the file 'dynac.short' but
!                 also read label to be written to dynac.short
             write(16,*) 'TYPE CODE: EMITL ***************'
             read(in,'(A)') shortl
             call emiprt(1)
           ELSEIF(I.eq.61) then
!  After RFKICK: Electric RF kicker
!      PV: Voltage Factor (Voltage (kV) * electrode length (m) / gap (m))
!      PDP: PHASE OF RF (deg)
!      PHARM: harmonic factor (bucher fq.)/(DTL freq.)
!      NVF: 0 = horizontal, 1 = vertical
             write(16,*) 'TYPE CODE: RFKICK **************'
             READ(IN,*) pv,pdp,pharm,nvf
             plane='horizontal'
             if(nvf.eq.1) plane='vertical  '
             write(16,7779) pv,pdp,plane
7779         format(' RF Kicker ',/,' Voltage Factor',E12.5,' kV*m/m'
     X       ,/,' RF Phase ',e12.5,' deg',' Type: ',a10)
             pdp=pdp*pi/180.
             call rfkick(pv,pdp,pharm,nvf)
             write(16,*) '********************************'
           ELSEIF(I.eq.62) then
!  AFTER FIRORD : first order matrix for optical lenses
             write(16,*) 'TYPE CODE: FIRORD **************'
             write(16,*) '  FIRST ORDER IN BEAM TRANSPORT'
             ISEOR=.FALSE.
             write(16,*) '********************************'
           ELSEIF(I.eq.63) then
!  AFTER DCBEAM : select DC or bunched beam
             READ(IN,*) iscont
             write(16,*) '********************************'
             write(16,*) 'TYPE CODE: DCBEAM **************'
             if(iscont.eq.1) then
               ifcont=.true.
               write(16,*) ' DC BEAM SELECTED    ***********'
             elseif(iscont.eq.0) then
               ifcont=.false.
               write(16,*) ' BUNCHED BEAM SELECTED *********'
             endif
             write(16,*) '********************************'
           ELSEIF(I.eq.64) then
!  AFTER T3D : request TRACE3D input file
             T3D=.true.
             write(16,*) '********************************'
             write(16,*) 'TYPE CODE: T3D *****************'
             write(16,*) ' TRACE3D INPUT FILE WILL BE WRITTEN'
             write(16,*) '********************************'
           ELSEIF(I.eq.65) then
!  AFTER MHB : multi-harmonic buncher
             write(16,*) '********************************'
             write(16,*) 'TYPE CODE: MHB *****************'
             write(16,*) '  MULTI-HARMONIC BUNCHER       *'
             write(16,*) '********************************'
             call buncnum             
           ELSEIF(I.eq.66) then
!  AFTER BINDIST : binary files will be read or written
             write(16,*) '********************************'
             write(16,*) 'TYPE CODE: BINDIST *************'
             write(16,*) '* Binary .dst files will be used '
             write(16,*) '********************************'
             bindst=.true.
           ELSEIF(I.eq.67) then
!    AFTER EMITGRD: emittance density plots
!    PLOTS IN XX', YY', XY AND ZZ'
             write(16,*) 'TYPE CODE: EMITGRD *************'
             igrprm=0
             call ytzp2d
             write(16,*) '********************************'
           ELSEIF(I.eq.68) then
!    AFTER PROFGRD: X-Z and Y-Z density plots,(X,Y,Z) and (Xp,Yp,Zp) profiles
             write(16,*) 'TYPE CODE: PROFGRD *************'
             igrprm=0
             if (igrprm.eq.0) then
!        READ GRAPH TITLE
               READ(IN,'(A)') TEXT
! idwdp=0 cog=ref in XZ,YZ plots (for instance for Alvarez structure)
! idwdp=1 cog<>ref in XZ,YZ plots (for instance for IH structrure)
! iskale=0 vertical scale on profile plots is NOT a log scale
! iskale=1 vertical scale on profile plots IS a log scale
               READ(IN,*) idwdp,iskale
!        READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!        K=1 HOR. LIMIT , K=2 VERT. LIMIT
               READ(IN,*) GLIM(3,1),GLIM(3,2),GLIM(4,1),GLIM(4,2)
             endif
             call grcomp2d(text,iskale)
             write(16,*) '****************************'
           ELSEIF(I.eq.53) then
!  AFTER STOP: mandatory, stop the computations
             write(16,*) 'TYPE CODE: STOP ****************'
             tcog=0.
             wcog=0.
             do ijp=1,ngood
               wcog=wcog+f(7,ijp)
               tcog=tcog+f(6,ijp)
             enddo
             if(ngood.ne.0) then
               wcog=wcog/float(ngood)
               tcog=tcog/float(ngood)
               gcog=wcog/xmat
               bcog=sqrt(gcog*gcog-1.)/gcog            
! store END data for .dmp file       
!             dmpdat(1)=davtot/100.
!             dmpdat(2)=100.*float(ngood/imax)
!             dmpdat(3)=0.
!             dmpdat(4)=tcog*180.*fh/pi
!             dmpdat(5)=bcog
!             dmpdat(6)=(sqrt(1./(1.-bcog*bcog))-1.)*xmat
!             dmpdat(7)=tref*180.*fh/pi
!             bref=vref/vl
!             dmpdat(8)=bref
!             dmpdat(9)=(sqrt(1./(1.-bref*bref))-1.)*xmat
! dmpdat(10), dmpdat(11), dmpdat(12) loaded in emiprt
!             dmpdat(13)=0.              
!             dmpdat(14)=0.
               shortl='STOP card encountered; beam data are:'
               call emiprt(1)      
!             nd=0
!             write(50,*) '# end     Z       trans   ',
!     *   'dummy    TOF(COG)    COG        Wcog          TOF(REF)   ',
!     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
!     *   'El,RMS       dummy         dummy'
!             write(50,*) '#  #     (m)       (%)    ',
!     *  '          (deg)      beta       (MeV)          (deg)      ',
!     *  '   beta       (MeV)       (mm.mrad)    (mm.mrad)    (ns.keV)'
!             write(50,7023) nd,(dmpdat(j),j=1,14)
!7023         format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
!     *   2(e14.7,1x,f7.5,1x,e14.7,1x),7(e12.5,1x))
               write(16,100) kle(i)
             endif
             exit
           ENDIF
         ELSE
!! key not found, go to STOP
           indic=999
           WRITE(66,*) indic
           WRITE(16,111)KLEY
           WRITE(6,111) KLEY
           EXIT
         ENDIF
       ENDDO
! write trace file (if requested)
       if(T3D) then
! write trace file (header part)
         myfile=''
         myfile='for_trace3d.t3d'
         if(mcselect) myfile='mc'//mc//'for_trace3d.t3d'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(itout,file=myfile,status='unknown')
         write(itout,'(A)') trace3h(1)
         write(itout,1990) kt3t,kt3t,kt3t
1990     format(' N1= 1, N2= ',I4,', NEL1= 1, NEL2= ',I4,
     *        ', NP1= 1, NP2= ',I4)
         do i=2,kt3h
           write(itout,'(A)') trace3h(i)
         enddo
         write(itout,1992)
1992     format(' PQEXT= 2.5, ICHROM= 0, IBS= 0, SMAX= 2.0')
         write(itout,1993)
1993     format(' XM=  15.00, XPM=  50.00, YM=  15.00')
         write(itout,1994)
1994     format(' XMI= 15.00, XPMI= 50.00, XMF= 15.00, XPMF= 25.00')
         write(itout,1995)
1995     format(' DPM=  90.0, DWM=  50.00, DPP= 90.00')
         write(itout,1996)
1996     format(' DPMI= 90.0, DPMF= 35.00, DWMI= 50.0, DWMF= 200.0')
! write trace file (beam line part)
!
! deal with negative drifts (typical within DTLs)
! if the current drift is negative, then see if there is a drift before or
! after it. If so, add the 2 drifts, devide by 2 and put this result in both
! drifts
         do k=2,kt3t-1
           trdrifa=0.
           trdrifb=0.
           tif=trace3t(k)
           tifb=trace3t(k-1)
           tifa=trace3t(k+1)
           if(tif(12:13).eq.' 1' .and. tifb(12:13).eq.' 1') then
             read(tif(28:50),*) trdrift
             if(trdrift.lt.0.) then
               read(tifb(28:50),*) trdrifb
               if(trdrifb.gt.0.) then
                 aver=(trdrifb+trdrift)/2.
                 trdrifb=aver
                 trdrift=aver
!                 write(6,*) k,'beforeb',tif(12:13),trdrift,trdrifb
                 write(fdrft,555) trdrift
555              format(f12.6)
                 tif(28:40)=fdrft
                 write(fdrft,555) trdrifb
                 tifb(28:40)=fdrft
                 trace3t(k)=tif
                 trace3t(k-1)=tifb
               endif
             endif
           elseif(tif(12:13).eq.' 1' .and. tifa(12:13).eq.' 1') then
             read(tif(28:50),*) trdrift
             if(trdrift.lt.0.) then
               read(tifa(28:50),*) trdrifa
               if(trdrifa.gt.0.) then
                 aver=(trdrifa+trdrift)/2.
                 trdrifa=aver
                 trdrift=aver
!                 write(6,*) k,'aftera',tif(12:13),trdrift,trdrifa
                 write(fdrft,555) trdrift
                 tif(28:40)=fdrft
                 write(fdrft,555) trdrifa
                 tifa(28:40)=fdrft
                 trace3t(k)=tif
                 trace3t(k+1)=tifa
               endif
             endif
           endif
         enddo
         do k=1,kt3t
           write(itout,'(A)') trace3t(k)
         enddo
         write(itout,'(A)') ' $END'
       endif
       call daves(beame)
       call eugwrt
       call cpu_time(exfin)
       exfin=exfin-exstrt
       call mytime(iitime)
       write(6,*)
       if (mg) then
! using MINGW style gfortran format: 03/30/10 20:51:06 (10 is 2010)
         text(1:4)='    '
         if(iitime(1:2).eq.'01')text(5:7)='Jan'
         if(iitime(1:2).eq.'02')text(5:7)='Feb'
         if(iitime(1:2).eq.'03')text(5:7)='Mar'
         if(iitime(1:2).eq.'04')text(5:7)='Apr'
         if(iitime(1:2).eq.'05')text(5:7)='May'
         if(iitime(1:2).eq.'06')text(5:7)='Jun'
         if(iitime(1:2).eq.'07')text(5:7)='Jul'
         if(iitime(1:2).eq.'08')text(5:7)='Aug'
         if(iitime(1:2).eq.'09')text(5:7)='Sep'
         if(iitime(1:2).eq.'10')text(5:7)='Oct'
         if(iitime(1:2).eq.'11')text(5:7)='Nov'
         if(iitime(1:2).eq.'12')text(5:7)='Dec'
         text(8:8)=' '
         text(9:10)=iitime(4:5)
         text(11:13)=' 20'
         text(14:15)=iitime(7:8)
         text(16:19)=' at '
         text(20:27)=iitime(10:17)
       else
         text(1:11)=iitime(1:11)
         text(12:15)=iitime(21:24)
         text(16:19)=' at '
         text(20:27)=iitime(12:19)
       endif
       write(12,*) 'Stopped on ',text(1:27)
       write(16,*) 'Stopped on ',text(1:27)
       write(6,'(A11,A27)') 'Stopped on ',text(1:27)
       write(6,'(A12,F14.6,A4)') 'Executed in ',exfin,' sec'
       write(16,101)
!      close input files
       close(10)
       close(20)
       close(22)
       close(25)
       close(27)
       close(55)
!  close output files
!   files actived in the code
!   44=chase_emith.out
       close(44)
       close(45)
       close(46)
       close(16)
       close(12)
       close(71)
       close(50)
       close(61)
       close(60)
       close(11)
       close(66)
       close(75)
       close(49)
!  files not actived in the code
!  SV 24/08/2015
       close(13)
!old       close(14)
!omment       close(15)
!omment       close(17)
!omment       close(18)
!omment       close(19)
!omment       close(21)
!omment       close(49)
       close(70)
!       stop
111    FORMAT('STOP ON KEY: ',A8,' (invalid key)')
100    FORMAT(/,40X,' STOP on key  : ',A8,//)
101    FORMAT('*******************************************************',
     1 '*****************')
       END
!> *******************************************************************
!! SUBROUTINE mytime
!! get system time and convert it to an ascii string
!< *******************************************************************
       SUBROUTINE mytime(iitime)
       implicit real(8) (a-h,o-z)
       character iitime*30
       integer(8) inttim
       inttim=time8()
       iitime=ctime(inttim)
       return
       end
!> *******************************************************************
!! SUBROUTINE rmami
!! activate the time of flight for bunchers, cavities and accelerating
!! gaps
!! - indic and icor:integer flags
!! - itvol and imamin: logical flags
!! - itvol = true =>   the time of flight is activated, otherwise
!! - itvol = false =>  the time of flight is passive
!! - imamin = true =>  adjustments are automatically made on the phase
!! of bunchers, cavities and acc. gaps
!! - imamin = false => no adjustments on the phase of accelerating
!! elements
!! - indic = 0 => itvol = true, in this case the time of flight is
!! activited for accelerating elements
!! - indic (<>) 0 => itvol = false and imamin = false
!! - icor = 0 => imamin = false
!! - icor (<>) 0 => imamin = true
!< *******************************************************************
       SUBROUTINE rmami
       implicit real(8) (a-h,o-z)
       parameter (maxcell1=4004)
       common/tapes/in,ifile,meta,ierr
       common/dyn/tref,vref
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/itvole/itvol,imamin
       common/tofev/ttvols
       logical itvol,imamin
       fcpi=fh*180./pi
       ttvols=0.
       read(in,*) indic,icor
       if(indic.eq.0) then
        itvol=.true.
        ttvols=tref
        write(16,10) ttvols*fcpi,davtot,tref*fcpi
       else
        itvol=.false.
        write(16,*) 'time of flight passive '
       endif
10     FORMAT(' ** time of flight activated at: ',e12.5,
     * ' deg at position: ',e12.5,' cm in the lattice',
     * /,3x,'tof of the reference: ',e12.5,' deg')
       imamin = .false.
       if(itvol.and.icor.ne.0) imamin = .true.
       if(imamin)
     * write(16,*)' Adjustments on phase offset of acc. elements'
       if(.not.imamin)
     *  write(16,*) ' No adjustments on phase offset'
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE shuffle
!! Reshuffles f(i,j) array so that the "good" particles are on top of
!! the stack.  The number of "good" particles (ngood) is passed back.
!< *******************************************************************
       SUBROUTINE shuffle
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/mcs/imcs,ncstat,cstat(20)
       common/macro/ratei
       common/tapes/in,ifile,meta,ierr       
       k=ngood
       ngood1=0
       DO
         if(ngood1.ge.k) exit
         if(int(f(8,ngood1+1)).ne.1) then
           do j=1,10
             c=f(j,ngood1+1)
             f(j,ngood1+1)=f(j,k)
             f(j,k)=c
           enddo
           k=k-1
         else
           ngood1=ngood1+1
         endif          
       ENDDO
       ngood=ngood1
       if(ngood.eq.0) then
         ratei=0.
       else
         ratei=float(imax)/float(ngood)
       endif
!*ets*2015/05/20
       ncstat=1
       cstat(1)=f(9,1)
       do j=2,ngood
         mcstat=0
         do k=1,ncstat
!           if(f(9,j).eq.cstat(k)) then
           if(int(f(9,j)).eq.int(cstat(k))) then
             mcstat=1
           endif
         enddo
         if(mcstat.eq.0) then
           ncstat=ncstat+1
           cstat(ncstat)=f(9,j)
         endif
       enddo
       write(16,*) 'Number of charge states after shuffle: ',ncstat
       write(16,*) 'Charge state(s): ',(cstat(j),j=1,ncstat)
       imcs=0
       if(ncstat.gt.1) imcs=1
!*ete*2015/05/20
!omment       write(16,*) '***reshuffle: ',ngood,' good particles'
       if(ngood.lt.10) then
         write(16,*)'Less than 10 particles left, statistics too low'
         write(6,*)
         write(ierr,*)'Less than 10 particles left,statistics too low'
         stop
       endif
       return
       end
!> *******************************************************************
!! FUNCTION xitl0(GAMI,GAMS,BETR,SAPHI,QQC)
!! called by RESTAY and ETGAP  dynamics computations
!< *******************************************************************
       FUNCTION xitl0(GAMI,GAMS,BETR,SAPHI,QQC)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *              AA,BB,CC,DD,EE,PCREST,SQCTTF
       FH0=FH/VL
       CGI=QQC/XMAT
       BETI=SQRT(1.-1./(GAMI*GAMI))
       BETS=SQRT(1.-1./(GAMS*GAMS))
       XK1=FH0/BETI
       XK2=FH0/BETS
       XKM=FH0/BETR
       TILTA2=PHSLIP/(2.*EQVL)
       PAVPH=1./10.*(XK1- XK2)*EQVL
     X +(XK1-XKM)*ASDL
       XKC1=-FH0/(BETI**3 * GAMI**3)
       XKC2=-FH0/(BETS**3 * GAMS**3)
       DO I=1,2
         PHIT10=SAPHI-PHSLIP/2.+PAVPH
         DAZ0=COS(PHIT10)*TILTA2
         DBZ0=SIN(PHIT10)*TILTA2
         DGZ0=CGI*(TK*DAZ0-SK*DBZ0)
         DGZ0=DGZ0/SIN(PHSLIP/2.)
         XKP1=XKC1*DGZ0
         PHIT11=SAPHI+PHSLIP/2.+PAVPH
         DAZ1=COS(PHIT11)*TILTA2
         DBZ1=SIN(PHIT11)*TILTA2
         DGZ1=CGI*(TK*DAZ1-SK*DBZ1)
         DGZ1=DGZ1/SIN(PHSLIP/2.)
         XKP2=XKC2*DGZ1
         PAVPH=1./10.*(XK1- XK2)*EQVL
     X         +(XK1-XKM)*ASDL
         PAVPH=PAVPH+(XKP1+XKP2)*EQVL**2 / 120.
       ENDDO
       XK11=XK1-XKM
       XK22=XK2-XKM
       AA=XK11
       BB=XKP1/2.
       CCL1=-(4.*XK22+6.*XK11)/(EQVL**2)
       CCL2=-(3./2.*XKP1-XKP2/2.)/EQVL
       CC=CCL1+CCL2
       DDL1=(7.*XK22+8.*XK11)/(EQVL**3)
       DDL2=(3./2.*XKP1-XKP2)/(EQVL**2)
       DD=DDL1+DDL2
       EEL1=-(3.*XK22+3.*XK11)/(EQVL**4)
       EEL2=-(XKP1/2.-XKP2/2.)/(EQVL**3)
       EE=EEL1+EEL2
       PHIT0=SAPHI+PAVPH
       GIT = CGI * (
     X TK*COS(PHIT0)-SK*SIN(PHIT0))
       XITL0=GAMI+GIT
       RETURN
       END
!> *******************************************************************
!! FUNCTION xitl2(GAMI,GAMS,BETR,SAPHI,QQC)
!! called by RESTAY and ETGAP
!! INTEGRAL of S ( EZG * Z/(BETA*GAMA)**3  *DZ)
!! PHASE JUMP
!< *******************************************************************
       FUNCTION xitl2(GAMI,GAMS,BETR,SAPHI,QQC)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *                AA,BB,CC,DD,EE,PCREST,SQCTTF
       DIMENSION H(8),T(8)
       DATA H /.101228536,.222381034,.313706646,.362683783,
     1  .362683783,.313706646,.222381034,.101228536/
       DATA T /-.960289856,-.796666477,-.525532409,
     1  -.183434642,.183434642,.525532409,
     2  .796666477,.960289856/
       FH0=FH/VL
       CGI=QQC/XMAT
       XITL2=0.
       BETI=SQRT(1.-1./(GAMI*GAMI))
       BETS=SQRT(1.-1./(GAMS*GAMS))
       XK1=FH0/BETI
       XK2=FH0/BETS
       XKM=FH0/BETR
       TILTA2=PHSLIP/(2.*EQVL)
       DO I=1,8
         XCC= EQVL*(1.+T(I))/2.
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
         GIT = CGI * (
     X   TK*COS(PHIT0)-SK*SIN(PHIT0)  )
         GI=GAMI+GIT *
     X   SIN(XCC*TILTA2)/SIN(PHSLIP/2.)
         BI=SQRT(1.-1./(GI*GI))
         PHIT1=PHIT0+XCC*PHSLIP/(2.*EQVL)
         DAZ=COS(PHIT1)*TILTA2
         DBZ=SIN(PHIT1)*TILTA2
         DGZ=CGI*(TK*DAZ-SK*DBZ)
         DGZ=DGZ/SIN(PHSLIP/2.)
         EZ = XMAT/QQC * DGZ
         XINT=1./(BI*GI)
         XCC1=XCC+ASDL
         XITL2=XITL2+H(I)*XINT**3 *XCC1*EZ
       ENDDO
       XITL2=XITL2/2. *EQVL
       RETURN
       END
!> *******************************************************************
!! FUNCTION xitl3(GAMI,GAMS,BETR,NIT,SAPHI,QQC)
!! called by RESTAY and ETGAP
!! INTEGRAL  S ( EZG * Z/(BETA*GAMA)**3  *DZ)
!! PHASE AND ENERGY AT THE MIDDLE OF THE GAP
!< *******************************************************************
       FUNCTION xitl3(GAMI,GAMS,BETR,NIT,SAPHI,QQC)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *               AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/MIDGAP/ENMIL,VAPMI
       COMMON/gaus13/H(13),T(13)
       common/sgcos/xkpc
       FH0=FH/VL
       CGI=QQC/XMAT
       XITL3=0.
       BETI=SQRT(1.-1./(GAMI*GAMI))
       BETS=SQRT(1.-1./(GAMS*GAMS))
       XK1=FH0/BETI
       XK2=FH0/BETS
       XKM=FH0/BETR
       XK11=XK1-XKM
       TILTA2=PHSLIP/(2.*EQVL)
       DO I=1,13
         XCC= EQVL*(1.+T(I))/2.
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
         GIT = CGI * (TK*COS(PHIT0)-SK*SIN(PHIT0))
         GI=GAMI+GIT * SIN(XCC*TILTA2)/SIN(PHSLIP/2.)
         BI=SQRT(1.-1./(GI*GI))
         PHIT1=PHIT0+XCC*PHSLIP/(2.*EQVL)
         DAZ=COS(PHIT1)*TILTA2
         DBZ=SIN(PHIT1)*TILTA2
         DGZ=CGI*(TK*DAZ-SK*DBZ)
         DGZ=DGZ/SIN(PHSLIP/2.)
         EZ = XMAT/QQC * DGZ
         XINT=1./(BI*GI)
         XCC1=XCC+ASDL
         XITL3=XITL3+H(I)*XINT**3 *XCC1*EZ
!     ENERGY AND PHASE AT THE MIDDLE OF THE GAP
         IF(NIT.EQ.3.AND.I.EQ.7) THEN
!          ENMIL=XMAT*(GI-GAMI)
           ENMIL=XMAT*(GI-1.)
           VAPMI=(XK11*ASDL+SAPHI+XKM*XCC1+AA*XCC+
     *     BB*XCC*XCC+CC*XCC**3+DD*XCC**4+EE*XCC**5)*180./PI
         ENDIF
       ENDDO
       XITL3=XITL3/2. *EQVL
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE xtypl2(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! integrals of the second derivative of the functions HA0(z) and HB0(z)
!! ZB = Z+ASDL
!< *******************************************************************
       SUBROUTINE xtypl2(GAMI,SAPHI,QSC,DCG)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *               AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/THAD2/H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM,
     X              H1AKI,H1AKIM,H1AKM,H1BKI,H1BKIM,H1BKM
       common/gaus17/H1(17),T1(17)
       fprec=epsilon(PHSLIP)
       FH0=FH/VL
       CGI=QSC/XMAT
       GAM2=GAMI**2
       BETI=SQRT(1. - 1./GAM2 )
       XK1=FH0/BETI
!     circular functions in cos
       H0AKI=0.
       H0AKIM=0.
       H0AKM=0.
       H1AKI=0.
       H1AKIM=0.
       H1AKM=0.
!     circular functions in sin
       H0BKI=0.
       H0BKIM=0.
       H0BKM=0.
       H1BKI=0.
       H1BKIM=0.
       H1BKM=0.
!
       DTILK=EQVL
       TILTA2=PHSLIP/(2.*EQVL)
       CGAM10=((GAMI*GAMI-1.)**3)/(FH0*FH0)
       DGAM10=GAMI*((GAMI*GAMI-1.)**2)/(FH0*FH0)
       PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
       DPHC1=(T2K*SK-S2K*TK)/(TK*TK+SK*SK)
       DPHC2=(T1K*TK+S1K*SK)*(T1K*SK-S1K*TK)/
     X ((TK*TK+SK*SK)**2)
       DPHCRTK=DPHC1-2.*DPHC2
       BIM1=BETI
       GAKM1=0.
       GAIT=GAMI
       do i=1,17
         XCC= EQVL*(1.+H1(I))/2.
         XCC1=XCC+ASDL
         IF(XCC1.GT.DCG) EXIT
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
!        Function GAMMA (Z)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
           GIS =  SIN(XCC*TILTA2)
         ELSE
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
           GIS =  XCC/(2.*EQVL)
         ENDIF
         GITC=GIT * GIS
         GI=GAMI+GIT * GIS
         BI=SQRT(1.-1./(GI*GI))
!        FONCTION DERIVE G0(Z) RELATIF A K MOYEN
         PHIT0K=-DTILK*(1.-XCC/EQVL)/2.
!        DERIVE PREMIERE FONGTION GAMMA
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIC =  COS(XCC*TILTA2)
           GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
           GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
           GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.*PHSLIP*EQVL)
           GAK =CGI * SQCTTF* (-GAK1-GAK2+GAK3)
         ELSE
           GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
           GAK =-CGI * SQCTTF* GAK1
         ENDIF
!      Second derivative of GAMMA(z)
!         if(gi.ne.gait) then
         if(abs(gi-gait).gt.fprec) then
           DGAK=(GAK-GAKM1)/(GI-GAIT) *GAK
         else
           dgak=0.
         endif
         GAKM1=GAK
         GAIT=GI
         XCC1=XCC+ASDL
         PHIT1=PHIT0+XCC*PHSLIP/(2.*EQVL)
         PHTZ0=(XCC/EQVL-.5)*DTILK
         DPHTZ0=DTILK/EQVL
         PHCRZ0=(PHTZ0-PHCRTK)
!      INTEGRALES FONCTIONS HAKI(Z) (a multipler par (k1i-k10)**2 )
         HAKI1=SQCTTF*COS(PHIT1-PCREST)/((GI*GI-1.)**2.5)
         HAKI2=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.)**2.5)
         HAKI3=SQCTTF*COS(PHIT1-PCREST)*GI*GI/((GI*GI-1.)**3.5)
!        n=0
         H0AKI=H0AKI+T1(I)*CGAM10*(-3.*HAKI1+15*HAKI3)-
     X         T1(I)*DGAM10*9.*HAKI2
!        n=1
         H1AKI=H1AKI+T1(I)*CGAM10*XCC1*(-3.*HAKI1+15.*HAKI3)-
     X         T1(I)*DGAM10*9.*HAKI2*XCC1
!  Integral of HAKIM(Z) (to be multiplied by (k1i-k10)*(kmi-km0) )
         HAKIM1=SQCTTF*COS(PHIT1-PCREST)*GAK/((GI*GI-1.)**2.5)
         HAKIM2=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAK/((GI*GI-1.)**3.5)
         HAKIM2=HAKIM2
         HAKIM3=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.)**2.5)
!        n=0
         H0AKIM=H0AKIM+T1(I)*SQRT(CGAM10)*(6.*HAKIM1-30.*HAKIM2 -
     X          3.*PHCRZ0*HAKIM3)
!        n=1
         H1AKIM=H1AKIM+T1(I)*SQRT(CGAM10)*(6.*HAKIM1-30.*HAKIM2 -
     X          3.*PHCRZ0*HAKIM3)*XCC1
!  Integral of HAKM(Z) (to be multiplied by (kmi-km0)**2  )
         HAKM1=SQCTTF*COS(PHIT1-PCREST)*GAK*GAK/((GI*GI-1.)**2.5)
         HAKM2=SQCTTF*COS(PHIT1-PCREST)*DGAK*GI/((GI*GI-1.)**2.5)
         HAKM3=SQCTTF*COS(PHIT1-PCREST)*GAK*GAK*GI*GI/
     X         ((GI*GI-1.)**3.5)
         HAKM4=SQCTTF*SIN(PHIT1-PCREST)*GAK*GI/
     X         ((GI*GI-1.)**2.5)
         HAKM5=SQCTTF*COS(PHIT1-PCREST)/
     X         ((GI*GI-1.)**1.5)
         HAKM6=SQCTTF*SIN(PHIT1-PCREST)/
     X         ((GI*GI-1.)**1.5)
!        n=0
         H0AKM=H0AKM+T1(I)*(-3.*HAKM1-3.*HAKM2+15.*HAKM3 +
     X         3.*PHCRZ0*HAKM4 -
     X         PHCRZ0*PHCRZ0*HAKM5+DPHCRTK*HAKM6)
!        n=1
         H1AKM=H1AKM+T1(I)*XCC1*(-3.*HAKM1-3.*HAKM2+15.*HAKM3 +
     X         3.*PHCRZ0*HAKM4 -
     X         PHCRZ0*PHCRZ0*HAKM5+DPHCRTK*HAKM6)
!
!      INTEGRALES FONCTIONS HBKI(Z) (a multipler par (k1i-k10)**2 )
         HBKI1=SQCTTF*SIN(PHIT1-PCREST)/((GI*GI-1.)**2.5)
         HBKI2=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.)**2.5)
         HBKI3=SQCTTF*SIN(PHIT1-PCREST)*GI*GI/((GI*GI-1.)**3.5)
!        n=0
         H0BKI=H0BKI+T1(I)*CGAM10*(-3.*HBKI1+15.*HBKI3) -
     X               T1(I)*DGAM10*9.*HBKI2
!        n=1
         H1BKI=H1BKI+T1(I)*CGAM10*XCC1*(-3.*HBKI1+15.*HBKI3) -
     X              T1(I)*DGAM10*9.*HBKI2*XCC1
!  Integral of HBKIM(Z) (to be multiplied by (k1i-k10)*(kmi-km0) )
         HBKIM1=SQCTTF*SIN(PHIT1-PCREST)*GAK/((GI*GI-1.)**2.5)
         HBKIM2=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAK/((GI*GI-1.)**3.5)
         HBKIM2=HBKIM2
         HBKIM3=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.)**2.5)
!        n=0
         H0BKIM=H0BKIM+T1(I)*SQRT(CGAM10)*(6.*HAKIM1-30.*HAKIM2 +
     X          3.*PHCRZ0*HAKIM3)
!        n=1
         H1BKIM=H1BKIM+T1(I)*SQRT(CGAM10)*(6.*HAKIM1-30.*HAKIM2 +
     X          3.*PHCRZ0*HAKIM3)*XCC1
!  Integral of HBKM(Z) (to be multiplied by (kmi-km0)**2  )
         HBKM1=SQCTTF*SIN(PHIT1-PCREST)*GAK*GAK/((GI*GI-1.)**2.5)
         HBKM2=SQCTTF*SIN(PHIT1-PCREST)*DGAK*GI/((GI*GI-1.)**2.5)
         HBKM3=SQCTTF*SIN(PHIT1-PCREST)*GAK*GAK*GI*GI/
     X         ((GI*GI-1.)**3.5)
         HBKM4=SQCTTF*COS(PHIT1-PCREST)*GAK*GI/
     X         ((GI*GI-1.)**2.5)
         HBKM5=SQCTTF*SIN(PHIT1-PCREST)/
     X         ((GI*GI-1.)**1.5)
         HBKM6=SQCTTF*COS(PHIT1-PCREST)/
     X         ((GI*GI-1.)**1.5)
!       n=0
         H0BKM=H0BKM+T1(I)*(-3.*HBKM1-3.*HBKM2+15.*HBKM3 -
     X         3.*PHCRZ0*HBKM4 -
     X         PHCRZ0*PHCRZ0*HBKM5-DPHCRTK*HBKM6)
!       n=1
         H1BKM=H1BKM+T1(I)*XCC1*(-3.*HBKM1-3.*HBKM2+15.*HBKM3-
     X         3.*PHCRZ0*HBKM4 -
     X         PHCRZ0*PHCRZ0*HBKM5-DPHCRTK*HBKM6)
       enddo
!    integrals in cos
       H0AKI=H0AKI/2. *EQVL
       H0AKIM=H0AKIM/2. *EQVL
       H0AKM=H0AKM/2. *EQVL
       H1AKI=H1AKI/2. *EQVL
       H1AKIM=H1AKIM/2. *EQVL
       H1AKM=H1AKM/2. *EQVL
!    integrals in sin
       H0BKI=H0BKI/2. *EQVL
       H0BKIM=H0BKIM/2. *EQVL
       H0BKM=H0BKM/2. *EQVL
       H1BKI=H1BKI/2. *EQVL
       H1BKIM=H1BKIM/2. *EQVL
       H1BKM=H1BKM/2. *EQVL
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE xtyplp1(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! Integrals of functions  HA0(Z) and HB0(Z)
!! Integrals of the first and second derivative of HA0(Z) et HB0(Z)(with PH01)
!! Integrals of the third derivative of HA0(Z) et HB0(Z)(with PH01)
!! zb = z+ASDL
!< *******************************************************************
       SUBROUTINE xtyplp1(GAMI,SAPHI,QSC,DCG)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/JACOB/GAKS,GAPS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *               AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/TYPLP1/YH1P1,YH2P1,HAPI,HBPI
       COMMON/TYPLP2/HAPPI,HBPPI
       common/gaus17/H1(17),T1(17)
       fprec=epsilon(PHSLIP)
       FH0=FH/VL
       CGI=QSC/XMAT
       GAM2=GAMI**2
       BETI=SQRT(1. - 1./GAM2 )
       XK1=FH0/BETI
       DTILK=EQVL
!     circular functions in cos
       YH1P1=0.
       HAPI=0.
       HAPPI=0.
!     circular functions in sin
       YH2P1=0.
       HBPI=0.
       HBPPI=0.
       TILTA2=PHSLIP/(2.*EQVL)
!       IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.)
!       IF(PHSLIP.EQ.0.) DESY=2.
       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.)
       IF(abs(PHSLIP).LE.fprec) DESY=2.
       do i=1,17
         XCC= EQVL*(1.+H1(I))/2.
         XCC1=XCC+ASDL
         IF(XCC1.GT.DCG) EXIT
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
!        FONCTION GAMMA (Z)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
           GIS =  SIN(XCC*TILTA2)
         ELSE
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
           GIS =  XCC/(2.*EQVL)
         ENDIF
         GI=GAMI+GIT * GIS
         BI=SQRT(1.-1./(GI*GI))
!        FONCTION DERIVE G0(Z) RELATIF A PH01
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GAP=-CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
!          DERIVE TROISIEME
           DDGAP=-GAP
         ELSE
           GAP = SIN(PHIT0-PCREST)*GIS
           GAP = -CGI * SQCTTF* GAP
           DDGAP=-GAP
         ENDIF
         IF(I.EQ.17) GAPS=GAP
!        Second derivative of G0(Z) in relation with  PH01
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           DGAP=-CGI*SQCTTF*COS(PHIT0-PCREST)*GIS/PHSLIP
         ELSE
           DGAP = COS(PHIT0-PCREST)*GIS
           DGAP = -CGI * SQCTTF*DGAP
         ENDIF
!        INTEGRALES FONCTIONS HA0(Z) et HB0(Z)
         XINT=1./(BI*BI*BI*GI*GI*GI)
         PHIT1=PHIT0+XCC*PHSLIP/(2.*EQVL)
         PHTZ0=(XCC/EQVL-.5)*DTILK
!        INTEGRALES DERIVES HA0(Z)
         DHA01=SQCTTF*COS(PHIT1-PCREST)*GI*GAP/((GI*GI-1.)**2.5)
         DHA02=0.
!        n=1
         YH1P1=YH1P1+T1(I)*XCC1*(-6.*DHA01-2.*DHA02)
!        INTEGRALES DERIVES  HB0(Z)
         DHB01=SQCTTF*SIN(PHIT1-PCREST)*GI*GAP/((GI*GI-1.)**2.5)
         DHB02=0.
!        n=1
         YH2P1=YH2P1+T1(I)*XCC1*(-6.*DHB01+2.*DHB02)
!        INTEGRALES HAPI(Z) (multiplies par (ph1i-ph10)**2 )
         HAPI1=SQCTTF*COS(PHIT1-PCREST)*GAP*GAP/((GI*GI-1.)**2.5)
         HAPI2=SQCTTF*COS(PHIT1-PCREST)*GI*DGAP/((GI*GI-1.)**2.5)
         HAPI3=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP*GAP/
     X         ((GI*GI-1.)**3.5)
!        n=1
         HAPI=HAPI+T1(I)*XCC1*(-3.*HAPI1-3.*HAPI2+15.*HAPI3)
!        INTEGRALES HAPPI(Z) (multiplies par (ph1i-ph10)**3 )/3
         HAPPI1=SQCTTF*COS(PHIT1-PCREST)*GAP*DGAP/
     X         ((GI*GI-1.)**2.5)
         HAPPI2=SQCTTF*COS(PHIT1-PCREST)*GAP*GAP*GAP*GI/
     X         ((GI*GI-1.)**3.5)
         HAPPI3=SQCTTF*COS(PHIT1-PCREST)*GAP*DGAP/
     X         ((GI*GI-1.)**2.5)
         HAPPI4=SQCTTF*COS(PHIT1-PCREST)*GI*DDGAP/
     X         ((GI*GI-1.)**2.5)
         HAPPI5=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP*DGAP/
     X         ((GI*GI-1.)**3.5)
         HAPPI6=SQCTTF*COS(PHIT1-PCREST)*GI*GAP**3/
     X         ((GI*GI-1.)**3.5)
         HAPPI7=SQCTTF*COS(PHIT1-PCREST)*GI*GI*DGAP*GAP/
     X         ((GI*GI-1.)**3.5)
         HAPPI8=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GI*GAP*GAP*GAP/
     X         ((GI*GI-1.)**4.5)
!        n=1
         HAPPI=HAPPI+T1(I)*XCC1*(-6.*HAPPI1+15.*HAPPI2-3.*HAPPI3 -
     X   3.*HAPPI4 +15.*HAPPI5 +30.*HAPPI6 +30.*HAPPI7 -105.*HAPPI8)
!
!        INTEGRAL OF HBPI(Z) (to be multiplied by (ph1i-ph10)**2 )
         HBPI1=SQCTTF*SIN(PHIT1-PCREST)*GAP*GAP/((GI*GI-1.)**2.5)
         HBPI2=SQCTTF*SIN(PHIT1-PCREST)*GI*DGAP/((GI*GI-1.)**2.5)
         HBPI3=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP*GAP/
     X         ((GI*GI-1.)**3.5)
!        n=1
         HBPI=HBPI+T1(I)*XCC1*(-3.*HBPI1-3.*HBPI2+15.*HBPI3 )
!        INTEGRALS of HBPPI(Z) (to be multiplied by(ph1i-ph10)**3 )/3
         HBPPI1=SQCTTF*SIN(PHIT1-PCREST)*GAP*DGAP/
     X         ((GI*GI-1.)**2.5)
         HBPPI2=SQCTTF*SIN(PHIT1-PCREST)*GAP*GAP*GAP*GI/
     X         ((GI*GI-1.)**3.5)
         HBPPI3=SQCTTF*SIN(PHIT1-PCREST)*GAP*DGAP/
     X         ((GI*GI-1.)**2.5)
         HBPPI4=SQCTTF*SIN(PHIT1-PCREST)*GI*DDGAP/
     X         ((GI*GI-1.)**2.5)
         HBPPI5=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP*DGAP/
     X         ((GI*GI-1.)**3.5)
         HBPPI6=SQCTTF*SIN(PHIT1-PCREST)*GI*GAP**3/
     X         ((GI*GI-1.)**3.5)
         HBPPI7=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*DGAP*GAP/
     X         ((GI*GI-1.)**3.5)
         HBPPI8=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GI*GAP*GAP*GAP/
     X         ((GI*GI-1.)**4.5)
!        n=1
         HBPPI=HAPPI+T1(I)*XCC1*(-6.*HBPPI1+15.*HBPPI2-3.*HBPPI3 -
     X   3.*HBPPI4 +15.*HBPPI5 +30.*HBPPI6 +30.*HBPPI7 -105.*HBPPI8)
       enddo
!    INTEGRALS to be multiplied by cos
       YH1P1=YH1P1/2. *EQVL
       HAPI=HAPI/2. *EQVL
       HAPPI=HAPPI/2. *EQVL
!    INTEGRALS to be multiplied by sin
       YH2P1=YH2P1/2. *EQVL
       HBPI=HBPI/2. *EQVL
       HBPPI=HBPPI/2. *EQVL
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE xtylpk(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! INTEGRALS of HA0(Z) and HB0(Z)
!! INTEGRALS of the second derivative of HA0(Z) and HB0(Z)
!! zb = z+ASDL
!< *******************************************************************
       SUBROUTINE xtylpk(GAMI,SAPHI,QSC,DCG)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *               AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/TYPLPK/YH10PK,YH11PK,YH20PK,YH21PK
       common/gaus17/H1(17),T1(17)
       fprec=epsilon(PHSLIP)
       FH0=FH/VL
       CGI=QSC/XMAT
       GAM2=GAMI**2
       BETI=SQRT(1. - 1./GAM2 )
       XK1=FH0/BETI
       DTILK=EQVL
!     CIRCULAIRES EN COS
       YH10PK=0.
       YH11PK=0.
!     CIRCULAIRES EN SIN
       YH20PK=0.
       YH21PK=0.
       TILTA2=PHSLIP/(2.*EQVL)
!       IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.)
!       IF(PHSLIP.EQ.0.) DESY=2.
       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.)
       IF(abs(PHSLIP).LE.fprec) DESY=2.
       CGAM10=((GAMI*GAMI-1.)**1.5)/FH0
       PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
       do i=1,17
         XCC= EQVL*(1.+H1(I))/2.
         XCC1=XCC+ASDL
         IF(XCC1.GT.DCG) EXIT
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
!        FONCTION GAMMA (Z)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
           GIS =  SIN(XCC*TILTA2)
         ELSE
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
           GIS =  XCC/(2.*EQVL)
         ENDIF
         GI=GAMI+GIT * GIS
         BI=SQRT(1.-1./(GI*GI))
!        Derivative of G0(Z) in relation with: PH01
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GAP=-CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
         ELSE
           GAP = SIN(PHIT0-PCREST)*GIS
           GAP = -CGI * SQCTTF* GAP
         ENDIF
!        Derivative of G0(Z) in relation with the equivalent K
         PHIT0K=-DTILK*(1.-XCC/EQVL)/2.
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIC =COS(XCC*TILTA2)
           GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
           GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
           GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.*PHSLIP*EQVL)
           GAK =CGI * SQCTTF* (-GAK1-GAK2+GAK3)
         ELSE
           GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
           GAK =-CGI * SQCTTF* GAK1
         ENDIF
!        derivative of G0(Z) in relation with the equivalent k and the phase PHI
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIC = COS(XCC*TILTA2)
           GAKP1=DTILK*SIN(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
           GAKP2=COS(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
           GAKP3=DTILK*SIN(PHIT0-PCREST)*XCC*GIC/(2.*PHSLIP*EQVL)
           GAKP =CGI * SQCTTF* (GAKP1-GAKP2-GAKP3)
         ELSE
           GAKP1 = COS(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
           GAKP = -CGI * SQCTTF* GAKP1
         ENDIF
!        INTEGRALS of HA0(Z) and HB0(Z)
         XINT=1./(BI*BI*BI*GI*GI*GI)
         PHIT1=PHIT0+XCC*PHSLIP/(2.*EQVL)
!        INTEGRALES DERIVE HA0(Z) HB0(Z)  k0 ET PHI
         DHA01=SQCTTF*COS(PHIT1-PCREST)*GAP/((GI*GI-1.)**2.5)
         DHA02=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP/
     X         ((GI*GI-1.)**3.5)
         DHB01=SQCTTF*SIN(PHIT1-PCREST)*GAP/((GI*GI-1.)**2.5)
         DHB02=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP/
     X         ((GI*GI-1.)**3.5)
!        n=1
         YH10PK=YH10PK+T1(I)*XCC1*CGAM10*(3.*DHA01-15.*DHA02)
         YH20PK=YH20PK+T1(I)*XCC1*CGAM10*(3.*DHB01-15.*DHB02)
!        Integrals of HA(Z) (multiplied by (ph1i-ph10)*(kmi-km0)
         HAPI1=SQCTTF*COS(PHIT1-PCREST)*GAP*GAK/((GI*GI-1.)**2.5)
         HAPI2=SQCTTF*COS(PHIT1-PCREST)*GI*GAKP/((GI*GI-1.)**2.5)
         HAPI3=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP*GAK/
     X         ((GI*GI-1.)**3.5)
!        n=1
         YH11PK=YH11PK+T1(I)*XCC1*(-3.*HAPI1-3.*HAPI2+15.*HAPI3)
!        Integrals of HB(Z) (multiplied by (ph1i-ph10)*(kmi-km0)
         HBPI1=SQCTTF*SIN(PHIT1-PCREST)*GAP*GAK/((GI*GI-1.)**2.5)
         HBPI2=SQCTTF*SIN(PHIT1-PCREST)*GI*GAKP/((GI*GI-1.)**2.5)
         HBPI3=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP*GAK/
     X         ((GI*GI-1.)**3.5)
!        n=1
         YH21PK=YH21PK+T1(I)*XCC1*(-3.*HBPI1-3.*HBPI2+15.*HBPI3)
       enddo
!    Cosinus integrals
       YH10PK=YH10PK/2. *EQVL
       YH11PK=YH11PK/2. *EQVL
!    Sinus integrals
       YH20PK=YH20PK/2. *EQVL
       YH21PK=YH21PK/2. *EQVL
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE xtypj(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! INTEGRALS of g(G)*Ez(**2) *z**n   n=0,1,2
!< *******************************************************************
       SUBROUTINE xtypj(GAMI,SAPHI,QSC,DCG)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *                AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/TYPJ/YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2,
     X               YFSKC0,YFSKC1,YFSKC2,
     X               YFSCK0,YFSCK1,YFSCK2,
     X               YFSCP0,YFSCP1,YFSCP2,
     X               YFS0,YFS1,YFS2
       common/gaus17/H1(17),T1(17)
       fprec=epsilon(PHSLIP)
       FH0=FH/VL
       CGI=QSC/XMAT
       GAM2=GAMI**2
       BETI=SQRT(1. - 1./GAM2 )
       XK1=FH0/BETI
       DTILK=EQVL
       YFS0=0.
       YFS1=0.
       YFS2=0.
       YFSKC0=0.
       YFSKC1=0.
       YFSKC2=0.
       YFSK0=0.
       YFSK1=0.
       YFSK2=0.
       YFSCK0=0.
       YFSCK1=0.
       YFSCK2=0.
       YFSCP0=0.
       YFSCP1=0.
       YFSCP2=0.
       YFSP0=0.
       YFSP1=0.
       YFSP2=0.
       TILTA2=PHSLIP/(2.*EQVL)
!       IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.)
!       IF(PHSLIP.EQ.0.) DESY=2.
       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.)
       IF(abs(PHSLIP).LE.fprec) DESY=2.
       CGAM10=((GAMI*GAMI-1.)**1.5)/FH0
       PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
       do i=1,17
         XCC= EQVL*(1.+H1(I))/2.
         XCC1=XCC+ASDL
         IF(XCC1.GT.DCG) EXIT
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
!        Function GAMMA (Z)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
           GIS =  SIN(XCC*TILTA2)
         ELSE
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
           GIS =  XCC/(2.*EQVL)
         ENDIF
         GI=GAMI+GIT * GIS
         BI=SQRT(1.-1./(GI*GI))
!        Derivative of G0(Z) with regard to the average k
         PHIT0K=-DTILK*(1.-XCC/EQVL)/2.
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIC =COS(XCC*TILTA2)
           GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
           GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
           GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.*PHSLIP*EQVL)
           GAK =CGI * SQCTTF* (-GAK1-GAK2+GAK3)
         ELSE
           GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
           GAK =-CGI * SQCTTF* GAK1
         ENDIF
         PHIT1=PHIT0+XCC*PHSLIP/(2.*EQVL)
         PHTZ0=(XCC/EQVL-.5)*DTILK
         XINT=(GI*GI+2.)/((GI*GI-1.)**2)
         XFK1=2.*GI*(1.-2.*(GI*GI+2.)/(GI*GI-1.))/((GI*GI-1.)**2)
         HA0=COS(PHIT1-PCREST)
         HB0=SIN(PHIT1-PCREST)
!    n=0
         YFS0=YFS0+T1(I)*HA0*HA0*XINT
         YFSKC0=YFSKC0-T1(I)*HA0*HA0*XFK1*CGAM10
         YFSK0=YFSK0+T1(I)*HA0*HA0*XFK1*GAK
         YFSCK0=YFSCK0-2.*T1(I)*HA0*HB0*XINT*(PHTZ0-PHCRTK)
!    n=1
         YFS1=YFS1+T1(I)*HA0*HA0*XINT*XCC
         YFSKC1=YFSKC1-T1(I)*HA0*HA0*XFK1*CGAM10*XCC
         YFSK1=YFSK1+T1(I)*HA0*HA0*XFK1*GAK*XCC
         YFSCK1=YFSCK1-2.*T1(I)*HA0*HB0*XINT*(PHTZ0-PHCRTK)*XCC
!    n=2
         YFS2=YFS2+T1(I)*HA0*HA0*XINT*XCC*XCC
         YFSKC2=YFSKC2-T1(I)*HA0*HA0*XFK1*CGAM10*XCC*XCC
         YFSK2=YFSK2+T1(I)*HA0*HA0*XFK1*GAK*XCC*XCC
         YFSCK2=YFSCK2-2.*T1(I)*HA0*HB0*XINT*(PHTZ0-PHCRTK)*XCC*XCC
!      Derivative of G0(Z) with regard to PH01
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GAP = -CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
         ELSE
           GAP=SIN(PHIT0-PCREST)*GIS
           GAP=-CGI*SQCTTF*GAP
         ENDIF
!    n=0
         YFSP0=YFSP0+T1(I)*XFK1*GAP*HA0*HA0
         YFSCP0=YFSCP0-2.*T1(I)*XINT*HA0*HB0
!    n=1
         YFSP1=YFSP1+T1(I)*XFK1*GAP*HA0*HA0*XCC
         YFSCP1=YFSCP1-2.*T1(I)*XINT*HA0*HB0*XCC
!    n=2
         YFSP2=YFSP2+T1(I)*XFK1*GAP*HA0*HA0*XCC*XCC
         YFSCP2=YFSCP2-2.*T1(I)*XINT*HA0*HB0*XCC*XCC
       enddo
!       IST=IAST
       YFS0=YFS0/2. *EQVL
       YFS1=YFS1/2. *EQVL
       YFS2=YFS2/2. *EQVL
       YFSKC0=YFSKC0/2. *EQVL
       YFSKC1=YFSKC1/2. *EQVL
       YFSKC2=YFSKC2/2. *EQVL
       YFSK0=YFSK0/2. *EQVL
       YFSK1=YFSK1/2. *EQVL
       YFSK2=YFSK2/2. *EQVL
       YFSCK0=YFSCK0/2. *EQVL
       YFSCK1=YFSCK1/2. *EQVL
       YFSCK2=YFSCK2/2. *EQVL
       YFSCP0=YFSCP0/2. *EQVL
       YFSCP1=YFSCP1/2. *EQVL
       YFSCP2=YFSCP2/2. *EQVL
       YFSP0=YFSP0/2. *EQVL
       YFSP1=YFSP1/2. *EQVL
       YFSP2=YFSP2/2. *EQVL
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE xtypm(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! INTEGRALS of g(G)*z**n  with n=0,1,2
!< *******************************************************************
       SUBROUTINE xtypm(GAMI,SAPHI,QSC,DCG)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *               AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/TYPM/YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2,
     X               YNSK0C,YNSK1C,YNSK2C,
     X               YNS0,YNS1,YNS2
       common/gaus17/H1(17),T1(17)
       fprec=epsilon(PHSLIP)
       FH0=FH/VL
       CGI=QSC/XMAT
       DTILK=EQVL
       YNS0=0.
       YNS1=0.
       YNS2=0.
       YNSK0C=0.
       YNSK1C=0.
       YNSK2C=0.
       YNSK0=0.
       YNSK1=0.
       YNSK2=0.
       YNSP0=0.
       YNSP1=0.
       YNSP2=0.
       GAM2=GAMI**2
       BETI=SQRT(1. - 1./GAM2 )
       XK1=FH0/BETI
       TILTA2=PHSLIP/(2.*EQVL)
!       IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.)
!       IF(PHSLIP.EQ.0.) DESY=2.
       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.)
       IF(abs(PHSLIP).LE.fprec) DESY=2.
       CGAM10=((GAMI*GAMI-1.)**1.5)/FH0
       PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
       do i=1,17
         XCC= EQVL*(1.+H1(I))/2.
         XCC1=XCC+ASDL
         IF(XCC1.GT.DCG) EXIT
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
!        Function GAMMA (Z)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIT=CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
           GIS=SIN(XCC*TILTA2)
         ELSE
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
           GIS =  XCC/(2.*EQVL)
         ENDIF
         GI=GAMI+GIT * GIS
         BI=SQRT(1.-1./(GI*GI))
!        Derivative of G0(Z) with regard to the average k
         PHIT0K=-DTILK*(1.-XCC/EQVL)/2.
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIC =COS(XCC*TILTA2)
           GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
           GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
           GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.*PHSLIP*EQVL)
           GAK=CGI * SQCTTF* (-GAK1-GAK2+GAK3)
         ELSE
           GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
           GAK =-CGI * SQCTTF* GAK1
         ENDIF
         XINT=(GI*GI+2.)/((GI*GI-1.)**2)
         XNK1=2.*GI*(1.-2.*(GI*GI+2.)/(GI*GI-1.))/((GI*GI-1.)**2)
!    n=0
         YNS0=YNS0+T1(I)*XINT
         YNSK0C=YNSK0C-T1(I)*XNK1*CGAM10
         YNSK0=YNSK0+T1(I)*XNK1*GAK
!    n=1
         YNS1=YNS1+T1(I)*XINT*XCC
         YNSK1C=YNSK1C-T1(I)*XNK1*CGAM10*XCC
         YNSK1=YNSK1+T1(I)*XNK1*GAK*XCC
!    n=2
         YNS2=YNS2+T1(I)*XINT*XCC*XCC
         YNSK2C=YNSK2C-T1(I)*XNK1*CGAM10*XCC*XCC
         YNSK2=YNSK2+T1(I)*XNK1*GAK*XCC*XCC
!      DERIVE G0(Z) RELATIF A PH01
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GAP = -CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
         ELSE
           GAP=SIN(PHIT0-PCREST)*GIS
           GAP=-CGI*SQCTTF*GAP
         ENDIF
         YNSP0=YNSP0+T1(I)*XNK1*GAP
         YNSP1=YNSP1+T1(I)*XNK1*GAP*XCC
         YNSP2=YNSP2+T1(I)*XNK1*GAP*XCC*XCC
       enddo
       YNS0=YNS0/2. *EQVL
       YNS1=YNS1/2. *EQVL
       YNS2=YNS2/2. *EQVL
       YNSK0C=YNSK0C/2. *EQVL
       YNSK1C=YNSK1C/2. *EQVL
       YNSK2C=YNSK2C/2. *EQVL
       YNSK0=YNSK0/2. *EQVL
       YNSK1=YNSK1/2. *EQVL
       YNSK2=YNSK2/2. *EQVL
       YNSP0=YNSP0/2. *EQVL
       YNSP1=YNSP1/2. *EQVL
       YNSP2=YNSP2/2. *EQVL
       RETURN
       END
!> *******************************************************************
!! FUNCTION gamci(PHI,PCRESI,GAMI,IST,QSC)
!! called by RESTAY and ETGAP
!! CURRENT GAMMA VALUE (the POSITION IS GIVEN BY IST)
!< *******************************************************************
       FUNCTION gamci(PHI,PCRESI,GAMI,IST,QSC)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *               AA,BB,CC,DD,EE,PCREST,SQCTTF
       common/gaus17/H1(17),T1(17)
       fprec=epsilon(PHSLIP)
       GAMCI=0.
       IF(IST.GT.17) RETURN
       CGI=QSC/XMAT
       TILTA2=PHSLIP/(2.*EQVL)
       I=IST
       XCC= EQVL*(1.+H1(I))/2.
       PHIT0=PHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)
!      Function GAMMA (Z)
!       IF(PHSLIP.NE.0.) THEN
       IF(abs(PHSLIP).GT.fprec) THEN
         GIT = CGI * SQCTTF*COS(PHIT0-PCRESI)/PHSLIP
         GIS =  SIN(XCC*TILTA2)
       ELSE
         GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
         GIS =  XCC/(2.*EQVL)
       ENDIF
       GAMCI=GAMI+GIT * GIS
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE intga(npt,ireca)
!! Calculate the beam self fields acting on each particle (called by
!! SCHERM) Gauss quadrature
!< *******************************************************************
       SUBROUTINE intga(npt,ireca)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
       COMMON/HERMD/AFXM(20),AFYM(20),AFZM(20)
       COMMON/HERMR/AFXR(20),AFYR(20),AFZR(20)
       COMMON/HERMRR/AFXRR(20),AFYRR(20),AFZRR(20)
       COMMON/SIZR/XRMS3,YRMS3,ZRMS3,ZCGR3
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/ELCG/XCGD,YCGD,ZCGD,XCGR,YCGR,ZCGR
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/INTGRT/ex,ey,ez
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/twcst/epsil
       COMMON/ECOR/const
       COMMON/NPART/IMAXR
       common/macro/ratei
       LOGICAL ichaes
       DIMENSION UI(6),WI(6)
       DATA (UI(J),J=1,6)/.033765,.169395,.380690,.619310,.830605,
     *      .966234/
       DATA (WI(J),J=1,6)/.085662,.180381,.233957,.233957,.180381,
     *      .085662/
!
! Initialize some constants and variables
! freq. in MHz
       freq=fh*0.5e-06/pi
! qmpart=coul , xrms=meters
!    ireca=0 : first ellipsoid  over nmaxy terms
!    ireca=4 : one ellipsoid over the first term
       xrmsc=0.
       yrmsc=0.
       zrmsc=0.
       xgc=0.
       ygc=0.
       zgc=0.
       if(ireca.eq.0.or.ireca.eq.4) then
         xrmsc=xrms1
         yrmsc=yrms1
         zrmsc=zrms1
         xgc=xcgd
         ygc=ycgd
         zgc=zcgd
       endif
!    ireca=1 : second ellipsoid
       if(ireca.eq.1) then
         xrmsc=xrms2
         yrmsc=yrms2
         zrmsc=zrms2
         xgc=xcgr
         ygc=ycgr
         zgc=zcgr
       endif
!    ireca=2 : third elllipsoid
       if(ireca.eq.2) then
         xrmsc=xrms3
         yrmsc=yrms3
         zrmsc=zrms3
         xgc=0.
         ygc=0.
         zgc=zcgr3
       endif
       qmpart=1.0e-09*beamc/(float(imax)*freq)
!omment        const=qmpart*xrmsc*yrmsc*zrmsc/(2.*epsilon)
       qmpart=qmpart*ratei
       const=qmpart/(2.*epsil)
       dnorm=(xrmsc*yrmsc*zrmsc)**.333333333
       dsq=dnorm*dnorm
       xsq=(xc(npt)-xgc)*(xc(npt)-xgc)
       ysq=(yc(npt)-ygc)*(yc(npt)-ygc)
       zsq=(zc(npt)-zgc)*(zc(npt)-zgc)
       if(ireca.eq.0) zc1=zc(npt)-zgc
       if(ireca.eq.1) zc2=zc(npt)-zgc
       ex=0.
       if(ireca.eq.2) zc2=zc(npt)-zgc
       ey=0.
       ez=0.
! initialize integrals to 0.
! integrate all 3 components (x,y,z)
       DO J=1,6
         a1=xrmsc*xrmsc-dsq+dsq/ui(j)
         a2=yrmsc*yrmsc-dsq+dsq/ui(j)
         a3=zrmsc*zrmsc-dsq+dsq/ui(j)
         t1=xsq/a1
         t2=ysq/a2
         t3=zsq/a3
         txyz=sqrt(t1+t2+t3)
         ff1=drxyz(nmaxy,txyz,ireca)/(ui(j)*ui(j)*sqrt(a1*a2*a3))
         fxn=ff1/a1
         fyn=ff1/a2
         fzn=ff1/a3
         ex=ex+wi(j)*fxn*dsq
         ey=ey+wi(j)*fyn*dsq
         ez=ez+wi(j)*fzn*dsq
       ENDDO
! Field components are in Newton/Coulomb
       ex=ex*const*xc(npt)
       ey=ey*const*yc(npt)
       ez=ez*const*(zc(npt)-zgc)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE sizcor(ect,xrms,yrms,zrms,imaxd)
!! Computes the R.M.S. of the bunch at positions of space charge
!! computation
!< *******************************************************************
       SUBROUTINE sizcor(ect,xrms,yrms,zrms,imaxd)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/CGRMS/xsum,ysum,zsum
       common/faisc/f(10,iptsz),imax,ngood
       imaxf=0
       imaxx=ngood
       xsum=0.
       ysum=0.
       zsum=0.
       xrmsp=xrms
       yrmsp=yrms
       zrmsp=zrms
       xsqsum=0.
       ysqsum=0.
       zsqsum=0.
       if(imaxd.gt.0) imaxx=imaxd
       do  i=1,imaxx
         xcoup=abs(xc(i)/xrmsp)
         ycoup=abs(yc(i)/yrmsp)
         zcoup=abs(zc(i)/zrmsp)
         if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
           xsum=xsum+xc(i)
           ysum=ysum+yc(i)
           zsum=zsum+zc(i)
           xsqsum=xsqsum+xc(i)*xc(i)
           ysqsum=ysqsum+yc(i)*yc(i)
           zsqsum=zsqsum+zc(i)*zc(i)
           imaxf=imaxf+1
         endif
       enddo
       xsum=xsum/imaxf
       ysum=ysum/imaxf
       zsum=zsum/imaxf
       xsqsum=xsqsum/imaxf
       ysqsum=ysqsum/imaxf
       zsqsum=zsqsum/imaxf
       xrms=SQRT(xsqsum-xsum*xsum)
       yrms=SQRT(ysqsum-ysum*ysum)
       zrms=SQRT(zsqsum-zsum*zsum)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE sizrms(imaxd,xrms,yrms,zrms,zmin)
!! partial R.M.S. (called by SCHERM)
!< *******************************************************************
       SUBROUTINE sizrms(imaxd,xrms,yrms,zrms,zmin)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/CGRMS/xsum,ysum,zsum
       common/faisc/f(10,iptsz),imax,ngood
       imaxx=ngood
       xsum=0.
       ysum=0.
       zsum=0.
       if(imaxd.gt.0) then
         do i=1,imaxd
           zc(i)=zc(i)-zmin
         enddo
         imaxx=imaxd
       endif
       xsqsum=0.
       ysqsum=0.
       zsqsum=0.
       do i=1,imaxx
         xsum=xsum+xc(i)
         ysum=ysum+yc(i)
         zsum=zsum+zc(i)
         xsqsum=xsqsum+xc(i)*xc(i)
         ysqsum=ysqsum+yc(i)*yc(i)
         zsqsum=zsqsum+zc(i)*zc(i)
       enddo
       xsum=xsum/imaxx
       ysum=ysum/imaxx
       zsum=zsum/imaxx
       xsqsum=xsqsum/float(imaxx)
       ysqsum=ysqsum/float(imaxx)
       zsqsum=zsqsum/float(imaxx)
       xrms=SQRT(xsqsum-xsum*xsum)
       yrms=SQRT(ysqsum-ysum*ysum)
       zrms=SQRT(zsqsum-zsum*zsum)
       RETURN
       END
!> *******************************************************************
!! FUNCTION snzt(CC,DD)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION snzt(CC,DD)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       common/gaus17/H1(17),T1(17)
       SNZT=0.
       DO I=1,17
         Z= (CC+DD)/2.+(DD-CC)*H1(I)/2.
         DENZ=DENSZ(NMAZ,Z,0)
         IF(DENZ.LT.0.) DENZ=0.
         SNZT=SNZT+T1(I)*DENZ
       ENDDO
       SNZT=SNZT*(DD-CC)/2.
       RETURN
       END
!> *******************************************************************
!! FUNCTION snzd(cc,dd)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION snzd(cc,dd)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       common/gaus17/H1(17),T1(17)
       SNZD=0.
       DO I=1,17
         Z= (CC+DD)/2.+(DD-CC)*H1(I)/2.
         DENZ=DENSZ(NMAZ,Z,0)
         IF(DENZ.LT.0.) EXIT
         ZZ=(Z-CC)
         SNZD=SNZD+T1(I)*DENZ
       ENDDO
       SNZD=SNZD*(DD-CC)
       RETURN
       END
!> *******************************************************************
!! FUNCTION vaprz(CC,DD)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION vaprz(CC,DD)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       common/gaus17/H1(17),T1(17)
       VAPRZ=0.
       VAR1=0.
       VAR2=0.
       DO I=1,17
         Z= (CC+DD)/2.+(DD-CC)*H1(I)/2.
         DENZ=DENSZ(NMAZ,Z,0)
         IF(DENZ.LT.0.) EXIT
         ZZ=(Z-CC)
         VAR1=VAR1+T1(I)*ZZ*ZZ*DENZ
         VAR2=VAR2+T1(I)*DENZ
       ENDDO
       VAPRZ=VAR1/VAR2
       RETURN
       END
!> *******************************************************************
!! FUNCTION prinz(CC,DD,KAP,ZRMSS1)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION prinz(CC,DD,KAP,ZRMSS1)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       common/gaus17/H1(17),T1(17)
       PRINZ=0.
       K=KAP-1
       DO I=1,17
         DENZ=0.
         Z= (CC+DD)/2.+(DD-CC)*H1(I)/2.
         DENZ=DENSZ(NMAZ,Z,0)
         IF(DENZ.LT.0.) EXIT
         ZZ=(Z-CC)/ZRMSS1
         PRINZ=PRINZ+T1(I)*HERM(2*K,ZZ)*DENZ
       ENDDO
       PRINZ=PRINZ*(DD-CC)/2.
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE rchsom(ZI,ZF,NMAZ)
!! specific function called by SCHERM
!! Look for the top of the partial distributions
!< *******************************************************************
       SUBROUTINE rchsom(ZI,ZF,NMAZ)
       implicit real(8) (a-h,o-z)
       XPZ=ABS((ZF-ZI))/400.
       DO
         ZTEST=ABS(ZF-ZI)
         IF(ZTEST.LE.XPZ) EXIT
         Z1=(ZF+ZI)/2.
         Z2=(Z1+ZI)/2.
         T1=DENSZ(NMAZ,Z1,0)
         T2=DENSZ(NMAZ,Z2,0)
!    new interval: Z2,ZF
         IF(T1.GT.T2) ZI=Z2
!    new interval  : ZI,Z1
         IF(T1.LT.T2) ZF=Z1
       ENDDO  
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE rchsor(AA,BB,CC,DD,ZS)
!! specific function called by SCHERM
!! Look for the top of the partial distributions
!< *******************************************************************
       SUBROUTINE rchsor(AA,BB,CC,DD,ZS)
       implicit real(8) (a-h,o-z)
       ZI=AA
       ZF=CC
       XPZ=ABS((ZF-ZI))/400.
       DO
         ZTEST=ABS(ZF-ZI)
         IF(ZTEST.LE.XPZ) EXIT
         Z1=(ZF+ZI)/2.
         Z2=(Z1+ZI)/2.
         T1=DENDIF(Z1,AA,BB,CC,DD)
         T2=DENDIF(Z2,AA,BB,CC,DD)
!    NEW INTERVAL : Z2,ZF
         IF(T1.GT.T2) ZI=Z2
!    NEW INTERVAL : ZI,Z1
         IF(T1.LT.T2) ZF=Z1
       ENDDO
       ZS=(ZI+ZF)/2.
       RETURN
       END
!> *******************************************************************
!! FUNCTION herm(M,X)
!! Hermite polynomials
!< *******************************************************************
       FUNCTION herm(M,X)
       implicit real(8) (a-h,o-z)
       DIMENSION HE(30)
       IF(M.EQ.0) THEN
         HERM=1.
         RETURN
       ENDIF
       IF(M.EQ.1) THEN
         HERM=X
         RETURN
       ENDIF
       HE(1)=1.
       HE(2)=X
       M1=M-1
       DO K=1,M1
         HE(K+2)=X*HE(K+1)-FLOAT(K)*HE(K)
       ENDDO
       HERM=HE(M+1)
       RETURN
       END
!> *******************************************************************
!! FUNCTION densz(M,Z,IRECA)
!! called by SCHERM
!! Look for the distribution in z position
!< *******************************************************************
       FUNCTION densz(M,Z,IRECA)
       implicit real(8) (a-h,o-z)
       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
       COMMON/HERMD/AFXM(20),AFYM(20),AFZM(20)
       COMMON/HERMR/AFXR(20),AFYR(20),AFZR(20)
       DENSZ=0.
       DO K=1,M
         KAP=K-1
         IF(IRECA.EQ.0)
     X    DENSZ=DENSZ+EXP(-Z*Z/2.)*AFZT(K)*HERM(KAP,Z)
         IF(IRECA.EQ.2)
     X    DENSZ=DENSZ+EXP(-Z*Z/2.)*AFZM(K)*HERM(2*KAP,Z)
         IF(IRECA.EQ.3)
     X    DENSZ=DENSZ+EXP(-Z*Z/2.)*AFZR(K)*HERM(2*KAP,Z)
       ENDDO
       RETURN
       END
!> *******************************************************************
!! FUNCTION codsy(BB,CC,DD,EE,KAP)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION codsy(BB,CC,DD,EE,KAP)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/gaus13/H(13),T(13)
       CODSY=0.
       K=KAP-1
       FF=2.*EE-CC
       DO I=1,13
         DENDIFR=0.
         Z= (CC+FF)/2.+(CC-FF)*T(I)/2.
         IF(Z.GE.FF.AND.Z.LT.EE) THEN
           ZS=2.*EE-Z
           Z1=DD+BB-ZS
           IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
           IF(ZS.GE.BB)
     X     DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
         ENDIF
         IF(Z.GE.EE) THEN
           IF(Z.LT.BB) DENDIFR=DENSZ(NMAZ,Z,0)
           Z1=DD+BB-Z
           IF(Z.GE.BB)
     X     DENDIFR=DENSZ(NMAZ,Z,0)-DENSZ(NMAZ,Z1,0)
         ENDIF
         IF(DENDIFR.LT.0.) DENDIFR=0.
         ZZ=Z-EE
!        ZRMS2(EFFECTIF)=ZRMS2(CALCULE)*ZRMS
         ZZ=ZZ/ZRMS2
         CODSY=CODSY+H(I)*HERM(2*K,ZZ)*DENDIFR
       ENDDO
       CODSY=CODSY*(CC-FF)/2.
       RETURN
       END
!> *******************************************************************
!! FUNCTION codif(BB,CC,DD,EE,EE1,KAP)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION codif(BB,CC,DD,EE,EE1,KAP)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/SIZR/XRMS3,YRMS3,ZRMS3,ZCGR3
       COMMON/gaus13/H(13),T(13)
       CODIF=0.
       K=KAP-1
       FF=2.*EE1-EE
       FF1=2.*EE-CC
       DENDIFR=0.
       DO I=1,13
         Z=(EE+FF)/2.+(EE-FF)*T(I)/2.
         IF(Z.LE.FF1) DENDIFR=DENSZ(NMAZ,Z,0)
         IF(Z .GE.FF1)  THEN
           ZS=2.*EE-Z
           Z1=DD+BB-ZS
           IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
           IF(ZS.GE.BB)
     X       DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
           DENDIFR=DENSZ(NMAZ,Z,0)-DENDIFR
         endif
         IF(Z.Gt.0.) dendifr=0.
         IF(DENDIFR.LT.0.) DENDIFR=0.
         ZZ=Z-EE1
!        ZRMS2(EFFECTIF)=ZRMS2(CALCULE)*ZRMS
         ZZ=ZZ/ZRMS3
         CODIF=CODIF+H(I)*HERM(2*K,ZZ)*DENDIFR
       ENDDO
       CODIF=-CODIF*FF/2.
       RETURN
       END
!> *******************************************************************
!! FUNCTION varia(BB,CC,DD,EE)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION varia(BB,CC,DD,EE)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/gaus13/H(13),T(13)
       VARIA=0.
       CODI1=0.
       CODI2=0.
       FF=2.*EE-CC
       DO I=1,13
         DENDIFR=0.
         Z= (CC+FF)/2.+(CC-FF)*T(I)/2.
         IF(Z.GE.FF.AND.Z.LT.EE) THEN
           ZS=2.*EE-Z
           Z1=DD+BB-ZS
           IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
           IF(ZS.GE.BB)
     X     DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
         ENDIF
         IF(Z.GE.EE) THEN
           IF(Z.LT.BB) DENDIFR=DENSZ(NMAZ,Z,0)
           Z1=DD+BB-Z
           IF(Z.GE.BB)
     X     DENDIFR=DENSZ(NMAZ,Z,0)-DENSZ(NMAZ,Z1,0)
         ENDIF
         ZZ=Z-EE
         IF(DENDIFR.LT.0.) DENDIFR=0.
         CODI1=CODI1+H(I)*ZZ*ZZ*DENDIFR
         CODI2=CODI2+H(I)*DENDIFR
       ENDDO
       VARIA=CODI1/CODI2
       RETURN
       END
!> *******************************************************************
!! FUNCTION variz(BB,CC,DD,EE,EE1)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION variz(BB,CC,DD,EE,EE1)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/gaus13/H(13),T(13)
       VARIZ=0.
       CODI1=0.
       CODI2=0.
       FF=2.*EE1-EE
       FF1=2.*EE-CC
       DO I=1,13
         DENDIFR=0.
         Z= (EE+FF)/2.+(EE-FF)*T(I)/2.
         IF(Z.LE.FF1) DENDIFR=DENSZ(NMAZ,Z,0)
         IF(Z .GE.FF1)  THEN
           ZS=2.*EE-Z
           Z1=DD+BB-ZS
           IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
           IF(ZS.GE.BB)
     X     DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
           DENDIFR=DENSZ(NMAZ,Z,0)-DENDIFR
         endif
         IF(Z.Gt.EE) dendifr=0.
         IF(DENDIFR.LT.0.) DENDIFR=0.
         ZZ=Z-EE1
         CODI1=CODI1+H(I)*ZZ*ZZ*DENDIFR
         CODI2=CODI2+H(I)*DENDIFR
       ENDDO
       VARIZ=CODI1/CODI2
       RETURN
       END
!> *******************************************************************
!! FUNCTION grz(AA,BB,CC,DD,EE)
!! specific function called by SCHERM
!< *******************************************************************
       FUNCTION grz(AA,BB,CC,DD,EE)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/gaus13/H(13),T(13)
       GRZ=0.
       GZ=0.
       GS=0.
       DO I=1,13
         Z= (EE+AA)/2.+(EE-AA)*T(I)/2.
         dif=dendir(z,aa,bb,cc,dd,ee)
         if(dif.lt.0.)dif=0.
         GZ=GZ+H(I)*Z*DIF
         GS=GS+H(I)*DIF
       ENDDO
       IF(GS.LE.0.) GRZ=0.
       IF(GS.GT.0.) GRZ=GZ/GS
       RETURN
       END
!> *******************************************************************
!! FUNCTION dendir(Z,AA,BB,CC,DD,EE)
!! Specific function called by SCHERM
!! Calculate the value (nt(z)-nm(z))
!< *******************************************************************
       FUNCTION dendir(Z,AA,BB,CC,DD,EE)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       DENDIR=0.
       FF=2.*EE-CC
       IF(Z.LT.AA)DENDIR=0.
       IF(Z.GE.AA.AND.Z.LT.FF) DENDIR=DENSZ(NMAZ,Z,0)
       IF(Z.GE.FF.AND.Z.LT.EE) THEN
         ZS=2.*EE-Z
         Z1=DD+BB-ZS
         DENDIFR=0.
         IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
         IF(ZS.GE.BB)
     X     DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
         DENDIR=DENSZ(NMAZ,Z,0)-DENDIFR
       ENDIF
       IF(Z.GE.EE) DENDIR=0.
       RETURN
       END
!> *******************************************************************
!! FUNCTION dendif(Z,AA,BB,CC,DD)
!! Specific function called by SCHERM
!! Calculate the value (nt(z)-nm(z))
!< *******************************************************************
       FUNCTION dendif(Z,AA,BB,CC,DD)
       implicit real(8) (a-h,o-z)
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       DENDIF=0.
       IF(Z.LT.AA)DENDIF=0.
       IF(Z.GE.AA.AND.Z.LT.BB) DENDIF=DENSZ(NMAZ,Z,0)
       IF(Z.GE.BB.AND.Z.LT.CC) THEN
         Z1=DD+BB-Z
         DENDIF=DENSZ(NMAZ,Z,0)-DENSZ(NMAZ,Z1,0)
       ENDIF
       IF(Z.GE.CC) DENDIF=0.
       RETURN
       END
!> *******************************************************************
!! FUNCTION drxyz(M,XYZ,IRECA)
!! Specific function called by SCHERM
!! Calculate the derivatives of:(n(x)+n(y)+n(z))/3
!!      IRECA=0 : for the first ellipse
!!      IRECA=1 : for the second ellipse
!!      IRECA=2 : for the third ellipse
!< *******************************************************************
       FUNCTION drxyz(M,XYZ,IRECA)
       implicit real(8) (a-h,o-z)
       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
       COMMON/HERMD/AFXM(20),AFYM(20),AFZM(20)
       COMMON/HERMR/AFXR(20),AFYR(20),AFZR(20)
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/HERMRR/AFXRR(20),AFYRR(20),AFZRR(20)
       COMMON/SIZR/XRMS3,YRMS3,ZRMS3,ZCGR3
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       DERIV1=0.
       DERIV2=0.
       IF(ABS(XYZ).GT.13.) XYZ=13.
       fe=EXP(-XYZ*XYZ/2.)
       axyz=ABS(xyz)
       MSTO=M
       DO K=2,M
         KAP=K-1
         KAH=2*KAP-1
         IF(IRECA.EQ.0) THEN
           DXXYZ=fe*FLOAT(KAP)*AFXM(K)*HERS(KAH,axyz)
           DYXYZ=fe*FLOAT(KAP)*AFYM(K)*HERS(KAH,axyz)
           DZXYZ=fe*FLOAT(KAP)*AFZM(K)*HERS(KAH,axyz)
           DERIV1=DERIV1+(DXXYZ+DYXYZ+DZXYZ)
         ENDIF
         IF(IRECA.EQ.1) THEN
           DXXYZ=fe*FLOAT(KAP)*AFXR(K)*HERS(KAH,axyz)
           DYXYZ=fe*FLOAT(KAP)*AFYR(K)*HERS(KAH,axyz)
           DZXYZ=fe*FLOAT(KAP)*AFZR(K)*HERS(KAH,axyz)
           DERIV1=DERIV1+(DXXYZ+DYXYZ+DZXYZ)
         ENDIF
         IF(IRECA.EQ.2) THEN
           DXXYZ=fe*FLOAT(KAP)*AFXRR(K)*HERS(KAH,axyz)
           DYXYZ=fe*FLOAT(KAP)*AFYRR(K)*HERS(KAH,axyz)
           DZXYZ=fe*FLOAT(KAP)*AFZRR(K)*HERS(KAH,axyz)
           DERIV1=DERIV1+(DXXYZ+DYXYZ+DZXYZ)
         ENDIF
       ENDDO
       DO K=1,M
         KAP=2*(K-1)
         IF(IRECA.EQ.0) THEN
           DXXYZ=-fe*AFXM(K)*HERM(KAP,XYZ)
           DYXYZ=-fe*AFYM(K)*HERM(KAP,XYZ)
           DZXYZ=-fe*AFZM(K)*HERM(KAP,XYZ)
           DERIV2=DERIV2+.5*(DXXYZ+DYXYZ+DZXYZ)
         ENDIF
         IF(IRECA.EQ.1) THEN
           DXXYZ=-fe*AFXR(K)*HERM(KAP,XYZ)
           DYXYZ=-fe*AFYR(K)*HERM(KAP,XYZ)
           DZXYZ=-fe*AFZR(K)*HERM(KAP,XYZ)
           DERIV2=DERIV2+.5*(DXXYZ+DYXYZ+DZXYZ)
         ENDIF
         IF(IRECA.EQ.2) THEN
           DXXYZ=-fe*AFXRR(K)*HERM(KAP,XYZ)
           DYXYZ=-fe*AFYRR(K)*HERM(KAP,XYZ)
           DZXYZ=-fe*AFZRR(K)*HERM(KAP,XYZ)
           DERIV2=DERIV2+.5*(DXXYZ+DYXYZ+DZXYZ)
         ENDIF
       ENDDO
       DRXYZ=-(DERIV1+DERIV2)/(3.*PI)
       M=MSTO
       RETURN
       END
!> *******************************************************************
!! FUNCTION hers(M,X)
!! Specific Hermite polynomials called by the function DRXYZ
!< *******************************************************************
       FUNCTION hers(M,X)
       implicit real(8) (a-h,o-z)
       DIMENSION HE(30)
       IF(M.EQ.1) THEN
         HERS=1.
         RETURN
       ENDIF
       IF(M.EQ.3) THEN
         HERS=X*X-3.
         RETURN
       ENDIF
       HE(1)=1.
       HE(2)=X*X-3.
       XM1=FLOAT((M+1)/2)+.01
       M1=INT(XM1)-2
       DO K=1,M1
         HE(K+2)=HERM(2*(K+2)-2,ABS(X))-FLOAT(2*(K+2)-2)*HE(K+1)
       ENDDO
       HERS=HE(M1+2)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE cdg(IDCH)
!! Calculate the c.o.g. of the bunch
!!      IDCH EQ 1: WITH  CHASE
!!      IDCH NE 1: OTHERWISE
!!      cog(1) : Energy(MeV)
!!      cog(3) : t.o.f. (sec)
!!      cog(4) : x-direction (cm)
!!      cog(5) : xp(mrd)
!!      cog(6) : y-direction (cm)
!!      cog(7) : yp(mrd)
!< *******************************************************************
       SUBROUTINE cdg(IDCH)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/DYN/TREF,VREF
       LOGICAL chasit
!      print*,'cdg'    ! wdk
       cog(1)=0.
       cog(3)=0.
       cog(4)=0.
       cog(5)=0.
       cog(6)=0.
       cog(7)=0.
       imaxf=0
       IF(IDCH.EQ.1) THEN
         chexmin(1)=f(2,1)
         chexmax(1)=f(2,1)
         chexmin(2)=f(4,1)
         chexmax(2)=f(4,1)
         chexmin(3)=f(6,1)
         chexmax(3)=f(6,1)
         chexmin(4)=f(7,1)
         chexmax(4)=f(7,1)       
         DO i=1,ngood
           IF(ICHAS(I).EQ.1) THEN
             if(f(2,i).lt.chexmin(1)) chexmin(1)=f(2,i)
             if(f(4,i).lt.chexmin(2)) chexmin(2)=f(4,i)
             if(f(6,i).lt.chexmin(3)) chexmin(3)=f(6,i)
             if(f(7,i).lt.chexmin(4)) chexmin(4)=f(7,i)
             if(f(2,i).gt.chexmax(1)) chexmax(1)=f(2,i)
             if(f(4,i).gt.chexmax(2)) chexmax(2)=f(4,i)
             if(f(6,i).gt.chexmax(3)) chexmax(3)=f(6,i)
             if(f(7,i).gt.chexmax(4)) chexmax(4)=f(7,i)
             cog(1)=cog(1)+f(7,i)
             cog(3)=cog(3)+f(6,i)
             cog(4)=cog(4)+f(2,i)
             cog(5)=cog(5)+f(3,i)
             cog(6)=cog(6)+f(4,i)
             cog(7)=cog(7)+f(5,i)
             imaxf=imaxf+1
           ENDIF
         ENDDO
       ELSE
         DO i=1,ngood
           cog(1)=cog(1)+f(7,i)
           cog(3)=cog(3)+f(6,i)
           cog(4)=cog(4)+f(2,i)
           cog(5)=cog(5)+f(3,i)
           cog(6)=cog(6)+f(4,i)
           cog(7)=cog(7)+f(5,i)
           imaxf=imaxf+1
         ENDDO
       ENDIF
       cog(1)=cog(1)/imaxf
       cog(3)=cog(3)/imaxf
       cog(4)=cog(4)/imaxf
       cog(5)=cog(5)/imaxf
       cog(6)=cog(6)/imaxf
       cog(7)=cog(7)/imaxf
       IF(ICHAS(I).EQ.1) THEN
         chexmin(1)=chexmin(1)-cog(4)
         chexmin(2)=chexmin(2)-cog(6)
         chexmin(3)=chexmin(3)-cog(3)
         chexmin(4)=chexmin(4)-cog(1)
         chexmax(1)=chexmax(1)-cog(4)
         chexmax(2)=chexmax(2)-cog(6)
         chexmax(3)=chexmax(3)-cog(3)
         chexmax(4)=chexmax(4)-cog(1)
       ENDIF
       return
       end
!> *******************************************************************
!! SUBROUTINE ext2d(IDCH)
!! Look for average extensions squared and return them in array exten
!! Used in the routines: EMIPRT ETGAP RESTAY STATIS
!!
!!      IDCH EQ 1: WITH  CHASE TEST
!!      IDCH NE 1: OTHERWISE
!!
!!        cog(1) : Energy(MeV)
!!        cog(3) : t.o.f. (sec)
!!        cog(4) : x-direction (cm)
!!        cog(5) : xp(mrd)
!!        cog(6) : y-direction (cm)
!!        cog(7) : yp(mrd)
!!
!!      exten(1) : Sum( dE*dE )  MeV*MeV
!!      exten(2) : Sum( dE*dPHase ) MeV*rad
!!      exten(3) : Sum( dPHase*dPHase ) rad*rad
!!      exten(4) : Sum( x*x )   cm*cm
!!      exten(5) : Sum( xp*xp )   mrad*mrad
!!      exten(6) : Sum( y*y )   cm*cm
!!      exten(7) : Sum( yp*yp )  mrad*mrad
!!      exten(8) : Sum( x*xp )   cm*mrad
!!      exten(9) : Sum( y*yp )   cm*mrad
!!      exten(12): Sum( (dp/p)*x(i) )  (cm), with p of REF
!!      exten(13): Sum( (dp/p)*y(i) )  (cm), with p of REF
!!      exten(14): Sum( (dp/p)*(dp/p) )  compared to p of REF
!!      exten(15): Sum( (dp/p)*x(i) )  (cm), with p of COG
!!      exten(16): Sum( (dp/p)*y(i) )  (cm), with p of COG
!!      exten(17): Sum( (dp/p)*(dp/p) )  compared to p of COG
!< *******************************************************************
       SUBROUTINE ext2d(IDCH)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON/DYN/TREF,VREF
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       dimension ffd(iptsz)
       LOGICAL chasit,acpt
       exten(1)=0.
       exten(2)=0.
       exten(3)=0.
       exten(4)=0.
       exten(5)=0.
       exten(6)=0.
       exten(7)=0.
       exten(8)=0.
       exten(9)=0.
       exten(12)=0.
       exten(13)=0.
       exten(14)=0.
       exten(15)=0.
       exten(16)=0.
       exten(17)=0.
       qmoy=0.
! --- imaxf: particles keep in the bunch. With CHASE imaxf may be different from ngood(i.e. imaxf < ngood)
       imaxf=0
       gcog=cog(1)/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       if(acpt) then
         bref=vrefi/vl
       else
         bref=vref/vl
       endif
       gref=1./sqrt(1.-bref*bref)
       do i=1,ngood
         gpai=f(7,i)/xmat
         if(gpai.gt.1) then
           bpai=sqrt(1.-1./(gpai*gpai))
         else
           bpai=0.
           gpai=1.
         endif
         fd(i)=(gpai*bpai)/(gref*bref)
         ffd(i)=(gpai*bpai)/(gcog*bcog)
       enddo
       do i=1,ngood
         FDPP=fd(i)-1.
         FFDPP=ffd(i)-1.
         fdp=f(7,i)-cog(1)
         TRPH1=FH*(f(6,i)-cog(3))
         TRXF=F(2,I)-COG(4)
         TRTF=F(3,I)-cog(5)
         TRYF=F(4,I)-COG(6)
         TRPF=F(5,I)-cog(7)
! --- without CHASE
         IF(IDCH.NE.1) THEN
           exten(1)=exten(1)+FDP**2
           exten(2)=exten(2)+TRPH1*FDP
           exten(3)=exten(3)+TRPH1**2
           EXTEN(4)=EXTEN(4)+TRXF**2
           exten(5)=exten(5)+TRTF**2
           EXTEN(6)=EXTEN(6)+TRYF**2
           exten(7)=exten(7)+TRPF**2
           EXTEN(8)=EXTEN(8)+TRXF*TRTF
           EXTEN(9)=EXTEN(9)+TRYF*TRPF
           exten(12)=exten(12)+FDPP*TRXF
           exten(13)=exten(13)+FDPP*TRYF
           exten(14)=exten(14)+FDPP**2
           exten(15)=exten(15)+FFDPP*TRXF
           exten(16)=exten(16)+FFDPP*TRYF
           exten(17)=exten(17)+FFDPP**2
           qmoy=qmoy+f(9,i)
           imaxf=imaxf+1
         ELSEIF(IDCH.EQ.1.AND.ICHAS(I).EQ.1) THEN
! --- with CHASE
           exten(1)=exten(1)+FDP**2
           exten(2)=exten(2)+TRPH1*FDP
           exten(3)=exten(3)+TRPH1**2
           EXTEN(4)=EXTEN(4)+TRXF**2
           exten(5)=exten(5)+TRTF**2
           EXTEN(6)=EXTEN(6)+TRYF**2
           exten(7)=exten(7)+TRPF**2
           EXTEN(8)=EXTEN(8)+TRXF*TRTF
           EXTEN(9)=EXTEN(9)+TRYF*TRPF
           exten(12)=exten(12)+FDPP*TRXF
           exten(13)=exten(13)+FDPP*TRYF
           exten(14)=exten(14)+FDPP**2
           exten(15)=exten(15)+FFDPP*TRXF
           exten(16)=exten(16)+FFDPP*TRYF
           exten(17)=exten(17)+FFDPP**2
           qmoy=qmoy+f(9,i)
           imaxf=imaxf+1
         ENDIF
       enddo
       do i=1,9
         exten(i)=exten(i)/float(imaxf)
       enddo
       do i=12,17
         exten(i)=exten(i)/float(imaxf)
       enddo
       qmoy=qmoy/float(imaxf)
       return
       end
!> *******************************************************************
!! SUBROUTINE ext2(IDCH)
!! Looks for average extensions squared and return them in array exten
!! Used in the routines: stapl  tiltbm  ytzp
!!
!!      IDCH EQ 1: WITH  CHASE TEST
!!      IDCH NE 1: OTHERWISE
!!
!!        cog(1) : Energy(MeV)
!!        cog(3) : t.o.f. (sec)
!!        cog(4) : x-direction (cm)
!!        cog(5) : xp(mrd)
!!        cog(6) : y-direction (cm)
!!        cog(7) : yp(mrd)
!!
!!      exten(1) : Sum( (dp/p)*(dp/p) ) compared to p of COG
!!      exten(2) : Sum( (dp/p)*phase )  (rad)
!!      exten(3) : Sum( phase*phase) ) (rad*rad)
!!      exten(4) : Sum( x(i)*x(i) )   cm*cm
!!      exten(5) : Sum( xp(i)*xp(i) )   mrad*mrad
!!      exten(6) : Sum( y(i)*y(i) )   cm*cm
!!      exten(7) : Sum( yp(i)*yp(i) )  mrad*mrad
!!      exten(8) : Sum( x(i)*xp(i) )   cm*mrad
!!      exten(9) : Sum( y(i)*yp(i) )   cm*mrad
!!      exten(10): Sum( dE*dE )        (MeV*MeV)
!!      exten(11): Sum( dE*phase )     (MeV*rad)
!!      exten(12): Sum( (dp/p)*x(i) )  (cm), with p of REF
!!      exten(13): Sum( (dp/p)*y(i) )  (cm), with p of REF
!!      exten(14): Sum( (dp/p)*(dp/p) ) compared to p of REF
!!      exten(15): Sum( (dp/p)*x(i) )  (cm), with p of COG
!!      exten(16): Sum( (dp/p)*y(i) )  (cm), with p of COG
!!      exten(17): Sum( (dp/p)*(dp/p) )  compared to p of COG
!< *******************************************************************
       SUBROUTINE ext2(IDCH)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON/DYN/TREF,VREF
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       dimension fdd(iptsz)
       LOGICAL chasit,acpt
! EXT2 looks for average extensions squared and returns them in exten(14)
       exten(1)=0.
       exten(2)=0.
       exten(3)=0.
       exten(4)=0.
       exten(5)=0.
       exten(6)=0.
       exten(7)=0.
       exten(8)=0.
       exten(9)=0.
       exten(10)=0.
       exten(11)=0.
       exten(12)=0.
       exten(13)=0.
       exten(14)=0.
       exten(15)=0.
       exten(16)=0.
       exten(17)=0.
       qmoy=0.
       imaxf=0
       gcog=cog(1)/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       if(acpt) then
         bref=vrefi/vl
       else
         bref=vref/vl
       endif
       gref=1./sqrt(1.-bref*bref)
       do i=1,ngood
         gpai=f(7,i)/xmat
         if(gpai.gt.1) then
           bpai=sqrt(1.-1./(gpai*gpai))
         else
           bpai=0.
           gpai=1.
         endif
         fd(i)=(gpai*bpai)/(gcog*bcog)
         fdd(i)=(gpai*bpai)/(gref*bref)
       enddo
       do i=1,ngood
         fdp=fd(i)-1.
         FDDP=fdd(i)-1.
         dener=f(7,i)-cog(1)
         TRPH1=FH*(f(6,i)-cog(3))
         TRXF=F(2,I)-COG(4)
         TRTF=F(3,I)-cog(5)
         TRYF=F(4,I)-COG(6)
         TRPF=F(5,I)-cog(7)
         IF(IDCH.EQ.1.AND.ICHAS(I).EQ.1) THEN
           exten(1)=exten(1)+FDP**2
           exten(2)=exten(2)+TRPH1*FDP
           exten(3)=exten(3)+TRPH1**2
           EXTEN(4)=EXTEN(4)+TRXF**2
           exten(5)=exten(5)+TRTF**2
           EXTEN(6)=EXTEN(6)+TRYF**2
           exten(7)=exten(7)+TRPF**2
           EXTEN(8)=EXTEN(8)+TRXF*TRTF
           EXTEN(9)=EXTEN(9)+TRYF*TRPF
           exten(10)=exten(10)+dener*dener
           exten(11)=exten(11)+dener*trph1
           exten(12)=exten(12)+FDDP*TRXF
           exten(13)=exten(13)+FDDP*TRYF
           exten(14)=exten(14)+FDDP**2
           exten(15)=exten(15)+FDP*TRXF
           exten(16)=exten(16)+FDP*TRYF
           exten(17)=exten(17)+FDP**2
           qmoy=qmoy+f(9,i)
           imaxf=imaxf+1
         ENDIF
         IF(IDCH.NE.1) THEN
           exten(1)=exten(1)+FDP**2
           exten(2)=exten(2)+TRPH1*FDP
           exten(3)=exten(3)+TRPH1**2
           EXTEN(4)=EXTEN(4)+TRXF**2
           exten(5)=exten(5)+TRTF**2
           EXTEN(6)=EXTEN(6)+TRYF**2
           exten(7)=exten(7)+TRPF**2
           EXTEN(8)=EXTEN(8)+TRXF*TRTF
           EXTEN(9)=EXTEN(9)+TRYF*TRPF
           exten(10)=exten(10)+dener*dener
           exten(11)=exten(11)+dener*trph1
           exten(12)=exten(12)+FDDP*TRXF
           exten(13)=exten(13)+FDDP*TRYF
           exten(14)=exten(14)+FDDP**2
           exten(15)=exten(15)+FDP*TRXF
           exten(16)=exten(16)+FDP*TRYF
           exten(17)=exten(17)+FDP**2
           qmoy=qmoy+f(9,i)
           imaxf=imaxf+1
         ENDIF
       enddo
       do i=1,17
         exten(i)=exten(i)/float(imaxf)
       enddo
       qmoy=qmoy/float(imaxf)
       return
       end
!> *******************************************************************
!! SUBROUTINE chrefe
!! change of reference frame
!!   ENTRY : XC YC A
!!    XC   : DISPLACEMENT IN THE HORIZONTAL DIRECTION (CM)
!!    YC   : DISPLACEMENT IN THE VERTICAL DIRECTION   (CM)
!!    A    : ROTATION ABOUT THE vertical AXIS         (DEG)
!< *******************************************************************
       SUBROUTINE chrefe
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       common/tapes/in,ifile,meta,ierr
       READ(IN,*)XC,YC,A
       a=a*pi/180.
       WRITE(16,100)XC,YC,A
       do i=1,ngood
         x=f(2,i)
         xp=f(3,i)*0.001
         yp=f(5,i)*0.001
         y=f(4,i)
         x0=x
         x=((x-yc)*cos(xp)+xc*sin(xp))/cos(xp-a)
         xp=xp-a
         xl=xc-x*sin(a)
         yl=yc-x0+x*cos(a)
         dl=sqrt(xl*xl+yl*yl)
         dl=sign(dl,xl)
         y=y+dl*tan(yp)
         f(2,i)=x
         f(3,i)=xp*1000.
         f(4,i)=y
         f(5,i)=yp*1000.
       enddo
  100  FORMAT(' New reference frame  XC =',F6.2,' CM , YC =',
     *         F6.2,' CM , A =',F6.4,' RADIAN',///)
       return
       end
!> *******************************************************************
!! SUBROUTINE etac
!! Several charge states in the  bunch, generated randomly
!!   ENTRY :
!!     N       : Number of charge states (maximum 6 different charge states)
!!     CHARGE(I)  PCENT(I)  EOFF (I = 1 to N )
!!     CHARGE(I)    : charge state
!!     PCENT(I)     : percentage of charge state
!!     EOFF(I)      : absolute energy offset of charge state w.r.t. COG (MeV)
!!     ix           : RANDOM NUMBER GENERATOR
!< *******************************************************************
       SUBROUTINE etac
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       common/tapes/in,ifile,meta,ierr
       common/mcs/imcs,ncstat,cstat(20)
       common/paths/dpath
       character*(256) dpath       
       dimension charge(20),pcent(20),charm(20),pc(20),eoff(20),vecx(1)
!       dimension foo(20,9),NDP(20)
       character myfile*256
       READ(IN,*) NCSTAT
       N=NCSTAT
       IF (N.GT.20) THEN
         WRITE (16,140) N
         STOP
       ENDIF
       imcs=1
       IF(N.EQ.0) then
! read charge state distribution from file
         myfile=''
         READ(in,'(A)') myfile
         lpath=LEN_TRIM(dpath)
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         write(16,*) 'Charge state distribution file: ',myfile
         open(56,file=myfile,status='unknown')
         read(56,*) ntot
         write(16,*) 'Maximum number of particles:',imax
         write(16,*) 'Number  of   good particles:',ngood
         write(16,*) 'Number of particles in charge state file:',ntot
         IF(ntot.lt.ngood) then
           write(16,*) 'Not enough particles in charge state file'
           STOP
         ENDIF
         DO J=1,ntot
           read(56,*) chstate
           f(9,i)=chstate
         enddo
         close(56)
       ELSE
! generate charge state distribution
         POURC=0.
         DO I=1,N
! for each charge state read charge, percentage and energy offset
           READ(IN,*) charm(I),PC(I),eoff(i)
           CSTAT(i)=charm(i)
           POURC=POURC+PC(I)
!           IF (POURC.GT.100.) THEN
           IF (POURC-100. .GT. 0.0000000000001) THEN
             WRITE (16,100) I,POURC
             STOP
           ENDIF
         enddo
         POURC=0.
         DO I=1,N
!           WRITE(16,110) charm(I),PC(I),eoff(i)
           POURC=POURC+PC(I)
         enddo
!         IF (POURC.NE.100.) THEN
         IF (POURC-100. .LT. -0.0000000000001) THEN
           WRITE (16,120) POURC
           STOP
         ENDIF
         j=1
         DO
           if(j.gt.n) exit
           ts=500.
           is=1
           do i=1,n
             if(ts.ge.charm(i)) then
               ts=charm(i)
               is=i
             endif
           enddo
           charge(j)=ts
           pcent(j)=pc(is)
           charm(is)=1000.
           j=j+1
         ENDDO  
         write(16,*) '**********************'
! for each charge state write charge, percentage and energy offset
         jjj=0
         do i=1,n
           WRITE(16,110) CHARGE(I),PCENT(I),eoff(i)
!           if(charge(i).eq.qst) jjj=1
           if(int(charge(i)).eq.int(qst)) jjj=1
         enddo
         len=1
! FIRST TRAJECTORY HAS CHARGE STATE AS DEFINED BY INPUT
         PCENT(1)=PCENT(1)/100.
         DO I=2,N
           PCENT(I)=PCENT(I-1)+PCENT(I)/100.
         enddo
         DO I=1,IMAX
           call rlux(vecx,len)
           XARPHA=VECX(1)
           IF (XARPHA.LE.PCENT(1)) THEN
             f(9,i)=CHARGE(1)
             f(7,i)=f(7,i)+eoff(1)
           ELSE
             DO J=1,N-1
               IF (XARPHA.GT.PCENT(J) .AND. XARPHA.LE.PCENT(J+1))then
                 f(7,i)=f(7,i)+eoff(J+1)
                 f(9,i)=CHARGE(J+1)
               ENDIF
             enddo
           ENDIF
         ENDDO
       ENDIF
! print energy, boro for each charge state
! 2016-04-17 ET code below eliminated: replaced by call to emiprt
!       DO k=1,ncstat
!         NDP(k)=0
!         do j=2,7
!           foo(k,j)=0.
!         enddo
!       ENDDO
!       DO i=1,imax
!         DO k=1,ncstat
!           if(f(9,i).eq.cstat(k)) then
!             NDP(k)=NDP(k)+1
!             do j=2,7
!               foo(k,j)=foo(k,j)+f(j,i)
!             enddo
!           endif
!         ENDDO
!       ENDDO
!       DO k=1,ncstat
!         do j=2,7
!           foo(k,j)=foo(k,j)/float(NDP(k))
!         enddo
!       ENDDO
!       DO k=1,ncstat
!         gref=foo(k,7)/xmat
!         bref=sqrt(1.-1./(gref*gref))
!         xe=(gref-1.)*xmat
!   magnetic rigidity
!         bor=3.3356*xmat*bref*gref/cstat(k)
!         write(16,*) ' Q: ',cstat(k),' COG : energy ',xe,
!     *     ' MeV  momentum ',bor,' kG.cm'
!       ENDDO
       call emiprt(0)
100    FORMAT(3X,' WRONG PERCENTAGE IN CHARGE STATE DISTRIBUTION',/,
     * 4X,' CHARGE STATE ',I3,' PERCENTAGE ',E14.7)
110    FORMAT(3X,' CHARGE STATE ',F6.1,'  PERCENTAGE ',E12.5,' %',
     * 4X,' ENERGY OFFSET ',E12.5,' MeV')
120    FORMAT(3X,' TOTAL PERCENTAGE OF ALL CHARGE STATES < 100 %',/,
     * 4X,' PERCENTAGE ',E12.5)
140    FORMAT(3X,' NUMBER OF CHARGE STATES : ',I3,' GREATER THAN 20')
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE crest(betr,eqvl,xpos,bkcr,ffield)
!! called by RESTAY
!! Look for the beta giving the maximun energy gain
!! iterative method
!< *******************************************************************
       SUBROUTINE crest(betr,eqvl,xpos,bkcr,ffield)
       implicit real(8) (a-h,o-z)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       XLHE=YLG
       ITR=0
       BE1=BETR
       BE2=BETR-8.333e-03*BETR
       XLEQ=XLHE
       DO
         ITR=ITR+1
         XK1=FH/(VL*BE1)
         XK2=FH/(VL*BE2)
         T1=TTA0(BE1)*ffield
         S1=TSB0(BE1)*ffield
         TP1=TTA1(BE1)*ffield
         SP1=TSB1(BE1)*ffield
         T2=TTA0(BE2)*ffield
         S2=TSB0(BE2)*ffield
         TP2=TTA1(BE2)*ffield
         SP2=TSB1(BE2)*ffield
         DTS=(T1*TP1+S1*SP1)/(T1*T1+S1*S1)
         A1K12=(T1*TP1+S1*SP1)/(T2*TP2+S2*SP2)
         A2K12=(T2*T2+S2*S2)/(T1*T1+S1*S1)
         AK12=A1K12*A2K12
         AK12=1./AK12
         BK12=(XK2-XK1)/(AK12-1.)
         BK12=BK12*DTS
         DESY=-4.*ATAN(DTS*3.2/XLEQ)
!     improve  DESYNCHRONISATION
         EPSRD=1.e-04
         IF(ABS(DESY).GE.EPSRD) THEN
           TIL2=DESY/2.
           DO III=1,3
             FTIL=TIL2/TAN(TIL2)-1.-BK12
             DFTIL=-TIL2/(SIN(TIL2)*SIN(TIL2))+1./TAN(TIL2)
             TIL2=TIL2-FTIL/DFTIL
           ENDDO
           DESY=TIL2*2.
         ENDIF
         IF(ABS(DESY).LT.EPSRD) EXIT
!           XPOS=(T1*SP1-S1*TP1)/(T1*T1+S1*S1)
!           BKCR=SQRT(T1*T1+S1*S1)
!           EQVL=XLEQ
!           RETURN
!         ENDIF
!    calculates the equivalent length
         XLEQ=DESY*(AK12-1.)/(XK2-XK1)
         DELTK=DESY/XLEQ
         XKCRT=XK1-DELTK
         BECRT=FH/(VL*XKCRT)
         BE1=BECRT
         BE2=BECRT-BECRT/120.
       ENDDO  
       XPOS=(T1*SP1-S1*TP1)/(T1*T1+S1*S1)
       BKCR=SQRT(T1*T1+S1*S1)
       EQVL=XLEQ
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE gaus(r1,r2,z1,z2,opt,er,ez)
!! called by SCHEFF
!! calculate er and ez at the r and z location given in fldcom
!! by gauss quadrature integration over the double
!! interval from r1 to r2 and from z1 to z2.
!! if opt.gt.0, determine number of integration points as follows.
!! let rat = max(cr/cz,cz/cr), where cr=r2-r1, and cz=z2-z1
!!     if rat.le.2, use 2 x 2 point array
!!     if rat.gt.2, use 2 x 4 point array
!!     if rat.gt.4, use 2 x 6 point array
!! if opt.lt.0, use 2 x 2 point array regardless of rat
!< *******************************************************************
       SUBROUTINE gaus(r1,r2,z1,z2,opt,er,ez)
       implicit real(8) (a-h,o-z)
       dimension r(6),z(6),wr(6),wz(6),xx(3,3),wx(3,3)
       data ((xx(i,j),i=1,3),j=1,3)/.2113248654,0.0,0.0,
     1   .06943184420,
     1  .33000947820,0.0,.03376524290,.16939530680,.3806904070/
       data ((wx(i,j),i=1,3),j=1,3)/.50,0.0,0.0,.17392742260,
     1   .32607257740,
     1  0.0, .085662246190,.1803807865000,.2339569673000/
       cr=r2-r1
       cz=z2-z1
       ir=1
       jz=1
       m=1
       if (opt.ge.0.) then
!---determine number of integration points
         rat=abs(cz/cr)
         l=0
         if (rat.lt.1.) then
           rat=1./rat
           l=1
         endif
         if (rat.gt.2.)m=2
         if (rat.gt.4.)m=3
         if (l.eq.0) jz=m
         if (l.eq.1) ir=m
       endif
       do i=1,ir
         k=2*i-1
         r(k)=r1+cr*xx(i,ir)
         r(k+1)=r2-cr*xx(i,ir)
         wr(k)=wx(i,ir)
         wr(k+1)=wx(i,ir)
       enddo
       do j=1,jz
         k=2*j-1
         z(k)=z1+cz*xx(j,jz)
         z(k+1)=z2-cz*xx(j,jz)
         wz(k)=wx(j,jz)
         wz(k+1)=wx(j,jz)
       enddo
       ser=0.
       sez=0.
       kr=2*ir
       kz=2*jz
       do i=1,kr
         do j=1,kz
           call flds(r(i),z(j),er1,ez1)
           ser=ser+wr(i)*wz(j)*er1*r(i)
           sez=sez+wr(i)*wz(j)*ez1*r(i)
         enddo
       enddo
       er=cr*cz*ser
       ez=cr*cz*sez
       return
       end
!> *******************************************************************
!! SUBROUTINE flds(r,z,er,ez)
!! called by SCHEFF
!! evaluate fields at r1,z1 due to ring of charge at r,z.
!! er=(pi/2)*r/d**3.     ez=(pi/2)*z/d**3.
!< *******************************************************************
       SUBROUTINE flds(r,z,er,ez)
       implicit real(8) (a-h,o-z)
       common/fldcom/ rp, zp,pl,opt,nip
       r1=rp
       z1=zp
       fprec=epsilon(r1)
! **********************************
       d=z1-z
       c=(r1-r)**2
       b=(r1+r)**2
       a=4.0*r*r1/(b+d**2)
       call eint (a,ee,ek)
       er1=0.0
       a=sqrt(b+d**2)
!       if (r1.ne.0.) then
       if (abs(r1).gt.fprec) then
         er1=(ek-(r**2-r1**2+d**2)*ee/(c+d**2))/(2.0*r1*a)
       endif
       ez1=d*ee/(a*(c+d**2))
       if (nip.ne.0) then
         do i=1,nip
           xi=i
           do j=1,2
             d=z1-(z+xi*pl)
             a=4.0*r*r1/(b+d**2)
             call eint (a,ee,ek)
             a=sqrt(b+d**2)
!             if (r1.ne.0.) then
             if (abs(r1).gt.fprec) then
               er1=er1+(ek-(r**2-r1**2+d**2)*ee/(c+d**2))/(2.0*r1*a)
             endif
             ez1=ez1+d*ee/(a*(c+d**2))
             xi=-xi
           enddo
         enddo
       endif
       er=er1
       ez=ez1
       return
       end
!> *******************************************************************
!! SUBROUTINE eint(a,ee,ek)
!! evaluate elliptic integrals  ( called by SCHEFF)
!< *******************************************************************
       SUBROUTINE eint(a,ee,ek)
       implicit real(8) (a-h,o-z)
       b=1.0-a
       c=log(b)
       ee=1.0+b*(.4630106-0.2452740*c+b*(0.1077857-0.04125321*c))
       ek=1.38629436-.5*c+b*(0.1119697-0.1213486*c+
     *    b*(.07253230-.028874721*c))
       return
       end
!> *******************************************************************
!! SUBROUTINE tiltz(tilta)
!! Skew the right ellipse generated by GEBEAM in the phase plane (x,z)
!< *******************************************************************
       SUBROUTINE tiltz(tilta)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/DYN/TREF,VREF
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       WRITE(16,1)TILTA
1      FORMAT(' tilt in the plane (x,z) around the c.o.g',
     X '    ANGLE :',E12.5,' DEG',/)
        TILTA=TILTA*PI/180.
       tref=0.
       vref=0.
       DO I=1,imax
         gpai=f(7,i)/xmat
         vref=vref+vl*sqrt(1.-1./(gpai*gpai))
         tref=tref+f(6,i)
       enddo
       vref=vref/float(imax)
       tref=tref/float(imax)
       vref1=0.
       tref1=0.
       DO I=1,IMAX
         gpai=f(7,i)/xmat
         vpai=sqrt(1.-1./(gpai*gpai))*vl
         trot=(f(6,i)-tref)*cos(tilta)-sin(tilta)*f(2,i)/vpai
         xrot=(f(6,i)-tref)*sin(tilta)*vpai+cos(tilta)*f(2,i)
         f(6,i)=trot
         f(2,i)=xrot
         tref1=tref1+f(6,i)
         vref1=vref1+vpai
       ENDDO
       tref=tref1/float(imax)
       vref=vref1/float(imax)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE schfdyn
!! Input datas for SCHEFF
!!   SCE(2)=r extension in rms multiples
!!   SCE(3)=z half extension in rms multiples
!!   SCE(4)=no. of radial mesh intervals (le 20)
!!   SCE(5)=no. of longitudinal mesh intervals (le 40)
!!   sce(6)=no. of adjacent bunches, applicable for buncher studies
!!          and should be 0 for linac dynamics
!!   sce(7)=pulse length, if not beta lambda.(transport studies)
!!          distance bewteen beam pulses
!!          input zero to get default "beta lambda"
!!          units are cm
!!   sce(8)=dummy
!!   sce(9)=option to integrate space charge forces over box
!!          if.eq.0. no integration.  see sub gaus for further
!!          explanation.
!< *******************************************************************
       SUBROUTINE schfdyn
       implicit real(8) (a-h,o-z)
       common/tapes/in,ifile,meta,ierr
       common/rcshef/sce(20)
       read(in,*) iread
       if(iread.eq.0) then
!  standard SCHEFF parameters
         sce(2)=4.
         sce(3)=4.
         sce(4)=20
         sce(5)=40
         sce(6)=0
         sce(9)=0.
         sce(7)=0.
       else
!    read  SCHEFF parameters
         READ(IN,*) sce(2),sce(3),sce(4),sce(5),sce(6),sce(7),sce(9)
       endif
       sce(3)=sce(3)*2.
       sce(8)=0.
       call schefini
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE compress(pib)
!! PRINT OF PARTICLE COORDINATES
!< *******************************************************************
       SUBROUTINE compress(pib)
       implicit real(8) (a-h,o-z)
       parameter(iptsz=1000002)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
!       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
!       common/sc3/beamc,scdist,sce10,cplm,ectt,apl,ichaes,iscsp
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
!       COMMON/DYN/TREF,VREF
!       common/mcs/imcs,ncstat,cstat(20)
!       common/tapes/in,ifile,meta,ierr
!       common/etcha3/ichxyz(iptsz)
!       common/rec/irec
!       common/etcom/cog(8),exten(17),fd(iptsz)
!       logical chasit
!  Do so by shifting particles belonging to the same bunch outside the (+/-) pib window to
!   inside the +/- pib window.
       pib=pib*pi/180
       do ite=1,3
! Find cog of bunch in time
         tcog=0.
         do i=1,ngood
           tcog=tcog+f(6,i)
         enddo
         tcog=tcog/float(ngood)
       write(16,58) tcog*fh*180./pi
58     format(' cog phase before shifting particles: ',e13.7,' deg')
         do i=1,ngood
           drad=(f(6,i)-tcog)*fh
           if(drad.gt.pib) then
             f(6,i)=(f(6,i)-2.*pi/fh)
           endif
           if(drad.lt.-pib) then
             f(6,i)=(f(6,i)+2.*pi/fh)
           endif
         enddo
       enddo
! Find cog of bunch in time after shifting particles
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       write(16,59) tcog*fh*180./pi
59     format(' cog phase after shifting particles : ',e13.7,' deg')
       return
       end
!> *******************************************************************
!! SUBROUTINE prbeam(iflg,wfile,fromrfq)
!! PRINT OF PARTICLE COORDINATES TO A FILE
!< *******************************************************************
       SUBROUTINE prbeam(iflg,wfile,fromrfq)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/sc3/beamc,scdist,sce10,cplm,ectt,apl,ichaes,iscsp
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       common/mcs/imcs,ncstat,cstat(20)
       common/tapes/in,ifile,meta,ierr
       common/etcha3/ichxyz(iptsz)
       common/rec/irec
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/paths/dpath
       common/etchas/fractx,fracty,fractl       
       character*(256) dpath,myfile       
       common/disttype/bindst
       logical chasit,fromrfq,bindst
       character wfile*80
!      PRINT OF PARTICLE COORDINATES
!wdk       print*,'prbeam'
       myfile=''
       ecog=0.
       tcog=0.
       xav=0.
       xpav=0.
       yav=0.
       ypav=0.
! **********************************************
!   cog of the bunch
       do i=1,ngood
         ecog=ecog+f(7,i)
         tcog=tcog+f(6,i)
         xav=xav+f(2,i)
         xpav=xpav+f(3,i)
         yav=yav+f(4,i)
         ypav=ypav+f(5,i)
       enddo
       ecog=ecog/float(ngood)
       tcog=tcog/float(ngood)
       xav=xav/float(ngood)
       xpav=xpav/float(ngood)
       yav=yav/float(ngood)
       ypav=ypav/float(ngood)
! write particle coordinates to files,  phase in radian
       BEREF=VREF/VL
       GAMREF=1./SQRT(1.-(BEREF*BEREF))
       ENREF=XMAT*GAMREF
       myfile(1:80)=wfile
       lpath=LEN_TRIM(dpath)
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       if(fromrfq) then
         nunit=57
       else
         nunit=58 
         if(bindst) then
           open(nunit,file=myfile,status='unknown',
     *          form='unformatted')
         else     
           open(nunit,file=myfile,status='unknown')
         endif  
       endif  
       if(iflg.lt.100) then
         if(bindst) then
           write(nunit) ngood,iflg, fh/(2000000.*pi)
         else     
           write(nunit,*) ngood,iflg, fh/(2000000.*pi)
         endif  
       else
! iflg.ge.100
         if(bindst) then
           write(nunit) ngood,iflg, fh/(2000000.*pi),ENREF-xmat,
     *         ecog-xmat
         else     
           write(nunit,*) ngood,iflg, fh/(2000000.*pi),ENREF-xmat,
     *         ecog-xmat
         endif  
       endif
       f2=0.
       f3=0.
       f4=0.
       f5=0.
       do i=1,ngood
         if(irec.eq.2) then
! coordinates relative to the reference
           eprt=f(7,i)-enref
           tprt=fh*(f(6,i)-tref)
           f2=f(2,i)
           f3=f(3,i)
           f4=f(4,i)
           f5=f(5,i)
         endif
         if(irec.eq.1) then
! absolute values for phase and energy
           eprt=f(7,i)-xmat
           tprt=fh*(f(6,i)-tcog)
! **********************************
           f2=f(2,i)
           f3=f(3,i)
           f4=f(4,i)
           f5=f(5,i)
         endif
         if(irec.eq.0) then
! values for phase and energy relative to the COG
           tprt=fh*(f(6,i)-tcog)
           eprt=f(7,i)-ecog
           f2=f(2,i)-xav
           f3=f(3,i)-xpav
           f4=f(4,i)-yav
           f5=f(5,i)-ypav
         endif
         if(iflg.eq.0 .or. iflg.eq.100) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,tprt,eprt
           else
             write(nunit,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
           endif
         elseif(iflg.eq.1 .or. iflg.eq.101) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
           else     
             write(nunit,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
           endif
         elseif(iflg.eq.2 .or. iflg.eq.102) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
           else
             write(nunit,102)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
           endif
         elseif(iflg.eq.3 .or. iflg.eq.103) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i),
     *          f(1,i)
           else
             write(nunit,103)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i),
     *          f(1,i)
           endif
         elseif(iflg.eq.10 .or. iflg.eq.110) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *          eprt
           else
             write(nunit,100)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *          eprt
           endif
         elseif(iflg.eq.11 .or. iflg.eq.111) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *          eprt,f(1,i)
           else
             write(nunit,101)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *          eprt,f(1,i)
           endif
         elseif(iflg.eq.12 .or. iflg.eq.112) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *          eprt,f(9,i)
           else
             write(nunit,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *          eprt,f(9,i)
           endif
         elseif(iflg.eq.13 .or. iflg.eq.113) then
           if(bindst) then
             write(nunit)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *         eprt,f(9,i),f(1,i)
           else
             write(nunit,103)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,
     *         eprt,f(9,i),f(1,i)
           endif
         endif
       enddo
       if(fromrfq) then
       else
         close(nunit)
! print "chased" beam if selected         
         if (chasit) then
           if(fractl.lt.1.) then
! ******************
! ---  chase in z-zp
! ******************
             call chasel
! ngz is number of retained particles in Z         
             ngz=0
             ecogc=0.
             ecogr=0.
             do i=1,ngood
               ichxyz(i)=ichas(i)
               if(ichxyz(i).eq.1) then 
                 ngz=ngz+1
                 ecogc=ecogc+f(7,i)-xmat
               else  
                 ecogr=ecogr+f(7,i)-xmat            
               endif
             enddo
             ecogc=ecogc/float(ngz)
             ecogr=ecogr/float(ngood-ngz)
             if(iflg.lt.100) then           
               write(60,*) ngood-ngz,iflg,fh/(2000000.*pi)
               write(61,*) ngz,iflg,fh/(2000000.*pi)
             else
               write(60,*) ngood-ngz,iflg,fh/(2000000.*pi),enref-xmat,
     *            ecogr
               write(61,*) ngz,iflg,fh/(2000000.*pi),enref-xmat,ecogc
             endif  
             f2=0.
             f3=0.
             f4=0.
             f5=0.
             do i=1,ngood
               if(irec.eq.2) then
! coordinates relative to the reference
                 eprt=f(7,i)-enref
                 tprt=fh*(f(6,i)-tref)
                 f2=f(2,i)
                 f3=f(3,i)
                 f4=f(4,i)
                 f5=f(5,i)
               endif
               if(irec.eq.1) then
! absolute values for phase and energy
                 eprt=f(7,i)-xmat
                 tprt=fh*(f(6,i)-tcog)
! **********************************
                 f2=f(2,i)
                 f3=f(3,i)
                 f4=f(4,i)
                 f5=f(5,i)
               endif
               if(irec.eq.0) then
! values for phase and energy relative to the COG
                 tprt=fh*(f(6,i)-tcog)
                 eprt=f(7,i)-ecog
                 f2=f(2,i)-xav
                 f3=f(3,i)-xpav
                 f4=f(4,i)-yav
                 f5=f(5,i)-ypav
               endif
               if(ichxyz(i).eq.0) then
!  ************** only with CHASE, write to file particles removed                          
                 if(iflg.eq.0 .or. iflg.eq.100)
     *       write(60,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
                 if(iflg.eq.10 .or. iflg.eq.110)
     *       write(60,100)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt
                 if(iflg.eq.1 .or. iflg.eq.101)
     *       write(60,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
                 if(iflg.eq.11 .or. iflg.eq.111)
     *       write(60,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(1,i)
                 if(iflg.eq.2 .or. iflg.eq.102)
     *       write(60,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
                 if(iflg.eq.12 .or. iflg.eq.112)
     *       write(60,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(9,i)
               else
!  ************** only with CHASE, write to file particles kept
                 if(iflg.eq.0 .or. iflg.eq.100)
     *       write(61,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
                 if(iflg.eq.10 .or. iflg.eq.110)
     *       write(61,100)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt
                 if(iflg.eq.1 .or. iflg.eq.101)
     *       write(61,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
                 if(iflg.eq.11 .or. iflg.eq.111)
     *       write(61,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(1,i)
                 if(iflg.eq.2 .or. iflg.eq.102)
     *       write(61,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
                 if(iflg.eq.12 .or. iflg.eq.112)
     *       write(61,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(9,i)
               endif
             enddo
           endif                       
           if(fractx.lt.1.) then
! ******************
! ---  chase in x-xp
! ******************
             call chasex
! ngx is number of retained particles in X         
             ngx=0
             ecogc=0.
             ecogr=0.             
             do i=1,ngood
               ichxyz(i)=ichas(i)
               if(ichxyz(i).eq.1) then
                 ngx=ngx+1
                 ecogc=ecogc+f(7,i)-xmat
               else  
                 ecogr=ecogr+f(7,i)-xmat            
               endif
             enddo
             ecogc=ecogc/float(ngx)
             ecogr=ecogr/float(ngood-ngx)
             if(iflg.lt.100) then           
               write(62,*) ngood-ngx,iflg,fh/(2000000.*pi)
               write(63,*) ngx,iflg,fh/(2000000.*pi)
             else
               write(62,*) ngood-ngx,iflg,fh/(2000000.*pi),enref-xmat,
     *            ecogr
               write(63,*) ngx,iflg,fh/(2000000.*pi),enref-xmat,ecogc
             endif  
             f2=0.
             f3=0.
             f4=0.
             f5=0.
             do i=1,ngood  
               if(irec.eq.2) then
! coordinates relative to the reference
                 eprt=f(7,i)-enref
                 tprt=fh*(f(6,i)-tref)
                 f2=f(2,i)
                 f3=f(3,i)
                 f4=f(4,i)
                 f5=f(5,i)
               endif
               if(irec.eq.1) then
! absolute values for phase and energy
                 eprt=f(7,i)-xmat
                 tprt=fh*(f(6,i)-tcog)
! **********************************
                 f2=f(2,i)
                 f3=f(3,i)
                 f4=f(4,i)
                 f5=f(5,i)
               endif
               if(irec.eq.0) then
! values for phase and energy relative to the COG
                 tprt=fh*(f(6,i)-tcog)
                 eprt=f(7,i)-ecog
                 f2=f(2,i)-xav
                 f3=f(3,i)-xpav
                 f4=f(4,i)-yav
                 f5=f(5,i)-ypav
               endif
               if(ichxyz(i).eq.0) then
!  ************** only with CHASE, write to file particles removed                          
                 if(iflg.eq.0 .or. iflg.eq.100)
     *       write(62,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
                 if(iflg.eq.10 .or. iflg.eq.110)
     *       write(62,100)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt
                 if(iflg.eq.1 .or. iflg.eq.101)
     *       write(62,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
                 if(iflg.eq.11 .or. iflg.eq.111)
     *       write(62,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(1,i)
                 if(iflg.eq.2 .or. iflg.eq.102)
     *       write(62,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
                 if(iflg.eq.12 .or. iflg.eq.112)
     *       write(62,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(9,i)
               else
!  ************** only with CHASE, write to file particles kept
                 if(iflg.eq.0 .or. iflg.eq.100)
     *       write(63,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
                 if(iflg.eq.10 .or. iflg.eq.110)
     *       write(63,100)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt
                 if(iflg.eq.1 .or. iflg.eq.101)
     *       write(63,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
                 if(iflg.eq.11 .or. iflg.eq.111)
     *       write(63,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(1,i)
                 if(iflg.eq.2 .or. iflg.eq.102)
     *       write(63,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
                 if(iflg.eq.12 .or. iflg.eq.112)
     *       write(63,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(9,i)
               endif
             enddo
           endif            
           if(fracty.lt.1.) then
! ******************
! ---  chase in y-yp
! ******************
             call chasey
! ngy is number of retained particles in Y         
             ngy=0
             ecogc=0.
             ecogr=0.
             do i=1,ngood
               ichxyz(i)=ichas(i)
               if(ichxyz(i).eq.1) then
                 ngy=ngy+1
                 ecogc=ecogc+f(7,i)-xmat
               else  
                 ecogr=ecogr+f(7,i)-xmat            
               endif
             enddo
             ecogc=ecogc/float(ngy)
             ecogr=ecogr/float(ngood-ngy)
             if(iflg.lt.100) then           
               write(64,*) ngood-ngy,iflg,fh/(2000000.*pi)
               write(65,*) ngy,iflg,fh/(2000000.*pi)
             else
               write(64,*) ngood-ngy,iflg,fh/(2000000.*pi),enref-xmat,
     *            ecogr
               write(65,*) ngy,iflg,fh/(2000000.*pi),enref-xmat,ecogc
             endif  
             f2=0.
             f3=0.
             f4=0.
             f5=0.
             do i=1,ngood
               if(irec.eq.2) then
! coordinates relative to the reference
                 eprt=f(7,i)-enref
                 tprt=fh*(f(6,i)-tref)
                 f2=f(2,i)
                 f3=f(3,i)
                 f4=f(4,i)
                 f5=f(5,i)
               endif
               if(irec.eq.1) then
! absolute values for phase and energy
                 eprt=f(7,i)-xmat
                 tprt=fh*(f(6,i)-tcog)
! **********************************
                 f2=f(2,i)
                 f3=f(3,i)
                 f4=f(4,i)
                 f5=f(5,i)
               endif
               if(irec.eq.0) then
! values for phase and energy relative to the COG
                 tprt=fh*(f(6,i)-tcog)
                 eprt=f(7,i)-ecog
                 f2=f(2,i)-xav
                 f3=f(3,i)-xpav
                 f4=f(4,i)-yav
                 f5=f(5,i)-ypav
               endif                                       
               if(ichxyz(i).eq.0) then
!  ************** only with CHASE, write to file particles removed                          
                 if(iflg.eq.0 .or. iflg.eq.100)
     *       write(64,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
                 if(iflg.eq.10 .or. iflg.eq.110)
     *       write(64,100)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt
                 if(iflg.eq.1 .or. iflg.eq.101)
     *       write(64,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
                 if(iflg.eq.11 .or. iflg.eq.111)
     *       write(64,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(1,i)
                 if(iflg.eq.2 .or. iflg.eq.102)
     *       write(64,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
                 if(iflg.eq.12 .or. iflg.eq.112)
     *       write(64,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(9,i)
               else
!  ************** only with CHASE, write to file particles kept
                 if(iflg.eq.0 .or. iflg.eq.100)
     *       write(65,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
                 if(iflg.eq.10 .or. iflg.eq.110)
     *       write(65,100)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt
                 if(iflg.eq.1 .or. iflg.eq.101)
     *       write(65,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(1,i)
                 if(iflg.eq.11 .or. iflg.eq.111)
     *       write(65,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(1,i)
                 if(iflg.eq.2 .or. iflg.eq.102)
     *       write(65,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,i)
                 if(iflg.eq.12 .or. iflg.eq.112)
     *       write(65,102)f2,f3/1000.,f4,f5/1000.,1.e09*tprt/fh,eprt,
     *       f(9,i)
               endif
             enddo
! following endif fracty             
           endif            
! following endif chaseit             
         endif
! following endif fromrfq             
       endif
100    format(6(e13.6,1x))
101    format(7(e13.6,1x))
102    format(7(e13.6,1x))
103    format(8(e13.6,1x))
       return
       end
!> *******************************************************************
!! SUBROUTINE gausse
!! called by HERSC
!! GAUSS method
!< *******************************************************************
       SUBROUTINE gausse
       implicit real(8) (a-h,o-z)
       common/gauss1/absg(40),wg(40),igaus
       common/randu/ck(15),kmax
       dimension ui(40),u9(9),u10(10),u12(12)
       dimension w9(9),w10(10),w12(12)
!   GAUSS n=9 de -1. a 1
       DATA (U9(J),J=1,9)/-.9681602,-.8360311,-.6133714,-.3242534,0.,
     1                     .3242534,.6133714,.8360311,.9681602/
       data (w9(j),j=1,9)/.0812744,.1806482,.2606107,.3123471,.3302394,
     1                     .3123471,.2606107,.1806482,.0812744/
!   GAUSS n=10 de -1. a 1
       DATA (U10(J),J=1,10)/-.9739065,-.8650634,-.6794096,-.4333954,
     1   -.1488743,.1488743,.4333954,.6794096,.8650634,.9739065/
       data (w10(j),j=1,10)/.0666713,.1494513,.2190864,.2692667,
     1   .2955242,.2955242,.2692667,.2190864,.1494513,.0666713/
!   GAUSS n=12 de -1. a 1
       DATA (U12(J),J=1,12)/-.9815606,-.9041173,-.7699027,-.5873180,
     1   -.3678315,-.1252334,.1252334,.3678315,.5873180,.7699027,
     2    .9041173,.9815606/
       data (w12(j),j=1,12)/.0471753,.1069393,.1600783,.2031674,
     1   .2334925,.2491470,.2491470,.2334925,.2031674,.1600783,
     2   .1069393,.0471753/
!    built the abscissas from (-1,1) to (1,0)
       if(igaus.eq.9) then
         do i=1,igaus
           ui(i)=u9(i)
           wg(i)=w9(i)
         enddo
       endif
!   following options in case one wishes to use 10 or 12 steps
       if(igaus.eq.10) then
         do i=1,igaus
           ui(i)=u10(i)
           wg(i)=w10(i)
         enddo
       endif
       if(igaus.eq.12) then
         do i=1,igaus
           ui(i)=u12(i)
           wg(i)=w12(i)
         enddo
       endif
       do i=1,igaus
         absg(i)=(1.+ui(i))/2.
         wg(i)=wg(i)/2.
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE table(lbmax,mbmax,nbmax)
!! called by HERSC
!! arrays of variables independent of the coordinates of particles
!! lbmax,mbmax,nbmax are the maximum degrees of the
!! coefficients A(l,m,n)
!< *******************************************************************
       SUBROUTINE table(lbmax,mbmax,nbmax)
       implicit real(8) (a-h,o-z)
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/randu/ck(15),kmax
       common/hass/carg(100),sarg(100),argip(100)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/consta/vl,pi,xmat,rpel,qst
       common/factor/fpir(40,40),fect(30)
!       maximum of subscripts : ideg
! igaus: order of the Gauss integration ******
!  maximum of lbmax,mmax,nbmax -->ideg
       ideg=nbmax
       if(lbmax.ge.ideg) ideg=lbmax
       if(mbmax.ge.ideg) ideg=mbmax
       ideg=ideg+1
       idegp2=ideg+2
!  arrays of the power of the circular functions fo the Gauss positions absg(i)
!   the maximum power is ideg+2
       do i=1,igaus
         co(i,1)=1.
         sn(i,1)=1.
       enddo
       do i=1,igaus
         aco=pi*absg(i)/2.
         cod=cos(aco)
         snd=sin(aco)
         do j=2,idegp2
           co(i,j)=co(i,j-1)*cod
           sn(i,j)=sn(i,j-1)*snd
         enddo
       enddo
!    arrays used in the integrals of tables 75 and 76
!    absg(i)**2(t1+t2+t3+1)+1-->ragp(i,j) i: Gauss positions, j: is the power
       idgp=3*ideg+kmax
       kemax=kmax/2
       do i=1,igaus
         ragp(i,1)=1.
         ragm1(i,1)=1.
         absm2=(1.-absg(i))*(1.-absg(i))
         do j=2,idgp
           ragp(i,j)=ragp(i,j-1)*absg(i)
         enddo
!   storage of (absg(i)-1)**2*kemax -->ragm1
         do j=2,kemax+1
           ragm1(i,j)=ragm1(i,j-1)*absm2
         enddo
       enddo
       do i=1,idgp+1
         carg(i)=sqrt((4.*float(i-1)+1.)/2.)
         sarg(i)=sqrt((4.*float(i-1)+3.)/2.)
         argip(i)=sqrt(2.*float(i-1)+1.)
       enddo
!   store the factorials
       do i=1,40
         do j=1,i
           fpir(i,j)=fper(i-1,j-1)
         enddo
       enddo
       fj=1.
       fect(1)=1.
       do i=1,23
         fi=float(i)
         fj=fj*fi
         fect(i+1)=fj
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION fpar(i,j)
!! Factorial function called by HERSC
!< *******************************************************************
       FUNCTION fpar(i,j)
       implicit real(8) (a-h,o-z)
       common/factor/fpir(40,40),fect(30)
       ii=i+1
       jj=j+1
       fpar=fpir(ii,jj)
       return
       end
!> *******************************************************************
!! FUNCTION fper(i,j)
!! called by HERSC
!! i*(i-1)*(i-2)*...(i-j+1)/(1.2....j)
!< *******************************************************************
       FUNCTION fper(i,j)
       implicit real(8) (a-h,o-z)
       faci=1.
       facj=1.
       fper=1.
       if(i.eq.0) return
       if(j.eq.0) return
       do  k=1,j
         facj=facj*float(k)
       enddo
       ii=i
       do k=1,j
         faci=faci*float(ii)
         ii=ii-1
       enddo
       fper=faci/facj
       return
       end
!> *******************************************************************
!! FUNCTION hermint(s,ihd)
!! called by HERSC
!< *******************************************************************
       FUNCTION hermint(s,ihd)
       implicit real(8) (a-h,o-z)
       dimension he(100)
       hermint=0.
       if(ihd.eq.0) then
         hermint=1.
         return
       endif
       if(ihd.eq.1) then
         hermint=s
         return
       endif
       he(1)=1.
       he(2)=s
       m1=ihd-1
       do k=1,m1
         he(k+2)=s*he(k+1)-float(k)*he(k)
       enddo
       hermint=he(ihd+1)*exp(-s*s/2.)
       return
       end
!> *******************************************************************
!! FUNCTION fact(m)
!! FACTORIAL of M
!< *******************************************************************
       FUNCTION fact(m)
       implicit real(8) (a-h,o-z)
       FACT=1.
       IF(M.EQ.0) RETURN
       DO  K=1,M
         FACT=FACT*FLOAT(K)
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE bhdist
!! called by HERSC
!! computes: the coefficients A(l,m,n)
!!           the rms sizes in x, y and z-direction
!! selects:  the significants terms in the Hermite series expansion
!! lmax, mmax and nmax are the maximum values of l, m, n for these
!! coefficients
!< *******************************************************************
       SUBROUTINE bhdist
       implicit real(8) (a-h,o-z)
       common/coef/a(30,30,30),xa,xb,xc
       common/ind/lmax,mmax,nmax
       common/indin/lmaxi,mmaxi,nmaxxi
       common/hcgrms/xcdg,ycdg,zcdg,ect,eps
!       character iitime*30
!      hermite degrees
       lmax=lmaxi
       mmax=mmaxi
       nmax=nmaxxi
       ect=4.
       call pintfast
       call hcoef
       return
       end
!> *******************************************************************
!! SUBROUTINE trms(isucc)
!! called by HERSC
!! storage  of the variables depending only of the rms sizes
!! lmax,mmax,nmax : maximum of the subscripts: l,m,n
!!                  for the significants Almn
!! isucc:order of succession of the integrals in table 1-b
!!     isucc=1: order of succesion x-->y-->z
!!     isucc=2: order of succesion y-->z-->x
!!     isucc=3: order of succesion z-->x-->y
!< *******************************************************************
       SUBROUTINE trms(isucc)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/coef/a(30,30,30),xa,xb,xc
       common/ind/lmax,mmax,nmax
!  lmax,mmax,nmax from zero
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/randu/ck(15),kmax
!  minimum of the rms sizes xa,xb,xc
       rmin=xa
       fprec=epsilon(rmin)
       if(rmin.gt.xb) rmin=xb
       if(rmin.gt.xc) rmin=xc
!  order of the succession of the integrals
!       if(rmin.eq.xc) isucc=3
!       if(rmin.eq.xb) isucc=2
!       if(rmin.eq.xa) isucc=1
       if(abs(rmin-xc).le.fprec) isucc=3
       if(abs(rmin-xb).le.fprec) isucc=2
       if(abs(rmin-xa).le.fprec) isucc=1
!   maximum of lmax,mmax,nmax
       maxi=lmax
       if(maxi.lt.mmax) maxi=mmax
       if(maxi.lt.nmax) maxi=nmax
       maxt=2*(maxi+1)+3
       x3=0.
       x2=0.
       x1=0.
!  order of succession x->y->z
       if(isucc.eq.1) then
         x3=xa
         x2=xb
         x1=xc
       endif
!  order of succession y->z->x
       if(isucc.eq.2) then
        x3=xb
        x2=xc
        x1=xa
       endif
!  order of succession z->x->y
       if(isucc.eq.3) then
         x3=xc
         x2=xa
         x1=xb
       endif
!   array rms(j,i) Powers of the rms sizes  j=1,2,3, the value i is the power
       rms(3,1)=1.
       rms(2,1)=1.
       rms(1,1)=1.
       do i=2,maxt
         rms(3,i)=rms(3,i-1)*x3
         rms(2,i)=rms(2,i-1)*x2
         rms(1,i)=rms(1,i-1)*x1
       enddo
       j1=kmax/2
       i1m=(lmax+1)/2
       i2m=(mmax+1)/2
       i3m=(nmax+1)/2
       im=i1m+i2m+i3m+j1+4
       if(im.ge.40) then
         write(16,*) ' overlap the array blam with im= ',im
         stop
       endif
       do i=1,igaus
         blam(i,1)=(rms(1,3)*co(i,3)+rms(2,3)*sn(i,3))/rms(3,3)
         do ii=2,im
           blam(i,ii)=blam(i,ii-1)*blam(i,1)
         enddo
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE uvrms
!! called by HERSC
!! storage of the variables depending only of the coordinate s3
!< *******************************************************************
       SUBROUTINE uvrms
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *              akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/ind/lmax,mmax,nmax
       common/indttal/lmnt
       common/randu/ck(15),kmax
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       s32=s3*s3
       s22=s2*s2
       s12=s1*s1
       exs3=exp(-s32/2.)
       exs2=exp(-s22/2.)
       exs1=exp(-s12/2.)
       as3=abs(s3)
       sgns3=1.
       if(s3.lt.0.) sgns3=-1.
       as31=as3*s1
       as32=as3*s2
       s1rms=s1*rms(1,2)
       s2rms=s2*rms(2,2)
!  power of as3, used in the functions spii,......
       s3pw(1)=1.
       do i=2,kmax
         s3pw(i)=s3pw(i-1)*as3
       enddo
!    memory array hsint(ig,arg,indice) for functions sipp,...
       do ig=1,igaus
         wgpi=wg(ig)*pi/2.
         sqblam(ig)=sqrt(blam(ig,1))
         xlblam=sqblam(ig)*rms(3,2)
         do iarg=1,2
           arghm1=s1rms*co(ig,2)/xlblam
           arghm2=s2rms*sn(ig,2)/xlblam
           if(iarg.eq.1) then
             arg=arghm1+arghm2
             earg=exp(-arg*arg/2.)
           endif
           if(iarg.eq.2) then
             arg=arghm1-arghm2
             earg=exp(-arg*arg/2.)
           endif
           hsint(ig,iarg,1)=1.*earg*wgpi
           hsint(ig,iarg,2)=arg*earg*wgpi
           do inhs=3,lmnt
             hsint(ig,iarg,inhs)=arg*hsint(ig,iarg,inhs-1)
     *                     -float(inhs-2)*hsint(ig,iarg,inhs-2)
           enddo
         enddo
       enddo
       r13=rms(1,2)/rms(3,2)
       r23=rms(2,2)/rms(3,2)
       do j=1,igaus
         do i=1,igaus
           aeps1=ragp(i,3)*(blam(j,1)-1.)/2.
           aeps1=s32*(aeps1+ragp(i,2))
           aeps2=ragp(i,3)*blam(j,1)/2.
           aeps2=aeps2*s32
           if(aeps1.gt.300.) aeps1=300.
           if(aeps2.gt.300.) aeps2=300.           
           akc1=ragp(i,2)*r13*co(j,2)*as31
           akc2=ragp(i,2)*r23*sn(j,2)*as32
           aks1=ragp(i,2)*r13*co(j,2)*as31
           aks2=ragp(i,2)*r23*sn(j,2)*as32
           epsi1(i,j)=exp(-aeps1)*wg(i)
           epsi2(i,j)=exp(-aeps2)*wg(i)
           akpcc(i,j)=cos(akc1)*cos(akc2)
           akpcs(i,j)=cos(akc1)*sin(akc2)
           akpsc(i,j)=sin(akc1)*cos(akc2)
           akpss(i,j)=sin(akc1)*sin(akc2)
         enddo
       enddo
!    Hermite functions
       hs1(1)=exs1
       hs2(1)=exs2
       hs3(1)=exs3
       hs1(2)=s1*exs1
       hs2(2)=s2*exs2
       hs3(2)=s3*exs3
       do ihe=3,lmnt
         hs1(ihe)=s1*hs1(ihe-1)-float(ihe-2)*hs1(ihe-2)
         hs2(ihe)=s2*hs2(ihe-1)-float(ihe-2)*hs2(ihe-2)
         hs3(ihe)=s3*hs3(ihe-1)-float(ihe-2)*hs3(ihe-2)
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE fielde(lc,mc,nc,isucc)
!! beam self-fields computation called by HERSC
!! look for the parity of the currents lc,mc and nc
!! compute the corresponding field components
!!     isucc=1: a<b,c
!!     isucc=2: b<a,c
!!     isucc=3: c<a,b
!! x,y,z are the scaling coordinates: x/a,y/b,z/c
!! The corresponding analytical equations are in the number of the
!! tables. The table number in 'comments' refers to the corresponding
!! analytical equations
!< *******************************************************************
       SUBROUTINE fielde(lc,mc,nc,isucc)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/field/ex,ey,ez
       common/randu/ck(15),kmax
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),sgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1),pw3as3=as3**(2*it3))
       common/sgpth/mksgi,mksgp
       common/ftth/makti,maktp
       common/fsth/maksi,maksp
       logical maksi,maksp
       logical makti,maktp
       logical mksgi,mksgp
       logical lpl,lpm,lpn
!         look for the parity of the currents lc,mc,nc
       lpl=.false.
       lpm=.false.
       lpn=.false.
       makti=.false.
       maktp=.false.
       maksi=.false.
       maksp=.false.
       mksgi=.false.
       mksgp=.false.
       xlc=lc
       tl=xlc-2.*int(xlc/2.+0.0001)
       fprec=epsilon(tl)
!       if(tl.eq.0.)lpl=.true.
       if(abs(tl).le.fprec)lpl=.true.
       xmc=mc
       tm=xmc-2.*int(xmc/2.+0.0001)
!       if(tm.eq.0.)lpm=.true.
       if(abs(tm).le.fprec)lpm=.true.
       xnc=nc
       tn=xnc-2.*int(xnc/2.+0.0001)
!       if(tn.eq.0.)lpn=.true.
       if(abs(tn).le.fprec)lpn=.true.
       if(lpl.and.lpm.and.lpn) itpar=1
       if(lpl.and.lpm.and..not.lpn) itpar=2
       if(lpl.and..not.lpm.and.lpn) itpar=3
       if(lpl.and..not.lpm.and..not.lpn) itpar=4
       if(.not.lpl.and.lpm.and.lpn) itpar=5
       if(.not.lpl.and.lpm.and..not.lpn) itpar=6
       if(.not.lpl.and..not.lpm.and.lpn) itpar=7
       if(.not.lpl.and..not.lpm.and..not.lpn) itpar=8
!
!  values of the variables it1,it2,it3 in relation with lc,mc,nc
!  the initial values of these lc,mc,nc is zero
       if (isucc.eq.1) then
!  a<b,c
         if(itpar.eq.1) then
!       E E E and  a<b,c:
!                  table 67-a: Ex=E(2t3+1,2t2,2t1)
!                              Ey=E(2t3,2t2+1,2t1)
!                              Ez=E(2t3,2t2,2t1+1)
!        values of it1,it2,it3 in table 3-a
           it3=lc/2
           it2=mc/2
           it1=nc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!            it=2*(it1+it2+it3)+1
             it=lc+mc+nc+1
             pwas3=as3**it
           endif
           ex=eipp(it1,it2,it3)
           ey=epip(it1,it2,it3)
           ez=eppi(it1,it2,it3)
           return
         endif
         if(itpar.eq.2) then
!       E E I and  a<b,c
!                  table 67-g: Ex=E(2t3+1,2t2,2t1+1)
!                              Ey=E(2t3,2t2+1,2t1+1)
!                              Ez=E(2t3,2t2,2t1)
!        values of it1,it2,it3 in table 3-g
!        x-direction and y-direction
           it3=lc/2
           it2=mc/2
           it1=(nc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!     it=2*(it1+it2+it3)+1
             it=lc+mc+nc
             pwas3=as3**it
           endif
           ex=eipi(it1,it2,it3)
           ey=epii(it1,it2,it3)
!     z-direction
           it1=(nc+1)/2
!           if(s3.ne.0.)pwas3=pwas3*s32
           if(abs(s3).gt.fprec)pwas3=pwas3*s32
!     it=2*(it1+it2+it3)+1
           ez=eppp(it1,it2,it3)
           return
         endif
         if(itpar.eq.3) then
!       E I E and  a<b,c
!               in table 67-h: Ex=E(2t3+1,2t2+1,2t1)
!                              Ey=E(2t3,2t2,2t1)
!                              Ez=E(2t3,2t2+1,2t1+1)
!        values of it1,it2,it3 in table 3-h
!        x-direction
           it3=lc/2
           it2=(mc-1)/2
           it1=nc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!     it=2*(it1+it2+it3)+1
             it=lc+mc+nc
             apwas3=as3**it
             pwas3=apwas3
           endif
           ex=eiip(it1,it2,it3)
!        y-direction
           it3=lc/2
           it2=(mc+1)/2
           it1=nc/2
!       it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=pwas3*s32
           if(abs(s3).gt.fprec)pwas3=pwas3*s32           
           ey=eppp(it1,it2,it3)
!        z-direction
           it3=lc/2
           it2=(mc-1)/2
           it1=nc/2
!           if(s3.ne.0.)pwas3=apwas3
           if(abs(s3).gt.fprec)pwas3=apwas3           
!       it=2*(it1+it2+it3)+1
           ez=epii(it1,it2,it3)
           return
         endif
         if(itpar.eq.4) then
!       E I I and  a<b,c
!               in table 67-f: Ex=E(2t3+1,2t2+1,2t1+1)
!                              Ey=E(2t3,2t2,2t1+1)
!                              Ez=E(2t3,2t2+1,2t1)
!        values of it1,it2,it3 in table 3-f
!        x-direction
           it3=lc/2
           it2=(mc-1)/2
           it1=(nc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
             it=lc+mc+nc-1
             pwas3=as3**it
           endif
           ex=eiii(it1,it2,it3)
!        y-direction
           it3=lc/2
           it2=(mc+1)/2
           it1=(nc-1)/2
!         it=2*(it1+it2+it3)+1
!           if(s3.ne.0.)pwas3=pwas3*s32
           if(abs(s3).gt.fprec)pwas3=pwas3*s32           
           ey=eppi(it1,it2,it3)
!        z-direction
           it3=lc/2
           it2=(mc-1)/2
           it1=(nc+1)/2
           ez=epip(it1,it2,it3)
           return
         endif
         if(itpar.eq.5) then
!       I E E and  a<b,c
!               in table 67-c: Ex=E(2t3,2t2,2t1)
!                              Ey=E(2t3+1,2t2+1,2t1)
!                              Ez=E(2t3+1,2t2,2t1+1)
!        values of it1,it2,it3 in table 3-c
!        x-direction
           it3=(lc+1)/2
           it2=mc/2
           it1=nc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!       it=2*(it1+it2+it3)+1
             it=lc+mc+nc
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=eppp(it1,it2,it3)
!        y-direction
           it3=(lc-1)/2
           it2=mc/2
           it1=nc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!       it=2*(it1+it2+it3)+1
             pwas3=apwas3
             pw3as3=apwas3
           endif
           ey=eiip(it1,it2,it3)
!        z-direction
           it3=(lc-1)/2
           it2=mc/2
           it1=nc/2
           ez=eipi(it1,it2,it3)
           return
         endif
         if(itpar.eq.6) then
!       I E I and  a<b,c
!               in table 67-e: Ex=E(2t3,2t2,2t1+1)
!                              Ey=E(2t3+1,2t2+1,2t1+1)
!                              Ez=E(2t3+1,2t2,2t1)
!        values of it1,it2,it3 in table 3-e
!        x-direction
           it3=(lc+1)/2
           it2=mc/2
           it1=(nc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!      it=2*(it1+it2+it3)+1
             it=lc+mc+nc-1
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=eppi(it1,it2,it3)
!        y-direction
           it3=(lc-1)/2
           it2=mc/2
           it1=(nc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!             it=2*(it1+it2+it3)+1
             pwas3=apwas3
           endif
           ey=eiii(it1,it2,it3)
!        z-direction
           it3=(lc-1)/2
           it2=mc/2
           it1=(nc+1)/2
!      it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=pwas3*s32
           if(abs(s3).gt.fprec) pwas3=pwas3*s32
           ez=eipp(it1,it2,it3)
           return
         endif
         if(itpar.eq.7) then
!       I I E and  a<b,c
!               in table 67-d: Ex=E(2t3,2t2+1,2t1)
!                              Ey=E(2t3+1,2t2,2t1)
!                              Ez=E(2t3+1,2t2+1,2t1+1)
!        values of it1,it2,it3 in table 3-d
!        x-direction
           it3=(lc+1)/2
           it2=(mc-1)/2
           it1=nc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!      it=2*(it1+it2+it3)+1
             it=lc+mc+nc-1
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=epip(it1,it2,it3)
!        y-direction
           it3=(lc-1)/2
           it2=(mc+1)/2
           it1=nc/2
!             it=2*(it1+it2+it3)+1
           ey=eipp(it1,it2,it3)
!        z-direction
           it3=(lc-1)/2
           it2=(mc-1)/2
           it1=nc/2
!         it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=apwas3
           if(abs(s3).gt.fprec) pwas3=apwas3
           ez=eiii(it1,it2,it3)
           return
         endif
         if(itpar.eq.8) then
!       I I I and  a<b,c
!               in table 67-b: Ex=E(2t3,2t2+1,2t1+1)
!                              Ey=E(2t3+1,2t2,2t1+1)
!                              Ez=E(2t3+1,2t2+1,2t1)
!        values of it1,it2,it3 in table 3-b
!        x-direction
           it3=(lc+1)/2
           it2=(mc-1)/2
           it1=(nc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!        it=2*(it1+it2+it3)+1
             it=lc+mc+nc
             pwas3=as3**it
           endif
           ex=epii(it1,it2,it3)
!        y-direction
           it3=(lc-1)/2
           it2=(mc+1)/2
           it1=(nc-1)/2
!     it=2*(it1+it2+it3)+1
           ey=eipi(it1,it2,it3)
!        z-direction
           it3=(lc-1)/2
           it2=(mc-1)/2
           it1=(nc+1)/2
           ez=eiip(it1,it2,it3)
           return
         endif
!    endif of isucc=1----> a<b,c
       endif
       if (isucc.eq.2) then
!       b<a,c
         if(itpar.eq.1) then
!       E E E and  b<a,c
!                  table 67-a: Ex=E(2t3,2t2,2t1+1)
!                              Ey=E(2t3+1,2t2,2t1)
!                              Ez=E(2t3,2t2+1,2t1)
!        values of it1,it2,it3 in table 3-a
           it3=mc/2
           it2=nc/2
           it1=lc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!      it=2*(it1+it2+it3)+1
             it=mc+nc+lc+1
             pwas3=as3**it
           endif
           ex=eppi(it1,it2,it3)
           ey=eipp(it1,it2,it3)
           ez=epip(it1,it2,it3)
           return
         endif
         if(itpar.eq.2) then
!       E E I and  b<a,c
!                  table 67-h: Ex=E(2t3,2t2+1,2t1+1)
!                              Ey=E(2t3+1,2t2+1,2t1)
!                              Ez=E(2t3,2t2,2t1)
!        values of it1,it2,it3 in table 3-h
!        x-direction and y-direction
           it3=mc/2
           it2=(nc-1)/2
           it1=lc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!      it=2*(it1+it2+it3)+1
             it=mc+nc+lc
             pwas3=as3**it
           endif
           ex=epii(it1,it2,it3)
           ey=eiip(it1,it2,it3)
!        z-direction
           it2=(nc+1)/2
!     it=2*(it1+it2+it3)+1
!           if(s3.ne.0.)pwas3=pwas3*s32
           if(abs(s3).gt.fprec)pwas3=pwas3*s32                     
           ez=eppp(it1,it2,it3)
           return
         endif
         if(itpar.eq.3) then
!       E I E and  b<a,c
!               in table 67-c: Ex=E(2t3+1,2t2,2t1+1)
!                              Ey=E(2t3,2t2,2t1)
!                              Ez=E(2t3+1,2t2+1,2t1)
!        values of it1,it2,it3 in table 3-c
!        x-direction
           it3=(mc-1)/2
           it2=nc/2
           it1=lc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!     it=2*(it1+it2+it3)+1
             it=mc+nc+lc
             apwas3=as3**it
             pwas3= apwas3
           endif
           ex=eipi(it1,it2,it3)
!        y-direction
           it3=(mc+1)/2
           it2=nc/2
           it1=lc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!      it=2*(it1+it2+it3)+1
             pwas3=pwas3*s32
           endif
           ey=eppp(it1,it2,it3)
!        z-direction
           it3=(mc-1)/2
           it2=nc/2
           it1=lc/2
!           if(s3.ne.0.) pwas3= apwas3
           if(abs(s3).gt.fprec)pwas3=apwas3
           ez=eiip(it1,it2,it3)
           return
         endif
         if(itpar.eq.4) then
!       E I I and  b<a,c
!               in table 67-d: Ex=E(2t3+1,2t2+1,2t1+1)
!                              Ey=E(2t3,2t2+1,2t1)
!                              Ez=E(2t3+1,2t2,2t1)
!        values of it1,it2,it3 in table 3-d
!        x-direction
           it3=(mc-1)/2
           it2=(nc-1)/2
           it1=lc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!      it=2*(it1+it2+it3)+1
             it=mc+nc+lc-1
             pwas3=as3**it
           endif
           ex=eiii(it1,it2,it3)
!        y-direction
           it3=(mc+1)/2
           it2=(nc-1)/2
           it1=lc/2
!    it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
             pwas3=pwas3*s32
           endif
           ey=epip(it1,it2,it3)
!        z-direction
           it3=(mc-1)/2
           it2=(nc+1)/2
           it1=lc/2
!             it=2*(it1+it2+it3)+1
           ez=eipp(it1,it2,it3)
           return
         endif
         if(itpar.eq.5) then
!       I E E and  b<a,c
!               in table 67-g: Ex=E(2t3,2t2,2t1)
!                              Ey=E(2t3+1,2t2,2t1+1)
!                              Ez=E(2t3,2t2+1,2t1+1)
!        values of it1,it2,it3 in table 3-g
!        x-direction
           it3=mc/2
           it2=nc/2
           it1=(lc+1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!       it=2*(it1+it2+it3)+1
             it=mc+nc+lc
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=eppp(it1,it2,it3)
!        y-direction
           it3=mc/2
           it2=nc/2
           it1=(lc-1)/2
!    it=2*(it1+it2+it3)+1
!           if(s3.ne.0.)pwas3=apwas3
           if(abs(s3).gt.fprec)pwas3=apwas3
           ey=eipi(it1,it2,it3)
!        z-direction
           it3=mc/2
           it2=nc/2
           it1=(lc-1)/2
           ez=epii(it1,it2,it3)
           return
         endif
         if(itpar.eq.6) then
!       I E I and  b<a,c
!               in table 67-f: Ex=E(2t3,2t2+1,2t1)
!                              Ey=E(2t3+1,2t2+1,2t1+1)
!                              Ez=E(2t3,2t2,2t1+1)
!        values of it1,it2,it3 in table 3-f
!        x-direction
           it3=mc/2
           it2=(nc-1)/2
           it1=(lc+1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
             it=mc+nc+lc-1
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=epip(it1,it2,it3)
!        y-direction
           it3=mc/2
           it2=(nc-1)/2
           it1=(lc-1)/2
!      it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=apwas3
           if(abs(s3).gt.fprec)pwas3=apwas3
           ey=eiii(it1,it2,it3)
!        z-direction
           it3=mc/2
           it2=(nc+1)/2
           it1=(lc-1)/2
!      it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=apwas3*s32
           if(abs(s3).gt.fprec) pwas3=apwas3*s32
           ez=eppi(it1,it2,it3)
           return
         endif
         if(itpar.eq.7) then
!       I I E and  b<a,c
!               in table 66-e: Ex=E(2t3+1,2t2,2t1)
!                              Ey=E(2t3,2t2,2t1+1)
!                              Ez=E(2t3+1,2t2+1,2t1+1)
!        values of it1,it2,it3 in table 3-e
!        x-direction
           it3=(mc-1)/2
           it2=nc/2
           it1=(lc+1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
             it=mc+nc+lc-1
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=eipp(it1,it2,it3)
!        y-direction
           it3=(mc+1)/2
           it2=nc/2
           it1=(lc-1)/2
!             it=2*(it1+it2+it3)+1
           ey=eppi(it1,it2,it3)
!        z-direction
           it3=(mc-1)/2
           it2=nc/2
           it1=(lc-1)/2
!           if(s3.ne.0.) pwas3=apwas3
           if(abs(s3).gt.fprec)pwas3=apwas3
!       it=2*(it1+it2+it3)+1
           ez=eiii(it1,it2,it3)
          return
         endif
         if(itpar.eq.8) then
!       I I I and  b<a,c
!               in table 67-b: Ex=E(2t3+1,2t2+1,2t1)
!                              Ey=E(2t3,2t2+1,2t1+1)
!                              Ez=E(2t3+1,2t2,2t1+1)
!        values of it1,it2,it3 in table 3-b
!        x-direction
           it3=(mc-1)/2
           it2=(nc-1)/2
           it1=(lc+1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
             it=mc+nc+lc
             pwas3=as3**it
           endif
           ex=eiip(it1,it2,it3)
!        y-direction
           it3=(mc+1)/2
           it2=(nc-1)/2
           it1=(lc-1)/2
!     it=2*(it1+it2+it3)+1
           ey=epii(it1,it2,it3)
!        z-direction
           it3=(mc-1)/2
           it2=(nc+1)/2
           it1=(lc-1)/2
!             it=2*(it1+it2+it3)+1
           ez=eipi(it1,it2,it3)
           return
         endif
!    endif of isucc=2----> b<a,c
       endif
       if (isucc.eq.3) then
!       c<a,b
         if(itpar.eq.1) then
!       E E E and  c<a,b
!                  table 67-a: Ex=E(2t3,2t2+1,2t1)
!                              Ey=E(2t3,2t2,2t1+1)
!                              Ez=E(2t3+1,2t2,2t1)
!        values of it1,it2,it3 in table 3-a
           it3=nc/2
           it2=lc/2
           it1=mc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
             it=nc+lc+mc+1
             pwas3=as3**it
           endif
           ex=epip(it1,it2,it3)
           ey=eppi(it1,it2,it3)
           ez=eipp(it1,it2,it3)
           return
         endif
         if(itpar.eq.2) then
!       E E I and  c<a,b
!                  table 67-c: Ex=E(2t3+1,2t2+1,2t1)
!                              Ey=E(2t3+1,2t2,2t1+1)
!                              Ez=E(2t3,2t2,2t1)
!        values of it1,it2,it3 in table 3-c
!        x-direction and y-direction
           it3=(nc-1)/2
           it2=lc/2
           it1=mc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!     it=2*(it1+it2+it3)+1
             it=nc+lc+mc
             pwas3=as3**it
           endif
           ex=eiip(it1,it2,it3)
           ey=eipi(it1,it2,it3)
!        z-direction
           it3=(nc+1)/2
!           if(s3.ne.0.) pwas3=pwas3*s32
           if(abs(s3).gt.fprec) pwas3=pwas3*s32
!       it=2*(it1+it2+it3)+1
           ez=eppp(it1,it2,it3)
           return
         endif
         if(itpar.eq.3) then
!       E I E and  c<a,b
!               in table 67-g: Ex=E(2t3,2t2+1,2t1+1)
!                              Ey=E(2t3,2t2,2t1)
!                              Ez=E(2t3+1,2t2,2t1+1)
!        values of it1,it2,it3 in table 3-g
!        x-direction
           it3=nc/2
           it2=lc/2
           it1=(mc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!     it=2*(it1+it2+it3)+1
             it=nc+lc+mc
             apwas3=as3**it
             pwas3=apwas3
           endif
           ex=epii(it1,it2,it3)
!        y-direction
           it3=nc/2
           it2=lc/2
           it1=(mc+1)/2
!     it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=pwas3*s32
           if(abs(s3).gt.fprec) pwas3=pwas3*s32           
           ey=eppp(it1,it2,it3)
!        z-direction
           it3=nc/2
           it2=lc/2
           it1=(mc-1)/2
!           if(s3.ne.0.) pwas3=apwas3
           if(abs(s3).gt.fprec) pwas3=apwas3
           ez=eipi(it1,it2,it3)
           return
         endif
         if(itpar.eq.4) then
!       E I I and  c<a,b
!               in table 67-e: Ex=E(2t3+1,2t2+1,2t1+1)
!                              Ey=E(2t3+1,2t2,2t1)
!                              Ez=E(2t3,2t2,2t1+1)
!        values of it1,it2,it3 in table 3-e
!        x-direction
           it3=(nc-1)/2
           it2=lc/2
           it1=(mc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!   it=2*(it1+it2+it3)+1
             it=nc+lc+mc-1
             pwas3=as3**it
           endif
           ex=eiii(it1,it2,it3)
!        y-direction
           it3=(nc-1)/2
           it2=lc/2
           it1=(mc+1)/2
!      it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=pwas3*s32
           if(abs(s3).gt.fprec) pwas3=pwas3*s32
           ey=eipp(it1,it2,it3)
!        z-direction
           it3=(nc+1)/2
           it2=lc/2
           it1=(mc-1)/2
!        it=2*(it1+it2+it3)+1
           ez=eppi(it1,it2,it3)
           return
         endif
         if(itpar.eq.5) then
!       I E E and  c<a,b
!               in table 67-h: Ex=E(2t3,2t2,2t1)
!                              Ey=E(2t3,2t2+1,2t1+1)
!                              Ez=E(2t3+1,2t2+1,2t1)
!        values of it1,it2,it3 in table 3-h
!        x-direction
           it3=nc/2
           it2=(lc+1)/2
           it1=mc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!        it=2*(it1+it2+it3)+1
             it=nc+lc+mc
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=eppp(it1,it2,it3)
!        y-direction
           it3=nc/2
           it2=(lc-1)/2
           it1=mc/2
!         it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=apwas3
           if(abs(s3).gt.fprec) pwas3=apwas3
           ey=epii(it1,it2,it3)
!        z-direction
           it3=nc/2
           it2=(lc-1)/2
           it1=mc/2
           ez=eiip(it1,it2,it3)
           return
         endif
         if(itpar.eq.6) then
!       I E I and  c<a,b
!               in table 67-d: Ex=E(2t3+1,2t2,2t1)
!                              Ey=E(2t3+1,2t2+1,2t1+1)
!                              Ez=E(2t3,2t2+1,2t1)
!        values of it1,it2,it3 in table 3-d
!        x-direction
           it3=(nc-1)/2
           it2=(lc+1)/2
           it1=mc/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!        it=2*(it1+it2+it3)+1
             it=nc+lc+mc-1
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=eipp(it1,it2,it3)
!        y-direction
           it3=(nc-1)/2
           it2=(lc-1)/2
           it1=mc/2
!       it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=apwas3
           if(abs(s3).gt.fprec) pwas3=apwas3           
           ey=eiii(it1,it2,it3)
!        z-direction
           it3=(nc+1)/2
           it2=(lc-1)/2
           it1=mc/2
!       it=2*(it1+it2+it3)+1
!           if(s3.ne.0.)  pwas3=pwas3*s32
           if(abs(s3).gt.fprec)  pwas3=pwas3*s32
           ez=epip(it1,it2,it3)
           return
         endif
         if(itpar.eq.7) then
!       I I E and  c<a,b
!               in table 67-f: Ex=E(2t3,2t2,2t1+1)
!                              Ey=E(2t3,2t2+1,2t1)
!                              Ez=E(2t3+1,2t2+1,2t1+1)
!        values of it1,it2,it3 in table 3-f
!        x-direction
           it3=nc/2
           it2=(lc+1)/2
           it1=(mc-1)/2
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
!          it=2*(it1+it2+it3)+1
             it=nc+lc+mc-1
             apwas3=as3**it
             pwas3=apwas3*s32
           endif
           ex=eppi(it1,it2,it3)
!        y-direction
           it3=nc/2
           it2=(lc-1)/2
           it1=(mc+1)/2
!       it=2*(it1+it2+it3)+1
           ey=epip(it1,it2,it3)
!        z-direction
           it3=nc/2
           it2=(lc-1)/2
           it1=(mc-1)/2
!      it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) pwas3=apwas3
           if(abs(s3).gt.fprec) pwas3=apwas3           
           ez=eiii(it1,it2,it3)
           return
         endif
         if(itpar.eq.8) then
!       I I I and  c<a,b
!               in table 67-b: Ex=E(2t3+1,2t2,2t1+1)
!                              Ey=E(2t3+1,2t2+1,2t1)
!                              Ez=E(2t3,2t2+1,2t1+1)
!        values of it1,it2,it3 in table 3-b
!        x-direction
         it3=(nc-1)/2
           it2=(lc+1)/2
           it1=(mc-1)/2
!        it=2*(it1+it2+it3)+1
!           if(s3.ne.0.) then
           if(abs(s3).gt.fprec) then
             it=nc+lc+mc
             pwas3=as3**it
           endif
           ex=eipi(it1,it2,it3)
!        y-direction
           it3=(nc-1)/2
           it2=(lc-1)/2
           it1=(mc+1)/2
!        it=2*(it1+it2+it3)+1
           ey=eiip(it1,it2,it3)
!        z-direction
           it3=(nc+1)/2
           it2=(lc-1)/2
           it1=(mc-1)/2
!        it=2*(it1+it2+it3)+1
           ez=eppi(it1,it2,it3)
           return
         endif
!    endif of isucc=3----> c<a,b
       endif
       end
!> *******************************************************************
!! FUNCTION eppp(it1,it2,it3)
!! E(2it3,2it2,2it1)   table 77-a-1
!< *******************************************************************
       FUNCTION eppp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/randu/ck(15),kmax
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),isgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1)
       eppp=0.
       isgnw=4*(it2+it1)+5*it3
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       eppp=wsng*pi2*exs3*rms(3,3)
       eppp=eppp*(tppp(it1,it2,it3)+sppp(it1,it2,it3))
       eppp=eppp-8.*wsng*rms(3,3)*sqpi*sgppp(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3
         ipar=isgn1-2*(isgn1/2)
         if(ipar.eq.0) then
           sgn1=1.
           sgn2=-1
         endif
         ipt12=2*it1+1
         ipt22=2*it2+1
         ipt212=2*(it1+it2)
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas3*rint*uppp(it1,it2,it3)
         scum=0.
         kj=1
         pcas3=pwas3
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*vppp(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3
         eppp=eppp+e1+e2
       endif
       return
       end
!> *******************************************************************
!! FUNCTION epip(it1,it2,it3)
!! E(2it3,2it2+1,2it1)  table 77-a-2
!< *******************************************************************
       FUNCTION epip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/randu/ck(15),kmax
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),isgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1)
       epip=0.
       isgnw=4*(it2+it1)+5*it3+2
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       epip=wsng*pi2*exs3*rms(3,3)
       epip=epip*(tpip(it1,it2,it3)+spip(it1,it2,it3))
       epip=epip-8.*wsng*rms(3,3)*sqpi*sgpip(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas31=pwas3*as3
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3+2
         ipar=isgn1-2*(isgn1/2)
         if(ipar.eq.0) then
           sgn1=1.
           sgn2=-1.
         endif
         ipt12=2*it1+1
         ipt22=2*it2+2
         ipt212=2*(it1+it2)+1
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas31*rint*upip(it1,it2,it3)
         scum=0.
         kj=1
         pcas3=pwas31
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*vpip(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3
         epip=epip+(e1+e2)
       endif
       return
       end
!> *******************************************************************
!! FUNCTION eppi(it1,it2,it3)
!! E(2it3,2it2,2it1+1) table 77-a-2
!< *******************************************************************
       FUNCTION eppi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/randu/ck(15),kmax
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),isgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1),pw3as3=as3**(2*it3)
       eppi=0.
       isgnw=4*(it2+it1)+5*it3+2
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       eppi=wsng*pi2*exs3*rms(3,3)
       eppi=eppi*(tppi(it1,it2,it3)+sppi(it1,it2,it3))
       eppi=eppi-8.*wsng*rms(3,3)*sqpi*sgppi(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas31=pwas3*as3
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3+2
         xsgn1=isgn1
         pari=xsgn1-2.*int(xsgn1/2.+0.0001)
!         if(pari.eq.0.) then
         if(abs(pari).le.fprec) then
           sgn1=1.
           sgn2=-1.
         endif
         ipt12=2*it1+2
         ipt22=2*it2+1
         ipt212=2*(it1+it2)+1
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas31*rint*uppi(it1,it2,it3)
         scum=0.
         kj=1
         pcas3=pwas31
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*vppi(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3
         eppi=eppi+(e1+e2)
       endif
       return
       end
!> *******************************************************************
!! FUNCTION epii(it1,it2,it3)
!! E(2*it3,2*it2+1,2*it1+1) table 77-a-1
!< *******************************************************************
       FUNCTION epii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/randu/ck(15),kmax
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),isgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1),pw3as3=as3**(2*it3)
       epii=0.
       isgnw=4*(it2+it1)+5*it3+4
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       epii=wsng*pi2*exs3*rms(3,3)
       epii=epii*(tpii(it1,it2,it3)+spii(it1,it2,it3))
       epii=epii-8.*wsng*rms(3,3)*sqpi*sgpii(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas31=pwas3*s32
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3+4
         ipar=isgn1-2*(isgn1/2)
         if(ipar.eq.0) then
           sgn1=1.
           sgn2=-1
         endif
         ipt12=2*it1+2
         ipt22=2*it2+2
         ipt212=2*(it1+it2+1)
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas31*rint*upii(it1,it2,it3)
         scum=0.
         kj=1
         pcas3=pwas31
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*vpii(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3
         epii=epii+e1+e2
       endif
       return
       end
!> *******************************************************************
!! FUNCTION eipp(it1,it2,it3)
!! E(2it3+1,2it2,2it1) table 77-b-2
!< *******************************************************************
       FUNCTION eipp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/randu/ck(15),kmax
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),sgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1),pw3as3=as3**(2*it3)
       eipp=0.
       isgnw=4*(it2+it1)+5*it3+3
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       eipp=wsng*sgns3*pi2*exs3*rms(3,3)
       eipp=eipp*(tipp(it1,it2,it3)+sipp(it1,it2,it3))
       eipp=eipp+8.*wsng*rms(3,3)*sqpi*sgipp(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas31=pwas3*as3
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3+3
         ipar=isgn1-2*(isgn1/2)
         if(ipar.eq.0) then
           sgn1=1.
           sgn2=-1
         endif
         ipt12=2*it1+1
         ipt22=2*it2+1
         ipt212=2*(it1+it2)
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas31*rint*uipp(it1,it2,it3)*sgns3
         scum=0.
         kj=1
         pcas3=pwas31
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*vipp(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3*sgns3
         eipp=eipp-(e1+e2)
       endif
       return
       end
!> *******************************************************************
!! FUNCTION eiip(it1,it2,it3)
!! E(2it3+1,2it2+1,2it1)  table 77-b-1
!< *******************************************************************
       FUNCTION eiip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/randu/ck(15),kmax
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),sgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1)
       eiip=0.
       isgnw=4*(it2+it1)+5*it3+5
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       eiip=wsng*sgns3*pi2*exs3*rms(3,3)
       eiip=eiip*(tiip(it1,it2,it3)+siip(it1,it2,it3))
       eiip=eiip+8.*wsng*rms(3,3)*sqpi*sgiip(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas31=pwas3*s32
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3+5
         ipar=isgn1-2*(isgn1/2)
         if(ipar.eq.0) then
           sgn1=1.
           sgn2=-1
         endif
         ipt12=2*it1+1
         ipt22=2*it2+2
         ipt212=2*(it1+it2)+1
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas31*rint*uiip(it1,it2,it3)*sgns3
         scum=0.
         kj=1
         pcas3=pwas31
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*viip(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3*sgns3
         eiip=eiip-(e1+e2)
       endif
       return
       end
!> *******************************************************************
!! FUNCTION eipi(it1,it2,it3)
!! E(2*it3+1,2*it2,2*it1+1)  table 77-b-1
!< *******************************************************************
       FUNCTION eipi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/randu/ck(15),kmax
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),sgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1)
       eipi=0.
       isgnw=4*(it2+it1)+5*it3+5
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       eipi=wsng*sgns3*pi2*exs3*rms(3,3)
       eipi=eipi*(tipi(it1,it2,it3)+sipi(it1,it2,it3))
       eipi=eipi+8.*wsng*rms(3,3)*sqpi*sgipi(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas31=pwas3*s32
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3+5
         ipar=isgn1-2*(isgn1/2)
         if(ipar.eq.0) then
           sgn1=1.
           sgn2=-1
         endif
         ipt12=2*it1+2
         ipt22=2*it2+1
         ipt212=2*(it1+it2)+1
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas31*rint*uipi(it1,it2,it3)*sgns3
         scum=0.
         kj=1
         pcas3=pwas31
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*vipi(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3*sgns3
         eipi=eipi-(e1+e2)
       endif
       return
       end
!> *******************************************************************
!! FUNCTION eiii(it1,it2,it3)
!! E(2*it3+1,2*it2+1,2*it1+1) table 77-b-2
!< *******************************************************************
       FUNCTION eiii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/partcl/x,y,z
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/randu/ck(15),kmax
!           pi2=pi*pi, sqpi=(pi/2)**3/2
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),sgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1),pw3as3=as3**(2*it3)
       eiii=0.
       isgnw=4*(it2+it1)+5*it3+5
       ipar=isgnw-2*(isgnw/2)
       wsng=-1.
       if(ipar.eq.0)wsng=1.
       eiii=wsng*sgns3*pi2*exs3*rms(3,3)
       eiii=eiii*(tiii(it1,it2,it3)+siii(it1,it2,it3))
       eiii=eiii+8.*wsng*rms(3,3)*sqpi*sgiii(it1,it2,it3)
       fprec=epsilon(s3)
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas31=pwas3*s32*as3
         sgn1=-1.
         sgn2=1.
         isgn1=3*(it1+it2)+4*it3+5
         ipar=isgn1-2*(isgn1/2)
         if(ipar.eq.0) then
           sgn1=1.
           sgn2=-1
         endif
         ipt12=2*it1+2
         ipt22=2*it2+2
         ipt212=2*(it1+it2)+2
         rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
         e1=2.*sgn1*pi2*pwas31*rint*uiii(it1,it2,it3)*sgns3
         scum=0.
         kj=1
         pcas3=pwas31
         do k=1,kmax,2
           scum=scum+ck(k)*pcas3*viii(kj)
           kj=kj+1
           pcas3=pcas3*s32
         enddo
         e2=scum*sgn2*2.*pi2*rint*exs3*sgns3
         eiii=eiii-(e1+e2)
       endif
       return
       end
!> *******************************************************************
!! FUNCTION tipp(it1,it2,it3)
!! Part of W**(2t3+1,2t2,2t1)  table 61-b
!! with T(2t3+1,2t2,2t1,j1)    table 41
!< *******************************************************************
       FUNCTION tipp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tipp=0.
       if(.not.makti) then
         makti=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           xsj1=1.
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
!   term T(2t3+1,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
         do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
               mm=mm+1
             enddo
!      s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2i(kk,jj1)=2.*fpar(km1,2*jm1)*stoc
             tt1=tt1+tt*stc2i(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tipp=tt1*ck(k)+tipp
           kk=kk+1
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
!   term T(2t3+1,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
               mm1=mm1+1
             enddo
             tt1=tt1+tt*stc2i(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tipp=tt1*ck(k)+tipp
           kk=kk+1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION tiip(it1,it2,it3)
!! part of W**(2t3+1,2t2+1,2t1)  table 61-b
!! with  T(2t3+1,2t2+1,2t1,j1)   table 41
!< *******************************************************************
       FUNCTION tiip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tiip=0.
       if(.not.makti) then
         makti=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           xsj1=1.
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
               mm=mm+1
             enddo
!      s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2i(kk,jj1)=2.*fpar(km1,2*jm1)*stoc
             tt1=tt1+tt*stc2i(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tiip=tt1*ck(k)+tiip
           kk=kk+1
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
!   term T(2t3+1,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
               mm=mm+1
             enddo
             tt1=tt1+tt*stc2i(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tiip=tt1*ck(k)+tiip
           kk=kk+1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION tipi(it1,it2,it3)
!! part of W**(2t3+1,2t2,2t1+1) in table 61-b
!! with T(2t3+1,2t2,2t1+1,j1)   in table 41
!< *******************************************************************
       FUNCTION tipi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tipi=0.
       if(.not.makti) then
         makti=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           xsj1=1.
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
!   term T(2t3+1,2t2+1,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
               mm=mm+1
             enddo
!      s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2i(kk,jj1)=2.*fpar(km1,2*jm1)*stoc
             tt1=tt1+tt*stc2i(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tipi=tt1*ck(k)+tipi
           kk=kk+1
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
!   term T(2t3+1,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
               mm=mm+1
             enddo
             tt1=tt1+tt*stc2i(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tipi=tt1*ck(k)+tipi
           kk=kk+1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION tiii(it1,it2,it3)
!! part of W**(2t3+1,2t2+1,2t1+1) in table 61-b
!! with T(2t3+1,2t2+1,2t1+1,j1)   in table 41
!< *******************************************************************
       FUNCTION tiii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tiii=0.
       if(.not.makti) then
         makti=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           xsj1=1.
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
!   term T(2t3+1,2t2+1,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+2)
               mm=mm+1
             enddo
!      s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2i(kk,jj1)=2.*fpar(km1,2*jm1)*stoc
             tt1=tt1+tt*stc2i(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tiii=tt1*ck(k)+tiii
           kk=kk+1
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1
!   term T(2t3+1,2t2+1,2t1+1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+2)
               mm1=mm1+1
             enddo
             tt1=tt1+tt*stc2i(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           tiii=tt1*ck(k)+tiii
           kk=kk+1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION tppp(it1,it2,it3)
!! part of W**(2t3,2t2,2t1) in table 61-a
!! with  T(2t3,2t2,2t1,j1)  in table 41
!< *******************************************************************
       FUNCTION tppp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tppp=0.
       if(.not.maktp) then
         maktp=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           xsj1=1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
               mm=mm+1
             enddo
!    s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2p(kk,jj1)=2.*fpar(km1,2*jm1+1)*stoc
             tt1=tt1+tt*stc2p(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tppp=tt1*ck(k)+tppp
             kk=kk+1
           endif
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
               mm=mm+1
             enddo
             tt1=tt1+tt*stc2p(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tppp=tt1*ck(k)+tppp
             kk=kk+1
           endif
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION tpip(it1,it2,it3)
!! the part of W**(2t3,2t2,2t1+1) in table 61-a
!! with T(2t3,2t2,2t1+1,j1)       in table 41
!< *******************************************************************
       FUNCTION tpip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tpip=0.
       if(.not.maktp) then
         maktp=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           xsj1=1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
               mm=mm+1
             enddo
!    s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2p(kk,jj1)=2.*fpar(km1,2*jm1+1)*stoc
             tt1=tt1+tt*stc2p(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tpip=tt1*ck(k)+tpip
             kk=kk+1
           endif
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
               mm=mm+1
             enddo
             tt1=tt1+tt*stc2p(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tpip=tt1*ck(k)+tpip
             kk=kk+1
           endif
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION tppi(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1) in table 61-a
!! with T(2t3,2t2,2t1+1,j1)   in table 41
!< *******************************************************************
       FUNCTION tppi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tppi=0.
       if(.not.maktp) then
         maktp=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           xsj1=1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
               mm=mm+1
             enddo
!    s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2p(kk,jj1)=2.*fpar(km1,2*jm1+1)*stoc
             tt1=tt1+tt*stc2p(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tppi=tt1*ck(k)+tppi
             kk=kk+1
           endif
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
               mm=mm+1
             enddo
             tt1=tt1+tt*stc2p(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tppi=tt1*ck(k)+tppi
             kk=kk+1
           endif
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION tpii(it1,it2,it3)
!! part of W**(2t3,2t2+1,2t1+1) in table 61-a
!! with T(2t3,2t2+1,2t1+1,j1)   in table 41
!< *******************************************************************
       FUNCTION tpii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
       common/ftth/makti,maktp
       logical makti,maktp
       tpii=0.
       if(.not.maktp) then
         maktp=.true.
         kk=1
         do k=2,kmax,2
           km1=k-1
           xsj1=1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
               stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+2)
               mm=mm+1
             enddo
!    s3pw(j1km+1)=as3**j1km
             stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
             stc2p(kk,jj1)=2.*fpar(km1,2*jm1+1)*stoc
             tt1=tt1+tt*stc2p(kk,jj1)
             xsj1=-xsj1
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tpii=tt1*ck(k)+tpii
             kk=kk+1
           endif
         enddo
         return
       else
         kk=1
         do k=2,kmax,2
           km1=k-1
           tt1=0.
           jm1=0
           jj1=1
           do j1=1,km1,2
             j1km=km1-2*jm1-1
!     j1km must be always greather or equal to zero
             if(j1km.lt.0) EXIT
!    T(2t3,2t2,2t1,j1) in table 41
             it3j1=it3+jm1
             tt=0.
             mm=1
             do m=1,it3j1+1
               mm1=m-1
               it23jm=2*(it2+it3+jm1-mm1)
               it1m=2*(it1+mm1)
               tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
               mm=mm+1
             enddo
             tt1=tt1+tt*stc2p(kk,jj1)
             jm1=jm1+1
             jj1=jj1+1
           enddo
           if(j1km.ge.0) then
             tpii=tt1*ck(k)+tpii
             kk=kk+1
           endif
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sipp(it1,it2,it3)
!! second part of W**(2t3+1,2t2,2t1) in table 61-b
!! with S(2t3+1,2t2,2t1,j1)  in table 70-b
!< *******************************************************************
       FUNCTION sipp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/hass/carg(100),sarg(100),argip(100)
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       sipp=0.
       it1p=2*it1+1
       it2p=2*it2+1
       it12p=2*(it1+it2+1)+1
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         xsj1=-1.
         km1=k-1
         tt1=0.
         jm1=0
         jj2=1
         do j1=1,km1,2
           jj1=2*jm1+1
           j1km=km1-jj1
             if(j1km.lt.0) EXIT
!    S(2t3+1,2t2,2t1,j1) computation
!      Gauss quadrature in table 70-b
           i1123j1=it1+it2+it3+jm1+1
           i2123j1=2*i1123j1
           tt=0.
           do ig=1,igaus
! Hermite functions are in the table hsint(ig,,ind )
!   caution!! !! in the table hsint the indice ind is starting from 1
!              i2123j1 is starting from zero
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base/sqblam(ig)*(htm0+htp0)
           enddo
           if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstci(kk,jj2)=fpar(km1,jj1)*stock
             xsj1=-xsj1
           endif
           tt1=sstci(kk,jj2)*tt+tt1
           jj2=jj2+1
           jm1=jm1+1
         enddo
         if(j1km.ge.0) then
           sipp=sipp+tt1*ck(k)
           kk=kk+1
!  enddo from k (k=1,kmax+1)
         endif
       enddo
       sipp=sipp*bsp
       maksi=.true.
       return
       end
!> *******************************************************************
!! FUNCTION siip(it1,it2,it3)
!! W**(2t3+1,2t2+1,2t1)       in table 61-b
!! with S(2t3+1,2t2+1,2t1,j1) in table 70-b
!< *******************************************************************
       FUNCTION siip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       siip=0.
       it1p=2*it1+1
       it2p=2*it2+2
       it12p=2*(it1+it2+2)
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         xsj1=-1.
         km1=k-1
         tt1=0.
         jm1=0
         jj2=1
         do j1=1,km1,2
           jj1=2*jm1+1
           j1km=km1-jj1
             if(j1km.lt.0) EXIT
!    S(2t3+1,2t2,2t1,j1) computation
!      Gauss quadrature in table 70-b
           i1123j1=it1+it2+it3+jm1+2
           i2123j1=2*i1123j1-1
           tt=0.
           do ig=1,igaus
! Hermite functions
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base*(htp0-htm0)
           enddo
           if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstci(kk,jj2)=fpar(km1,jj1)*stock
             xsj1=-xsj1
           endif
           tt1=sstci(kk,jj2)*tt+tt1
           jj2=jj2+1
           jm1=jm1+1
         enddo
         if(j1km.ge.0) then
           siip=siip+tt1*ck(k)
           kk=kk+1
         endif
!  enddo from k (k=1,kmax+1)
       enddo
       siip=siip*bsp
       maksi=.true.
       return
       end
!> *******************************************************************
!! FUNCTION sipi(it1,it2,it3)
!! part of W**(2t3+1,2t2,2t1+1)     in table 61-b
!! with S(2t3+1,2t2,2t1+1,j1) given in table 70-b
!< *******************************************************************
       FUNCTION sipi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       sipi=0.
       it1p=2*it1+2
       it2p=2*it2+1
       it12p=2*(it1+it2+2)
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         xsj1=-1.
         km1=k-1
         tt1=0.
         jm1=0
         jj2=1
         do j1=1,km1,2
           jj1=2*jm1+1
           j1km=km1-jj1
             if(j1km.lt.0) EXIT
!    S(2t3+1,2t2,2t1,j1) computation
!      Gauss quadrature in table 70-b
           i1123j1=it1+it2+it3+jm1+2
           i2123j1=2*i1123j1-1
           tt=0.
           do ig=1,igaus
! Hermite functions
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base*(htp0+htm0)
           enddo
           if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstci(kk,jj2)=fpar(km1,jj1)*stock
             xsj1=-xsj1
           endif
           tt1=sstci(kk,jj2)*tt+tt1
           jj2=jj2+1
           jm1=jm1+1
         enddo
         if(j1km.ge.0) then
           sipi=sipi+tt1*ck(k)
           kk=kk+1
         endif
!  enddo from k (k=1,kmax+1)
       enddo
       sipi=sipi*bsp
       maksi=.true.
       return
       end
!> *******************************************************************
!! FUNCTION siii(it1,it2,it3)
!! part of W**(2t3+1,2t2+1,2t1+1) in table 61-b
!! with S(2t3+1,2t2+1,2t1+1,j1)   in table 70-b
!< *******************************************************************
       FUNCTION siii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       siii=0.
       it1p=2*it1+2
       it2p=2*it2+2
       it12p=2*(it1+it2+2)+1
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         xsj1=-1.
         km1=k-1
         tt1=0.
         jm1=0
         jj2=1
         do j1=1,km1,2
           jj1=2*jm1+1
           j1km=km1-jj1
           if(j1km.lt.0) EXIT
!    S(2t3+1,2t2,2t1,j1) computation
!      Gauss quadrature in table 70-b
           i1123j1=it1+it2+it3+jm1+2
           i2123j1=2*i1123j1
           tt=0.
           do ig=1,igaus
! Hermite functions
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base*(htm0-htp0)/sqblam(ig)
           enddo
           if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstci(kk,jj2)=fpar(km1,jj1)*stock
             xsj1=-xsj1
           endif
           tt1=sstci(kk,jj2)*tt+tt1
           jj2=jj2+1
           jm1=jm1+1
         enddo
         if(j1km.ge.0) then
           siii=siii+tt1*ck(k)
           kk=kk+1
         endif
!  enddo from k (k=1,kmax+1)
       enddo
       siii=-siii*bsp
       maksi=.true.
       return
       end
!> *******************************************************************
!! FUNCTION sppp(it1,it2,it3)
!! part of W**(2t3,2t2,2t1)     in table 61-a
!! with S(2t3,2t2,2t1,j1) given in table 70-a
!< *******************************************************************
       FUNCTION sppp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       sppp=0.
       it1p=2*it1+1
       it2p=2*it2+1
       it12p=2*(it1+it2+1)+1
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         km1=k-1
         xsj1=1
         tt1=0.
         jj1=1
         do j1=1,k
           jm1=j1-1
           j1km=km1-2*jm1
           if(j1km.lt.0) EXIT
!     j1km must be always greather or equal to zero
!      Gauss quadrature in table 70-a
           i1123j1=it1+it2+it3+jm1
           i2123j1=2*i1123j1
           tt=0.
           do ig=1,igaus
! Hermite functions
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base*(htm0+htp0)/sqblam(ig)
           enddo
           if(.not.maksp) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
             xsj1=-xsj1
           endif
           tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
           jj1=jj1+1
         enddo
         sppp=sppp+tt1*ck(k)
         kk=kk+1
!  enddo from k (k=1,kmax+1)
       enddo
       sppp=sppp*bsp
       maksp=.true.
       return
       end
!> *******************************************************************
!! FUNCTION spip(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1)     in table 61-a
!! with S(2t3,2t2,2t1+1,j1) given in table 70-a
!< *******************************************************************
       FUNCTION spip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       spip=0.
       it1p=2*it1+1
       it2p=2*it2+2
       it12p=2*(it1+it2+1)+2
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         km1=k-1
         xsj1=1
         tt1=0.
         jj1=1
         do j1=1,k
           jm1=j1-1
           j1km=km1-2*jm1
           if(j1km.lt.0) EXIT
!     j1km must be always greather or equal to zero
!      Gauss quadrature in table 70-a
           i1123j1=it1+it2+it3+jm1
           i2123j1=2*i1123j1+1
           tt=0.
           do ig=1,igaus
! Hermite functions
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1+1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base*(htp0-htm0)
           enddo
           if(.not.maksp) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
             xsj1=-xsj1
           endif
           tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
           jj1=jj1+1
         enddo
         spip=spip+tt1*ck(k)
         kk=kk+1
!  enddo from k (k=1,kmax+1)
       enddo
       spip=spip*bsp
       maksp=.true.
       return
       end
!> *******************************************************************
!! FUNCTION sppi(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1)     in table 61-a
!! with S(2t3,2t2,2t1+1,j1) given in table 70-a
!< *******************************************************************
       FUNCTION sppi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       sppi=0.
       it1p=2*it1+2
       it2p=2*it2+1
       it12p=2*(it1+it2+1)+2
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         km1=k-1
         xsj1=1.
         tt1=0.
         jj1=1
         do j1=1,k
           jm1=j1-1
           j1km=km1-2*jm1
!     j1km must be always greather or equal to zero
           if(j1km.lt.0) EXIT
!      Gauss quadrature in table 70-a
           i1123j1=it1+it2+it3+jm1
           i2123j1=2*i1123j1+1
           tt=0.
           do ig=1,igaus
! Hermite functions
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1+1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base*(htm0+htp0)
           enddo
           if(.not.maksp) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
             xsj1=-xsj1
           endif
           tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
           jj1=jj1+1
         enddo
         sppi=sppi+tt1*ck(k)
         kk=kk+1
!  enddo from k (k=1,kmax+1)
       enddo
       sppi=sppi*bsp
       maksp=.true.
       return
       end
!> *******************************************************************
!! FUNCTION spii(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1)       in table 61-a
!! with S(2t3,2t2+1,2t1+1,j1) given in table 70-a
!< *******************************************************************
       FUNCTION spii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/randu/ck(15),kmax
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/rms/rms(3,50),s1,s2,s3
       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/fssk/sstci(8,8),sstcp(8,8)
       common/fsth/maksi,maksp
       logical maksi,maksp
       spii=0.
       it1p=2*it1+2
       it2p=2*it2+2
       it12p=2*(it1+it2+2)+1
       bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
       kk=1
       do k=1,kmax,2
         km1=k-1
         xsj1=1.
         tt1=0.
         jj1=1
         do j1=1,k
           jm1=j1-1
           j1km=km1-2*jm1
           if(j1km.lt.0) EXIT
!     j1km must be always greather or equal to zero
!      Gauss quadrature in table 70-a
           i1123j1=it1+it2+it3+jm1
           i2123j1=2*i1123j1+2
           tt=0.
           do ig=1,igaus
! Hermite functions
             base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1+1)
             htm0=hsint(ig,2,i2123j1+1)
             htp0=hsint(ig,1,i2123j1+1)
             tt=tt+base*(htm0-htp0)/sqblam(ig)
           enddo
           if(.not.maksp) then
!   s3pw(j1km+1)=as3**j1km
             stock=2.*xsj1*s3pw(j1km+1)
             sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
             xsj1=-xsj1
           endif
           tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
           jj1=jj1+1
         enddo
         spii=spii+tt1*ck(k)
         kk=kk+1
!  enddo from k (k=1,kmax+1)
       enddo
       maksp=.true.
       spii=-spii*bsp
       return
       end
!****************************************************************
!  funtions sigma in table 14
!   these functions are used in tables 77-a-1 to 77-b-2
!   sgppp -->l,m and n even
!   sgpip --> l even, m odd, n even
!   .................................
!*****************************************************************
!> *******************************************************************
!! FUNCTION sgppp(it1,it2,it3)
!! FUNCTION sigma(2t3,2t2,2t1) in table 14
!! in E(2t3,2t2,2t1)           in table 77-a-1
!< *******************************************************************
       FUNCTION sgppp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgppp=0.
       if(it3.eq.0) return
       sgn=-1.
       if(.not.mksgp) then
         mksgp=.true.
         do ik=1,it3
           sg1=0.
           km2=2*ik-2
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
           sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
           enddo
           sgppp=sgppp+sgp3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
           enddo
           sgppp=sgppp+sgp3(ik)*sg1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sgpip(it1,it2,it3)
!! FUNCTION sigma(2t3,2t+1,2t1) in table 14
!! is in E(2t3,2t2+1,2t1) given in table 77-a-2
!< *******************************************************************
       FUNCTION sgpip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgpip=0.
       if(it3.eq.0) return
       sgn=-1.
       if(.not.mksgp) then
         mksgp=.true.
         do ik=1,it3
           sg1=0.
           km2=2*ik-2
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
!omment             hs30=hs3(km2+1)*rms(3,it3k+1)
           sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
           enddo
           sgpip=sgpip+sgp3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
           enddo
           sgpip=sgpip+sgp3(ik)*sg1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sgppi(it1,it2,it3)
!! FUNCTION sigma(2t3,2t2,2t1+1) in table 14
!! is in E(2t3,2t2,2t1+1)        in table 77-a-2
!< *******************************************************************
       FUNCTION sgppi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgppi=0.
       if(it3.eq.0) return
       sgn=-1.
       if(.not.mksgp) then
         mksgp=.true.
         do ik=1,it3
           sg1=0.
           km2=2*ik-2
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
           sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
           enddo
           sgppi=sgppi+sgp3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
           enddo
           sgppi=sgppi+sgp3(ik)*sg1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sgpii(it1,it2,it3)
!! FUNCTION sigma(2t3,2t2+1,2t1+1)  in table 14
!! correspond to E(2t3,2t2+1,2t1+1) in table 77-a-1
!< *******************************************************************
       FUNCTION sgpii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgpii=0.
       if(it3.eq.0) return
       sgn=-1.
       if(.not.mksgp) then
         mksgp=.true.
         do ik=1,it3
           sg1=0.
           km2=2*ik-2
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
           sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
           enddo
           sgpii=sgpii+sgp3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
           enddo
           sgpii=sgpii+sgp3(ik)*sg1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sgipp(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2,2t1) in table 14
!! E(2t3+1,2t2,2t1)     is given in table 77-b-2
!< *******************************************************************
       FUNCTION sgipp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgipp=0.
       if(it3.le.0) return
       sgn=-1.
       if(.not.mksgi) then
         mksgi=.true.
         do ik=1,it3
           sg1=0.
           km1=2*ik-1
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
           sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
           enddo
           sgipp=sgipp+sgi3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
           enddo
           sgipp=sgipp+sgi3(ik)*sg1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sgiip(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2+1,2t1) in table 14
!! inside E(2t3+1,2t2+1,2t1) given in table 77-b-1
!< *******************************************************************
       FUNCTION sgiip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgiip=0.
       if(it3.eq.0) return
       sgn=-1.
       if(.not.mksgi) then
         mksgi=.true.
         do ik=1,it3
           sg1=0.
           km1=2*ik-1
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
           sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
           enddo
           sgiip=sgiip+sgi3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
           enddo
           sgiip=sgiip+sgi3(ik)*sg1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sgipi(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2,2t1+1)  in table 14
!! in E(2t3+1,2t2,2t1+1)            in table 77-b-1
!< *******************************************************************
       FUNCTION sgipi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgipi=0.
       if(it3.eq.0) return
       sgn=-1.
       if(.not.mksgi) then
         mksgi=.true.
         do ik=1,it3
           sg1=0.
           km1=2*ik-1
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
           sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
           enddo
           sgipi=sgipi+sgi3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
           enddo
           sgipi=sgipi+sgi3(ik)*sg1
         enddo
         return
       endif
       end
!> *******************************************************************
!! FUNCTION sgiii(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2+1,2t1+1) in table 14
!! in E(2t3+1,2t2+1,2t1+1)           in table 77-b-2
!< *******************************************************************
       FUNCTION sgiii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/herfun/hs1(60),hs2(60),hs3(60)
       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
       common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
       common/sgpth/mksgi,mksgp
       logical mksgi,mksgp
       sgiii=0.
       if(it3.eq.0) return
       sgn=-1.
       if(.not.mksgi) then
         mksgi=.true.
         do ik=1,it3
           sg1=0.
           km1=2*ik-1
           it3kp1=it3-ik+1
           it3k=2*(it3-ik)
           sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
           do jk=1,it3kp1
             jkm1=jk-1
             jt3kj=2*(it3-ik-jkm1)
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
             sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
           enddo
           sgiii=sgiii+sgi3(ik)*sg1
           sgn=-sgn
         enddo
         return
       else
         do ik=1,it3
           sg1=0.
           it3kp1=it3-ik+1
           do jk=1,it3kp1
             jkm1=jk-1
             jt23kj=2*(it3+it2-ik-jkm1)
             jt1j=2*(it1+jkm1)
             sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
           enddo
           sgiii=sgiii+sgi3(ik)*sg1
         enddo
         return
       endif
       end
!*****************************************************************************
!   Functions U and V given in tables 75 and 76
!   uppp ---> l,m,n  even
!   upip ---> l even, m odd, n even
!   .................................
!*****************************************************************************
!> *******************************************************************
!! FUNCTION uppp(it1,it2,it3)
!! the integral U(2t3,2t2,2t1,thet) is given in table 75
!! the summation with cos(thet)**2*t1,cos(thet)**2*t2 is found in
!! table 77-a-1
!< *******************************************************************
       FUNCTION uppp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       uppp=0.
       ind=2*(it1+it2+it3)+1
       idt1=2*it1+1
       idt2=2*it2+1
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arcc(i,j)=ragp(i,ind)*akpcc(i,j)
           u=u+arcc(i,j)*epsi1(i,j)
         enddo
         uppp=uppp+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION upip(it1,it2,it3)
!! the integral U(2t3,2t2+1,2t1,thet) is given in table 75
!! the summation with cos(thet)**2t1,cos(thet)**(2t2+1) is in
!! table 77-a-2
!< *******************************************************************
       FUNCTION upip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       upip=0.
       ind=2*(it1+it2+it3)+2
       idt1=2*it1+1
       idt2=2*it2+2
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arcs(i,j)=ragp(i,ind)*akpcs(i,j)
           u=u+arcs(i,j)*epsi1(i,j)
         enddo
         upip=upip+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION uppi(it1,it2,it3)
!! the integral U(2t3,2t2,2t1+1,thet)  in table 75
!! the summation with cos(thet)**(2*t1+1),cos(thet)**2*t2  in
!! table 77-a-2
!< *******************************************************************
       FUNCTION uppi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       uppi=0.
       ind=2*(it1+it2+it3)+2
       idt1=2*it1+2
       idt2=2*it2+1
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arsc(i,j)=ragp(i,ind)*akpsc(i,j)
           u=u+arsc(i,j)*epsi1(i,j)
         enddo
         uppi=uppi+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION upii(it1,it2,it3)
!! the integral U(2*t3,2*t2+1,2*t1+1,thet)  table 75
!! the summation with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1)
!! table 77-a-1
!< *******************************************************************
      FUNCTION upii(it1,it2,it3)
      implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       upii=0.
       ind=2*(it1+it2+it3+1)+1
       idt1=2*it1+2
       idt2=2*it2+2
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arss(i,j)=ragp(i,ind)*akpss(i,j)
           u=u+arss(i,j)*epsi1(i,j)
         enddo
         upii=upii+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION uipp(it1,it2,it3)
!! the integral U(2*t3+1,2*t2,2*t1,thet)  table 75
!! for the summation with cos(thet)**2*t1,cos(thet)**2*t2 see
!! table 77-b-2
!< *******************************************************************
       FUNCTION uipp(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       uipp=0.
       ind=2*(it1+it2+it3+1)
       idt1=2*it1+1
       idt2=2*it2+1
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arcc(i,j)=ragp(i,ind)*akpcc(i,j)
           u=u+arcc(i,j)*epsi1(i,j)
         enddo
         uipp=uipp+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION uiip(it1,it2,it3)
!! the integral U(2*t3+1,2*t2+1,2*t1,thet) table 75
!! summation over cos(thet)**2*t1,cos(thet)**(2*t2+1) table 77-b-1
!< *******************************************************************
       FUNCTION uiip(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       uiip=0.
       ind=2*(it1+it2+it3+1)+1
       idt1=2*it1+1
       idt2=2*it2+2
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arcs(i,j)=ragp(i,ind)*akpcs(i,j)
           u=u+arcs(i,j)*epsi1(i,j)
         enddo
         uiip=uiip+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION uipi(it1,it2,it3)
!! the integral U(2t3+1,2t2,2t1+1,thet)  table 75
!! summation over cos(thet)**(2*t1+1),cos(thet)**2*t2  table 77-b-1
!< *******************************************************************
       FUNCTION uipi(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *             arss(40,40),cs(40)
       uipi=0.
       ind=2*(it1+it2+it3+1)+1
       idt1=2*it1+2
       idt2=2*it2+1
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arsc(i,j)=ragp(i,ind)*akpsc(i,j)
           u=u+arsc(i,j)*epsi1(i,j)
         enddo
         uipi=uipi+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION uiii(it1,it2,it3)
!! the integral U(2*t3+1,2*t2+1,2*t1+1,thet)  table 75
!! summation with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1)
!! (see table 77-b-2)
!< *******************************************************************
       FUNCTION uiii(it1,it2,it3)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       uiii=0.
       ind=2*(it1+it2+it3+1)+2
       idt1=2*it1+2
       idt2=2*it2+2
       do j=1,igaus
         cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
         u=0.
         do i=1,igaus
           arss(i,j)=ragp(i,ind)*akpss(i,j)
           u=u+arss(i,j)*epsi1(i,j)
         enddo
         uiii=uiii+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION vppp(k)
!! the integral V(2t3,2t2,2t1,k,thet)  table 76
!! sum with cos(thet)**2*t1,cos(thet)**2*t2 (see table 77-a-1)
!< *******************************************************************
       FUNCTION vppp(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *              akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *               arss(40,40),cs(40)
       vppp=0.
       do j=1,igaus
         u=0.
         do i=1,igaus
           u=u+arcc(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         vppp=vppp+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION vpip(k)
!! the integral V(2t3,2t2+1,2t1,k,thet)  table 76
!! sum with cos(thet)**2*t1,cos(thet)**(2*t2+1) (table 77-a-2)
!< *******************************************************************
       FUNCTION vpip(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *              akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       vpip=0.
       do j=1,igaus
         u=0.
         do i=1,igaus
           u=u+arcs(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         vpip=vpip+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION vppi(k)
!! the integral V(2t3,2t2,2t1+1,k,thet)  table 76
!! sum wih cos(thet)**2*t1,cos(thet)**(2*t2+1) (table 77-a-2)
!< *******************************************************************
       FUNCTION vppi(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *              akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       vppi=0.
       do j=1,igaus
         u=0.
         do i=1,igaus
           u=u+arsc(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         vppi=vppi+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION vpii(k)
!! the integral V(2*t3,2*t2+1,2*t1+1,k,thet)   table 76
!! sum with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1) (table 77-a-1)
!< *******************************************************************
       FUNCTION vpii(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       vpii=0.
       do j=1,igaus
       u=0.
         do i=1,igaus
           u=u+arss(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         vpii=vpii+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION vipp(k)
!! the integral V(2*t3+1,2*t2,2*t1,thet)  table 76
!! sum with cos(thet)**2*t1,cos(thet)**2*t2 ( table 77-b-2)
!< *******************************************************************
       FUNCTION vipp(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *              akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       vipp=0.
       do j=1,igaus
         u=0.
         do i=1,igaus
           u=u+arcc(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         vipp=vipp+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION viip(k)
!! the integral V(2*t3+1,2*t2+1,2*t1,thet)       table 76
!! sum with cos(thet)**2*t1,cos(thet)**(2*t2+1) (table 77-b-1)
!< *******************************************************************
       FUNCTION viip(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       viip=0.
       do j=1,igaus
         u=0.
         do i=1,igaus
           u=u+arcs(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         viip=viip+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION vipi(k)
!! the integral V(2*t3+1,2*t2,2*t1+1,k,thet)     table 76
!! sum with cos(thet)**(2*t1+1),cos(thet)**2*t2 (table 77-b-1)
!< *******************************************************************
       FUNCTION vipi(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       vipi=0.
       do j=1,igaus
         u=0.
         do i=1,igaus
           u=u+arsc(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         vipi=vipi+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION viii(k)
!! the integral V(2*t3+1,2*t2+1,2*t1+1,thet)      in table 76
!! sum with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1) (table 77-b-2)
!< *******************************************************************
       FUNCTION viii(k)
       implicit real(8) (a-h,o-z)
       common/rms/rms(3,50),s1,s2,s3
       common/gauss1/absg(40),wg(40),igaus
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40),
     *             akpcs(40,40),akpsc(40,40),akpss(40,40)
       common/expmod/ragp(40,100),ragm1(40,40)
       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40),
     *              arss(40,40),cs(40)
       viii=0.
       do j=1,igaus
         u=0.
         do i=1,igaus
           u=u+arss(i,j)*ragm1(i,k)*epsi2(i,j)
         enddo
         viii=viii+cs(j)*u
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE pintfast
!! Particles too far from the C. of G. of the bunch are eliminated
!! for the Almn computations with HERSC
!< *******************************************************************
       SUBROUTINE pintfast
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/vl,pi,xmat,rpel,qst
       common/dyn/tref,vref
       common/sc3/beamc,scdist,sce10,cplm,ectt,apl,ichaes,iscsp
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/part/xc(iptsz),yc(iptsz),zc(iptsz)
       common/dimens/zcp(iptsz),xcp(iptsz),ycp(iptsz)
       common/nume/nuelm
       common/vpintim/gcg,bcg
       common/coef/a(30,30,30),xrmsz,yrmsz,zrmsz
       common/macro/ratei
       nuelm=nuelm+1
       write(16,*)' space charge with HERSC call number: ',nuelm
       trmoy=0.
       wcg=0.
       xcg=0.
       xcg=0.
       ycg=0.
       do i=1,ngood
         trmoy=trmoy+f(6,i)
         wcg=wcg+f(7,i)
         xcg=xcg+f(2,i)
         ycg=ycg+f(4,i)
       enddo
       trmoy=trmoy/float(ngood)
       wcg=wcg/float(ngood)
       gcg=wcg/xmat
       bcg=sqrt(1.-1./(gcg*gcg))
       xcg=xcg/float(ngood)
       ycg=ycg/float(ngood)
       zcg=trmoy*fh
!  Isochronism correction in bending magnet
!  apl is the angle due to the lack of isochronicity in the plane (x,z)
!  (see : A modified space charge routine for high intensity bunched
!         beam,P.Lapostolle and 5 authors,NIM A Vol.379,pp21-40,
!         September 1996)
!    does not work with SCHEFF method (iscsp=3)
       apl=0.
       if(iscsp.le.2) then
         xb2x=0.
         xb2z=0.
         xbxz=0.
         imaxx=0
         do np=1,ngood
           gnp=f(7,np)/xmat
           bnp=sqrt(1.-1./(gnp*gnp))
           zc(np)=(trmoy-f(6,np))*bnp*vl/100.
!   *   correct. relativiste
!omment           zc(np)=zc(np)*gcg
!   *
           xc(np)=(f(2,np)-xcg)/100.
           xb2z=xb2z+zc(np)*zc(np)
           xb2x=xb2x+xc(np)*xc(np)
           xbxz=xbxz+zc(np)*xc(np)
           imaxx=imaxx+1
         enddo
         xb2z=xb2z/float(imaxx)
         xb2x=xb2x/float(imaxx)
         xbxz=xbxz/float(imaxx)
         apl=atan(-2.*xbxz/(xb2x-xb2z))/2.
       endif
       write(16,*)'*slope of the bunch in plane(Oz,Ox):',apl,' radian'
! bunch at the space charge position
       xbar=0.
       ybar=0.
       zbar=0.
       imaxx=0
!  Divide by 100. to convert from centimeters to meters
       do np=1,ngood
         gnp=f(7,np)/xmat
         bnp=sqrt(1.-1./(gnp*gnp))
         znp=(trmoy-f(6,np))*bnp*vl
!   *   correct. relativiste valero
!omment         znp=znp*gcg
!   *
         xnp=f(2,np)
         zc(np)=znp*cos(apl)+xnp*sin(apl)
         xnp=xnp*cos(apl)-znp*sin(apl)
!  convert from mrad to rad
         f3=f(3,np)*1.e-03
         f5=f(5,np)*1.e-03
!  convert from cm   to m
         xc(np)=(xnp+zc(np)*f3)/100.
         yc(np)=(f(4,np)+zc(np)*f5)/100.
         zc(np)=zc(np)/100.
! evaluate xbar , ybar , zbar
         xbar=xbar+xc(np)
         ybar=ybar+yc(np)
         zbar=zbar+zc(np)
       enddo
       eng=float(ngood)
       xbar=xbar/eng
       ybar=ybar/eng
       zbar=zbar/eng
       do np=1,ngood
         xc(np)=xc(np)-xbar
         yc(np)=yc(np)-ybar
         zc(np)=zc(np)-zbar
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE hcoef
!! the significant Hermite coefficients (called by HERSC)
!< *******************************************************************
       SUBROUTINE hcoef
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/vl,pi,xmat,rpel,qst
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/hcgrms/xcdg,ycdg,zcdg,ect,eps
       common/ind/lmax,mmax,nmax
       common/indttal/lmnt
       common/randu/ck(15),kmax
       common/coef/a(30,30,30),xrmsz,yrmsz,zrmsz
       common/part/xc(iptsz),yc(iptsz),zc(iptsz)
       common/isoch/apl
       common/dimens/zcp(iptsz),xcp(iptsz),ycp(iptsz)
       common/nume/nuelm
       common/macro/ratei
       common/facrms/fxrms,fyrms,fzrms
       common/rcoef/rdcf
       common/factor/fpir(40,40),fect(30)
       dimension hx(30),hy(30),hz(30),tran(1)
! calculation of Hermite coefficients on the principal axis in x,y,z
       do i=1,ngood
         zcp(i)=zc(i)
         xcp(i)=xc(i)
         ycp(i)=yc(i)
       enddo
       do kn=1,nmax
         do km=1,mmax
           do kl=1,lmax
             a(kl,km,kn)=0.
           enddo
         enddo
       enddo
       zcg=0.
       xcg=0.
       ycg=0.
       do i=1,ngood
         zcg=zcg+zc(i)
         xcg=xcg+xc(i)
         ycg=ycg+yc(i)
       enddo
       xcg=xcg/float(ngood)
       ycg=ycg/float(ngood)
       zcg=zcg/float(ngood)
       xsqsum=0.
       ysqsum=0.
       zsqsum=0.
!    evaluate the rms sizes
       do j=1,ngood
         xcj=xc(j)-xcg
         ycj=yc(j)-ycg
         zcj=zc(j)-zcg
         xsqsum=xsqsum+xcj*xcj
         ysqsum=ysqsum+ycj*ycj
         zsqsum=zsqsum+zcj*zcj
       enddo
       xrmsz=xsqsum/float(ngood)
       yrmsz=ysqsum/float(ngood)
       zrmsz=zsqsum/float(ngood)
       xrmsz=sqrt(xrmsz)
       yrmsz=sqrt(yrmsz)
       zrmsz=sqrt(zrmsz)
       write(16,*) '*RMS of the bunch (m): ',xrmsz,yrmsz,zrmsz
!omment       write(17,25) nuelm,xrmsz,yrmsz,zrmsz
!omment25     format(2x,i5,3(2x,e12.5))
!     ***TEST control s.c.
!omment        rewind(19)
!omment        irep=0
!omment        rewind(21)
!omment        write(21,*) '      x(cm)         y(cm)         z(cm)'
!   coordinates of the bunch  x, y, z
!omment        do j=1,ngood
!omment          xcoup=(xcp(j)-xcg)/xrmsz
!omment          ycoup=(ycp(j)-ycg)/yrmsz
!omment          zcoup=(zcp(j)-zcg)/zrmsz
!omment          write(21,1188) xcoup,ycoup,zcoup
!omment          if((abs(xcoup).lt.fxrms).and.(abs(ycoup).lt.fyrms).and.
!omment     *      (abs(zcoup).lt.fzrms)) then
!omment           write(19,1188) xcoup,ycoup,zcoup
!omment           irep=irep+1
!omment          endif
!omment        enddo
!omment1188     format(3(2x,e12.5))
!    ***END TEST control s.c.
       if(rdcf.ge.1.) then
         hz(1)=1.
         hy(1)=1.
         hx(1)=1.
         irct=0
         do j=1,ngood
           xc(j)=(xcp(j)-xcg)/xrmsz
           yc(j)=(ycp(j)-ycg)/yrmsz
           zc(j)=(zcp(j)-zcg)/zrmsz
           if((abs(xc(j)).lt.fxrms).and.(abs(yc(j)).lt.fyrms).and.
     *        (abs(zc(j)).lt.fzrms)) then
             irct=irct+1
             ach=abs(f(9,j))
             hz(2)=zc(j)
             hy(2)=yc(j)
             hx(2)=xc(j)
             do kn=1,nmax
               if(kn.gt.2) hz(kn)=zc(j)*hz(kn-1)-float(kn-2)*hz(kn-2)
               do km=1,mmax
                 if(km.gt.2) hy(km)=yc(j)*hy(km-1)-float(km-2)*hy(km-2)
                 do kl=1,lmax
                   if(kl.gt.2) hx(kl)=xc(j)*hx(kl-1)-float(kl-2)*
     *                                hx(kl-2)
                   xherm=hx(kl)*hy(km)*hz(kn)/(fect(kl)*fect(km)*
     *                   fect(kn))
                   a(kl,km,kn)=a(kl,km,kn)+xherm/pwtpi*ach
                 enddo
               enddo
             enddo
           endif
         enddo
         rate=float(ngood)/float(irct)
!         write(16,*) ' particles kept in Almn computation: ',irct
         do kn=1,nmax
           do km=1,mmax
             do kl=1,lmax
               a(kl,km,kn)=a(kl,km,kn)*rate
             enddo
           enddo
         enddo
       endif
!*********************************
       if(rdcf.lt.1.) then
         rdcfc=rdcf*float(imax)/float(ngood)
         if(rdcfc.gt.1.) rdcfc=1.
         len=1
         irct=0
         hz(1)=1.
         hy(1)=1.
         hx(1)=1.
         do j=1,ngood
           call rlux(tran,len)
           if(tran(1).le.rdcfc) then
             xc(j)=(xcp(j)-xcg)/xrmsz
             yc(j)=(ycp(j)-ycg)/yrmsz
             zc(j)=(zcp(j)-zcg)/zrmsz
             if((abs(xc(j)).lt.fxrms).and.(abs(yc(j)).le.fyrms).and.
     *         (abs(zc(j)).lt.fzrms)) then
               ach=abs(f(9,j))
               irct=irct+1
               hz(2)=zc(j)
               hy(2)=yc(j)
               hx(2)=xc(j)
               do kn=1,nmax
                 if(kn.gt.2) hz(kn)=zc(j)*hz(kn-1)-float(kn-2)*hz(kn-2)
                 do km=1,mmax
                   if(km.gt.2) hy(km)=yc(j)*hy(km-1)-float(km-2)*
     *                                hy(km-2)
                   do kl=1,lmax
                     if(kl.gt.2) hx(kl)=xc(j)*hx(kl-1)-float(kl-2)*
     *                                  hx(kl-2)
                     xherm=hx(kl)*hy(km)*hz(kn)/(fect(kl)*fect(km)*
     *                     fect(kn))
                     a(kl,km,kn)=a(kl,km,kn)+xherm/pwtpi*ach
                   enddo
                 enddo
               enddo
             endif
           endif
         enddo
         rate=float(ngood)/float(irct)
         write(16,*) ' particles kept in Almn: ',irct
         do kn=1,nmax
           do km=1,mmax
             do kl=1,lmax
                a(kl,km,kn)=a(kl,km,kn)*rate
             enddo
           enddo
         enddo
       endif
!118    format(3(2x,e12.5))
!   *  cesaro  transformation
       lsup=lmax
       msup=mmax
       nsup=nmax
         do kn=1,nsup
           do km=1,msup
             do kl=1,lsup
               cesl=(1.-float(kl-1)/float(lsup))
               cesm=(1.-float(km-1)/float(msup))
               cesn=(1.-float(kn-1)/float(nsup))
               ces=cesl*cesm*cesn
!esaro force             a(kl,km,kn)=a(kl,km,kn)*ces*ces
               a(kl,km,kn)=a(kl,km,kn)*ces
             enddo
           enddo
         enddo
!    *
!   select the significant coefficients
       fond=abs(a(1,1,1))
       itot=0
       iret=0
       do kn=1,nmax
         n=kn-1
         ipar=n-2*int(n/2)
         if(ipar.eq.0)zz=0.
         if(ipar.ne.0) then
         if(n.eq.1) zz=1.
           if(n.eq.3) zz=.75
           if(n.eq.5) zz=.625
         if(n.gt.5.and.n.le.11) zz=0.50
           if(n.gt.11) zz=0.375
         endif
         do km=1,mmax
           m=km-1
         ipar=m-2*int(m/2)
         if(ipar.eq.0)yy=0.
           if(ipar.ne.0) then
           if(m.eq.1) yy=1.
             if(m.eq.3) yy=.75
             if(m.eq.5) yy=.625
           if(m.gt.5.and.m.le.11) yy=0.50
             if(m.gt.11) yy=0.375
           endif
           do kl=1,lmax
             l=kl-1
             ipar=l-2*int(l/2)
             if(ipar.eq.0)xx=0.
             if(ipar.ne.0) then
             if(l.eq.1) xx=1.
             if(l.eq.3) xx=.75
             if(l.eq.5) xx=.625
             if(l.gt.5.and.l.le.11) xx=0.50
             if(l.gt.11) xx=0.375
             endif
             itot=itot+1
             xherm=hermint(xx,l)*hermint(yy,m)*hermint(zz,n)
             ab=abs(a(kl,km,kn)*xherm)/fond
             if(ab.ge.eps) then
             iret=iret+1
           else
             a(kl,km,kn)=0.
           endif
           enddo
         enddo
       enddo
       rpeps=float(iret)/float(itot)
       write(16,*)'*significant terms in Hermite series expansion: ',
     *             iret,' total of terms :',itot
       if(rpeps.ge..3) then
         write(16,*) ' problem in space charge : rpeps gt .3 ',rpeps
         stop
       endif
!   select the maximum values l, m and n for the significant coefficients
       lsup=0
       msup=0
       nsup=0
       lmnt=0
       fprec=epsilon(a(1,1,1))
       do kn=1,nmax
         do km=1,mmax
           do kl=1,lmax
!             if(a(kl,km,kn).ne.0.) then
             if(abs(a(kl,km,kn)).gt.fprec) then
               itm=kl+km+kn-3
               if(itm.ge.lmnt) lmnt=itm
               if(lsup.le.kl) lsup=kl
               if(msup.le.km) msup=km
               if(nsup.le.kn) nsup=kn
             endif
            enddo
         enddo
       enddo
       lmnt=lmnt+kmax+4+3
       write(16,*) ' maximum of n m l for the significants terms ',
     *            nsup-1,msup-1,lsup-1
       write(16,*) ' maximun of (t) for the significants terms ',lmnt
!   *  cesaro  transformation
!cc         do kn=1,nsup
!cc           do km=1,msup
!cc             do kl=1,lsup
!cc               cesl=(1.-float(kl-1)/float(lsup))
!cc               cesm=(1.-float(km-1)/float(msup))
!cc               cesn=(1.-float(kn-1)/float(nsup))
!cc               ces=cesl*cesm*cesn
!cc              a(kl,km,kn)=a(kl,km,kn)*ces
!cc             enddo
!cc           enddo
!cc         enddo
!    *
       return
       end
!> *******************************************************************
!! SUBROUTINE hersc(ini)
!! space charge method: HERSC
!< *******************************************************************
       SUBROUTINE hersc(ini)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/vl,pi,xmat,rpel,qst
       common/sc3/beamc,scdist,sce10,cplm,ectt,apl,ichaes,iscsp
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/cdek/dwp(iptsz)
       common/part/xc(iptsz),yc(iptsz),zc(iptsz)
       common/coef/a(30,30,30),xrmsz,yrmsz,zrmsz
       common/hcgrms/xcdg,ycdg,zcdg,ect,eps
       common/ind/lmax,mmax,nmax
       common/indin/lmaxi,mmaxi,nmaxxi
       common/indttal/lmnt
       common/rms/rms(3,50),s1,s2,s3
       common/randu/ck(15),kmax
       common/circu/co(40,50),sn(40,50),blam(40,100)
       common/gauss1/absg(40),wg(40),igaus
       common/field/ex,ey,ez
       common/expmod/ragp(40,100),ragm1(40,40)
       common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
       common/facrms/fxrms,fyrms,fzrms
       common/dimens/zcp(iptsz),xcp(iptsz),ycp(iptsz)
       common/beamsa/fs(7,iptsz)
       common/dcspa/iesp
       common/cmpte/iell
       common/npart/imaxr
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/rcoef/rdcf
       common/macro/ratei
       common/tapes/in,ifile,meta,ierr
       common/posc/xpsc
       common/locher/rx,ry,rz,nx,ny,nz
       logical ichaes,iesp
       dimension exk(15,15,30),eyk(15,15,30),ezk(15,15,30)
       data lbmax,mbmax,nbmax/23,23,23/
! ini = 0 :initialisation of the routine
       fprec=epsilon(pi)         
       if(ini.le.0) then
         sq2pi=sqrt(2.*pi)
!   input parameters
         igaus=9
!   eps allows to select the significant terms in the HERMITE series expansion
         eps=8.e-03
!   maximun of the upper limits in the HERMITE series expansion
         lmaxi=11
         mmaxi=11
         nmaxxi=11
!   The HERMITE coefficients Almn are computed with the particles include in a cube
!   with regard to the RMS of the bunch. The sizes of the cube are:RMSx*fxrms, ........
         fxrms=2.5
         fyrms=2.5
         fzrms=2.5
         if(ini.lt.0) then
           read(in,*)lmaxi,mmaxi,nmaxxi
           write(16,*)'upper limits ',lmaxi,mmaxi,nmaxxi
           read(in,*)fxrms,fyrms,fzrms
           write(16,*) ' rms factors',fxrms,fyrms,fzrms
           read(in,*)eps
           write(16,*) ' select the Hermite cefficients with: ',eps
         endif
!    MESH**********
!      limits in (+-) RMS
         rx=4.
         ry=4.
         rz=4.
!      number of nodes in each direction
         nx=8
         ny=8
         nz=8
!  rdcf   : in %/100 , allows to select a reduced number of particles for the Almn.
         call shuffle
         call gausse
         read(in,*) rdcf
         if(rdcf.gt.1.) rdcf=1.
         if(rdcf.le.0.) then
           if(ngood.gt.15000) then
             rdcf=15000./float(ngood)
           else
             rdcf=1.
           endif
         endif
         call table(lbmax,mbmax,nbmax)
         return
       endif
! **********************************************************************
       if(ini.eq.1) then
!    .................................................................................
!       seeks: the significant coefficients  in the Hermite series expansions
!              ---> storage array a(l,m,n)
!              maximum values of l,m and n of the significants a(l,m,n) --->lmax,mmax,nmax
!              RMS of the bunch ---> xa,xb and xc
!       order of the succesives integrals
!       isucc=1: xa<xb,xc , rms(3,2)=xa, rms(2,2)=xb,  rms(1,2)=xc
!                           rms(3,k)=xa**(k-1), ..........
!       isucc=2: xb<xa,xc , rms(3,2)=xb, rms(2,2)=xc,  rms(1,2)=xa
!       isucc=1: xc<xa,xb , rms(3,2)=xc, rms(2,2)=xa,  rms(1,2)=xb
!       compute the array blam(i,j)
!        blam(i,j): FUNCTION beta**2 in the fifth relation in table 31
!                   blam(i,j)=beta**2j,j=1,...,im=(lmax+mmax+nmax+kmax)/2+2
!                   i is given from the i-Gauss position in absg(i)
!   ..................................................................................
         call bhdist
         call trms(isucc)
         sta=a(1,1,1)
         icoa=0
         fprec=epsilon(sta)         
         do ican=1,nmax
           do icam=1,mmax
             do ical=1,lmax
!               if(a(ican,icam,ical).ne.0.) icoa=icoa+1
               if(abs(a(ican,icam,ical)).gt.fprec) icoa=icoa+1
             enddo
           enddo
         enddo
       return
       endif
! **********************************************************************
!   beam self-fields
       if(ini.eq.2) then
!   limits of the mesch : rx ry rz
!   length of the steps
         delx=2.*rx/float(nx)
         dely=2.*ry/float(ny)
         delz=2.*rz/float(nz)
!    Initialize constants
!   xmass-Kg,wavel=cm,charge=coul.
!   clight=cm/sec MHz/Hz ,freq=Mhz ,xmat=MeV
! freq. in MHz
         freq=fh*0.5e-06/pi
         epsil=8.854189586e-12
         const3=1.E-06
         const2=1.E-06/xmat
         dxp=0.
         dyp=0.
         dw=0.
         dz=scdist/100.
         dz1=dz
         zsot1=0.
!   qmpart=macro-charge
         qmpart=1.0e-9*beamc/(float(imax)*freq)
         if(ratei.le.0.) then
           write(16,*) ' all the particles are lost '
           stop
         endif
         qmpart=qmpart*ratei
         vrms=xrmsz*yrmsz*zrmsz
         cmacro=qmpart/(epsil*vrms)
         wcg=0.
         do i=1,ngood
          wcg=wcg+f(7,i)
         enddo
         wcg=wcg/float(ngood)
         gcg=wcg/xmat
         gmoy=gcg
         bcg=sqrt(1.-1./(gcg*gcg))
         bmoy=bcg
!  relativistic correction
         cmacro=cmacro/gmoy
!
         cmacrxy=cmacro/(bmoy*bmoy*gmoy*gmoy)
!   beam self-fields at the nodes of the mesh
         imail=0
         rcy=-ry
         do j=1,ny
           rcx=-rx
           do i=1,nx
             rcz=-rz
             do k=1,nz
               if(isucc.eq.1) then
                 s3=rcx
                 s2=rcy
                 s1=rcz
                 ax=pwtpi*rms(3,2)
                 ay=pwtpi*rms(2,2)
                 az=pwtpi*rms(1,2)
                 rrx=rms(3,2)
                 rry=rms(2,2)
                 rrz=rms(1,2)
               endif
               if(isucc.eq.2) then
                 s3=rcy
                 s2=rcz
                 s1=rcx
                 ax=pwtpi*rms(1,2)
                 ay=pwtpi*rms(3,2)
                 az=pwtpi*rms(2,2)
                 rrx=rms(1,2)
                 rry=rms(3,2)
                 rrz=rms(2,2)
               endif
               if(isucc.eq.3) then
                 s3=rcz
                 s2=rcx
                 s1=rcy
                 ax=pwtpi*rms(2,2)
                 ay=pwtpi*rms(1,2)
                 az=pwtpi*rms(3,2)
                 rrx=rms(2,2)
                 rry=rms(1,2)
                 rrz=rms(3,2)
               endif
             call uvrms
!     fields
!       loop over the l,m and n
             exk(i,j,k)=0.
             eyk(i,j,k)=0.
             ezk(i,j,k)=0.
             do jn=1,nmax
                 jn1=jn-1
                 do jm=1,mmax
                   jm1=jm-1
                   do jl=1,lmax
                     jl1=jl-1
!                     if(a(jl,jm,jn).ne.0.) then
                     if(abs(a(jl,jm,jn)).gt.fprec) then
                       call fielde(jl1,jm1,jn1,isucc)
!     the beam self-fields are  in tables 67-a to 67-h
                       exk(i,j,k)=a(jl,jm,jn)/ax*ex+exk(i,j,k)
                       eyk(i,j,k)=a(jl,jm,jn)/ay*ey+eyk(i,j,k)
                       ezk(i,j,k)=a(jl,jm,jn)/az*ez+ezk(i,j,k)
                     endif
                   enddo
                 enddo
               enddo
               rcz=rcz+delz
               imail=imail+1
             enddo
             rcx=rcx+delx
           enddo
           rcy=rcy+dely
         enddo
! xi in Amps, ibeam in mA
         dxp=0.
         dyp=0.
         dw=0.
!   save the  particles coordinates
         do i=1,ngood
           xc(i)=xcp(i)
           yc(i)=ycp(i)
           zc(i)=zcp(i)
         enddo
! Do integration to determine Ex,Ey,Ez for each macro particle
         nprint=1
         insd=0
         iout=0
         ickl=0
         do ic=1,ngood
!     position in the mesh
           ickl=ickl+1
!    *    valero
           u=xc(ic)/xrmsz
           v=yc(ic)/yrmsz
           w=zc(ic)/zrmsz
!omment           u=xc(ic)/rrx
!omment           v=yc(ic)/rry
!omment           w=zc(ic)/rrz
           i=int((u+rx)/delx)+1
           j=int((v+ry)/dely)+1
           k=int((w+rz)/delz)+1
!   the particle is in the mesh
           if(i.gt.0.and.i.le.nx.and.j.gt.0.and.j.le.ny.
     *                        and.k.gt.0.and.k.le.nz) then
             xnd1=-rx+float(i-1)*delx
             ynd1=-ry+float(j-1)*dely
             znd1=-rz+float(k-1)*delz
             delu=u-xnd1
             delv=v-ynd1
             delw=w-znd1
             delux=delu/delx
             delvy=delv/dely
             delwz=delw/delz
! *******interpollation for particle inside a cube
! %%%%%%     in plane 1:
! node 1: (i,j,k)  node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 4:(i,j,k+1)
!  axis (nd1,nd2)
             ex12=(exk(i+1,j,k)-exk(i,j,k))*delux+exk(i,j,k)
!  axis (nd4,nd3)
             ex43=(exk(i+1,j,k+1)-exk(i,j,k+1))*delux+exk(i,j,k+1)
!    plane 1
             exp1=(ex43-ex12)*delwz+ex12
! %%%%%%%     in plane 3:
!  node 5:(i,j+1,k) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1) node 8:(i,j+1,k+1)
!  axis(nd5,nd6)
             ex56=(exk(i+1,j+1,k)-exk(i,j+1,k))*delux+exk(i,j+1,k)
!  axis(nd8,nd7)
             ex87=(exk(i+1,j+1,k+1)-exk(i,j+1,k+1))*delux+exk(i,j+1,
     *             k+1)
!   plane 3
             exp3=(ex87-ex56)*delwz+ex56
!  $$$$$ plane1+plane3
             exp13=(exp3-exp1)*delvy+exp1
! %%%%%    in plane 2:
! node 1: (i,j,k)  node 2:(i+1,j,k) node 5:(i,j+1,k) node 6:(i+1,j+1,k)
! axis (nd1,nd2) : ex12
! axis (nd5,nd6) : ex56
!  plane 2
             exp2=(ex56-ex12)*delvy+ex12
!  %%%%%%    in plane 5
!  node 4:(i,j,k+1) node 3:(i+1,j,k+1) node 8:(i,j+1,k+1) node 7:(i+1,j+1,k+1)
!   axis(nd4,nd3)
             ex43=(exk(i+1,j,k+1)-exk(i,j,k+1))*delux+exk(i,j,k+1)
!   axis(nd8,nd7)
             ex87=(exk(i+1,j+1,k+1)-exk(i,j+1,k+1))*delux+exk(i,j+1,
     *             k+1)
!  plane 5
             exp5=(ex87-ex43)*delvy+ex43
!  $$$$ plane2+plane5
             exp25=(exp5-exp2)*delwz+exp2
!   &&&& (plane1+plane3)+(plane2+plane5) --> field Ex(u,v,w)
             ext=(exp13+exp25)/2.
! ******* field component Ey
! %%%%%%     in plane 2:
! node 1: (i,j,k)  node 2:(i+1,j,k) node 5:(i,j+1,k) node 6:(i+1,j+1,k)
!  axis(nd1,nd5)
             ey15=(eyk(i,j+1,k)-eyk(i,j,k))*delvy+eyk(i,j,k)
!  axis (nd2,nd6)
             ey26=(eyk(i+1,j+1,k)-eyk(i+1,j,k))*delvy+eyk(i+1,j,k)
!   plane 2
             eyp2=(ey26-ey15)*delu/delx+ey15
! %%%%%%     in plane 5:
!  node 4:(i,j,k+1) node 3:(i+1,j,k+1) node 8:(i,j+1,k+1) node 7:(i+1,j+1,k+1)
!  axis(nd4,nd8)
             ey48=(eyk(i,j+1,k+1)-eyk(i,j,k+1))*delvy+eyk(i,j,k+1)
!  axis(nd3,nd7)
             ey37=(eyk(i+1,j+1,k+1)-eyk(i+1,j,k+1))*delvy+eyk(i+1,j,
     *             k+1)
!   plane 5
             eyp5=(ey37-ey48)*delux+ey48
! $$$$$$ plane2+plane5
             eyp25=(eyp5-eyp2)*delwz+eyp2
! %%%%%%     in plane 6:
!  node 1:(i,j,k) node 5:(i,j+1,k) node 4:(i,j,k+1) node 8:(i,j+1,k+1)
!  axis(nd1,nd5): ey15
!  axis(nd4,nd8): ey48
!  plane 6
             eyp6=(ey48-ey15)*delwz+ey15
! %%%%%%     in plane 4:
!  node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1)
!   axis(nd2,nd6): ey26
!   axis(nd3,nd7): ey37
!    plane 4
             eyp4=(ey37-ey26)*delwz+ey26
! $$$$plane6+plane4
             eyp46=(eyp4-eyp6)*delux+eyp6
!  ��� (plane2+plane5)+(plane4+plane6)--> field Ez(u,v,w)
             eyt=(eyp25+eyp46)/2.
! *******interpollation of the field component Ez
! %%%%%%     in plane 1:
!  node 1:(i,j,k) node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 4:(i,j,k+1)
! axis(nd1,nd4)
             ez14=(ezk(i,j,k+1)-ezk(i,j,k))*delwz+ezk(i,j,k)
! axis(nd2,nd3)
             ez23=(ezk(i+1,j,k+1)-ezk(i+1,j,k))*delwz+ezk(i+1,j,k)
!   plane 1
             ezp1=(ez23-ez14)*delux+ez14
! %%%%%%     in plane 3:
!  node 5:(i,j+1,k) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1) node 8:(i,j+1,k+1)
!  axis (nd5,nd8)
             ez58=(ezk(i,j+1,k+1)-ezk(i,j+1,k))*delwz+ezk(i,j+1,k)
!  axis (nd6,nd7)
             ez67=(ezk(i+1,j+1,k+1)-ezk(i+1,j+1,k))*delwz+ezk(i+1,
     *             j+1,k)
!   plane 3
             ezp3=(ez67-ez58)*delux+ez58
!  $$$$$$ plane1+plane3
             ezp13=(ezp3-ezp1)*delvy+ezp1
! %%%%%%     in plane 6:
!  node 1:(i,j,k) node 5:(i,j+1,k) node 4:(i,j,k+1) node 8:(i,j+1,k+1)
!  axis (nd1,nd4)
             ez14=(ezk(i,j,k+1)-ezk(i,j,k))*delwz+ezk(i,j,k)
!  axis (nd5,nd8)
             ez58=(ezk(i,j+1,k+1)-ezk(i,j+1,k))*delwz+ezk(i,j+1,k)
!   plane 6
             ezp6=(ez58-ez14)*delvy+ez14
! %%%%%%     in plane 4:
!  node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1)
!  axis(nd2,nd3)
             ez23=(ezk(i+1,j,k+1)-ezk(i+1,j,k))*delwz+ezk(i+1,j,k)
!  axis(nd6,nd7)
             ez67=(ezk(i+1,j+1,k+1)-ezk(i+1,j+1,k))*delwz+ezk(i+1,
     *             j+1,k)
!     plane 4
             ezp4=(ez67-ez23)*delvy+ez23
! $$$$$$ plane6+plane4
             ezp64=(ezp4-ezp6)*delux+ezp6
! ������� (P1+P3)+(P6+P4)----> Ez(u,v,w)
             ezt=(ezp13+ezp64)/2.
             insd=insd+1
! calculate kicks in x',y' and z' (energy)
             eztp=ezt*cos(apl)-ext*sin(apl)
             extp=ezt*sin(apl)+ext*cos(apl)
             ezt=eztp
             ext=extp
             gsc=f(7,ic)/xmat
             bsc=sqrt(1.-1./(gsc*gsc))
!omment             cmacrxy=cmacro/(bmoy*bmoy*gmoy*gmoy*gmoy)
!omment             cmacrxy=cmacro/(bsc*bsc*gsc*gsc)
             dxp=const2*ext*dz*cmacrxy*abs(f(9,ic))
             dyp=const2*eyt*dz*cmacrxy*abs(f(9,ic))
             dw=const3*ezt*dz*cmacro*abs(f(9,ic))
! ****test************************************
!omment              dw=dw/gmoy
!  ****************************************
             if(.not.iesp) then
!     load the entrance beam parameters for cavities or gaps
               do js=1,7
                 f(js,ic)=fs(js,ic)
               enddo
               f(3,ic)=f(3,ic)+dxp*1000.
               f(5,ic)=f(5,ic)+dyp*1000.
               f(2,ic)=f(2,ic)-dz1*dxp*100.*xpsc
               f(4,ic)=f(4,ic)-dz1*dyp*100.*xpsc
!omment               f(2,ic)=f(2,ic)-dz1*dxp*100.
!omment               f(4,ic)=f(4,ic)-dz1*dyp*100.
               dwp(ic)=dw
             else
               f(3,ic)=f(3,ic)+dxp*1000.
               f(5,ic)=f(5,ic)+dyp*1000.
               f(7,ic)=f(7,ic)+dw
             endif
           else
!  the particle is not in the mesh
!   computed the beam self-fields as made at the nodes
             ax=0.
             ay=0.
             az=0.
             if(isucc.eq.1) then
               s3=xc(ic)/rms(3,2)
               s2=yc(ic)/rms(2,2)
               s1=zc(ic)/rms(1,2)
               ax=pwtpi*rms(3,2)
               ay=pwtpi*rms(2,2)
               az=pwtpi*rms(1,2)
               rrx=rms(3,2)
               rry=rms(2,2)
               rrz=rms(1,2)
             endif
             if(isucc.eq.2) then
               s3=yc(ic)/rms(3,2)
               s2=zc(ic)/rms(2,2)
               s1=xc(ic)/rms(1,2)
               ax=pwtpi*rms(1,2)
               ay=pwtpi*rms(3,2)
               az=pwtpi*rms(2,2)
               rrx=rms(1,2)
               rry=rms(3,2)
               rrz=rms(2,2)
             endif
             if(isucc.eq.3) then
               s3=zc(ic)/rms(3,2)
               s2=xc(ic)/rms(2,2)
               s1=yc(ic)/rms(1,2)
               ax=pwtpi*rms(2,2)
               ay=pwtpi*rms(1,2)
               az=pwtpi*rms(3,2)
               rrx= rms(2,2)
               rry=rms(1,2)
               rrz=rms(3,2)
             endif
!       storage arrays of the functions in the integrals in tables 75 and 76
!       these values given in table 73 are independent of l, m and n
!       They are stored in: epsi1(i,j),epsi2(i,j), akpc1(i,j), akpc2(i,j),
!          akps1(i,j), akps2(i,j) where i,j are the Gauss positions
             call uvrms
!     field computation
!     loop over the l,m and n
             ext=0.
             eyt=0.
             ezt=0.
             do jn=1,nmax
               jn1=jn-1
               do jm=1,mmax
                 jm1=jm-1
                 do jl=1,lmax
                   jl1=jl-1
!                   if(a(jl,jm,jn).ne.0.) then
                   if(abs(a(jl,jm,jn)).gt.fprec) then
!     in output the SUBROUTINE field returns the values of the FUNCTION E*(l,m,n)
!     shown in tables 77-a-1 to 77-b-2 in x,y and z-directions-->ex,ey,ez
                     call fielde(jl1,jm1,jn1,isucc)
!     the corresonding field components are obtained from tables 67-a to 67-h
                     ext=a(jl,jm,jn)/ax*ex+ext
                     eyt=a(jl,jm,jn)/ay*ey+eyt
                     ezt=a(jl,jm,jn)/az*ez+ezt
                   endif
                 enddo
               enddo
             enddo
             iout=iout+1
!    kicks
!    kicks computation
! calculate kick in x',y' and z' (energy)
!   isochronism correction
             eztp=ezt*cos(apl)-ext*sin(apl)
             extp=ezt*sin(apl)+ext*cos(apl)
             ezt=eztp
             ext=extp
             gsc=f(7,ic)/xmat
             bsc=sqrt(1.-1./(gsc*gsc))
!omment             cmacrxy=cmacro/(bmoy*bmoy*gmoy*gmoy)
!omment             cmacrxy=cmacro/(bsc*bsc*gsc*gsc)
             dxp=const2*ext*dz*cmacrxy*abs(f(9,ic))
             dyp=const2*eyt*dz*cmacrxy*abs(f(9,ic))
             dw=const3*ezt*dz*cmacro*abs(f(9,ic))
             if(.not.iesp) then
!     load the beam at the input at cavities or gaps
               do js=1,7
                 f(js,ic)=fs(js,ic)
               enddo
               f(3,ic)=f(3,ic)+dxp*1000.
               f(5,ic)=f(5,ic)+dyp*1000.
               f(2,ic)=f(2,ic)-dz1*dxp*100.*xpsc
               f(4,ic)=f(4,ic)-dz1*dyp*100.*xpsc
!omment               f(2,ic)=f(2,ic)-dz1*dxp*100.
!omment               f(4,ic)=f(4,ic)-dz1*dyp*100.
               dwp(ic)=dw
             else
               f(3,ic)=f(3,ic)+dxp*1000.
               f(5,ic)=f(5,ic)+dyp*1000.
               f(7,ic)=f(7,ic)+dw
             endif
           endif
! end of if particle not in mesh
           nprint=nprint+1
! end of the loop ic
         enddo
         write(16,*) ' particles in the mesh:',insd,' outside: ',iout
! end of if when ini=2
       endif
!1000   format(4(2x,e12.5))
       return
       end
!> *******************************************************************
!! SUBROUTINE xtypl1(GAMI,SAPHI,QSC,DCG)
!! called by ETGAP and RESTAY
!! INTEGRALS  E(z)*(BG)**-3 *z**n   n=0,1
!! INTEGRALS  dE(z)/dT*(BG)**-3 *z**n   n=0,1,2
!! INTEGRALS FUNCTIONS HA0(Z) and HB0(Z)
!! INTEGRALS OF THE FIRST DERIVATIVES OF HA0(Z) and HB0(Z)
!< *******************************************************************
       SUBROUTINE xtypl1(GAMI,SAPHI,QSC,DCG)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/POSI/IST
       COMMON/JACOB/GAKS,GAPS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *                AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/TYPL1/YH1K0,YH1K1,YP1K1,YP1K2,
     X              YH1K00,YH1K01,YP1K01,YP1K02,
     X              YH10,YH11,YP11,YP12
       COMMON/TYPL2/YH2K0,YH2K1,
     X              YP2K1,YP2K2,
     X              YH2K00,YH2K01,YP2K01,YP2K02,
     X              YH20,YH21,YP21,YP22
!      TRANSVERSAL dE(z)/dt
       COMMON/TYPI1/YE1K0,YE1K1,YE1K2,
     X              YE1KC0,YE1KC1,YE1KC2,
     X              YE10,YE11,YE12
       COMMON/TYPI2/YE2K0,YE2K1,YE2K2,
     X              YE2KC0,YE2KC1,YE2KC2,
     X              YE20,YE21,YE22
       DIMENSION H(17),T(17)
       DATA T /-.990575473,-.950675522,-.880239154,
     1          -.781514004,-.657671159,-.512690537,
     2          -.351231763,-.178484181,  0.,
     3           .178484181, .351231763,.512690537,
     4           .657671159, .781514004,.880239154,
     5           .950675522, .990575473/
       DATA H /.024148303,.055459529,.085036148,
     1         .111883847,.135136368,.154045761,
     2         .168004102,.176562705,.179446470,
     3         .176562705,.168004102,.154045761,
     4         .135136368,.111883847,.085036148,
     5         .055459529,.024148303/
       fprec=epsilon(PHSLIP)
       FH0=FH/VL
       CGI=QSC/XMAT
!     Circular cosinus functions
!     In longitudinal direction
       YH1K0=0.
       YH1K1=0.
       YP1K1=0.
       YP1K2=0.
       YH1K00=0.
       YH1K01=0.
       YP1K01=0.
       YP1K02=0.
       YH10=0.
       YH11=0.
       YP11=0.
       YP12=0.
!      In transverse direction ( dE(z)/dt )
       YE1K0=0.
       YE1K1=0.
       YE1K2=0.
       YE1KC0=0.
       YE1KC1=0.
       YE1KC2=0.
       YE10=0.
       YE11=0.
       YE12=0.
!     Circular sinus functions
!     In longitudinal direction
       YH2K0=0.
       YH2K1=0.
       YP2K1=0.
       YP2K2=0.
       YH2K00=0.
       YH2K01=0.
       YP2K01=0.
       YP2K02=0.
       YH20=0.
       YH21=0.
       YP21=0.
       YP22=0.
!      In transverse direction ( dE(z)/dt )
       YE2K0=0.
       YE2K1=0.
       YE2K2=0.
       YE2KC0=0.
       YE2KC1=0.
       YE2KC2=0.
       YE20=0.
       YE21=0.
       YE22=0.
!    Calculates the integrals
       DTILK=EQVL
       GAM2=GAMI**2
       BETI=SQRT(1. - 1./GAM2 )
       XK1=FH0/BETI
       TILTA2=PHSLIP/(2.*EQVL)
       CGAM10=((GAMI*GAMI-1.)**1.5)/FH0
       PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
       ist=0
       do i=1,17
         ist=ist+1
         XCC= EQVL*(1.+T(I))/2.
         XCC1=XCC+ASDL
         IF(XCC1.GT.DCG) EXIT
         PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.*EQVL)+PAVPH
!       FONCTION GAMMA (Z)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
           GIS =  SIN(XCC*TILTA2)
         ELSE
           GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
           GIS =  XCC/(2.*EQVL)
         ENDIF
         GI=GAMI+GIT * GIS
         BI=SQRT(1.-1./(GI*GI))
!       Derivative of  G0(Z) relative to the equivalent k
         PHIT0K=-DTILK*(1.-XCC/EQVL)/2.
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           GIC =  COS(XCC*TILTA2)
           GAK1 = DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
           GAK2 = SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
           GAK3 = DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.*PHSLIP*EQVL)
           GAK = CGI * SQCTTF* (-GAK1-GAK2+GAK3)
         ELSE
           GAK1 = SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
           GAK = -CGI * SQCTTF* GAK1
         ENDIF
         IF(I.EQ.17) GAKS=GAK
!      Calculate the integrals of  HA0(Z) and HB0(Z)
         XINT=1./(BI*BI*BI*GI*GI*GI)
         PHIT1=PHIT0+XCC*PHSLIP/(2.*EQVL)
         PHTZ0=(XCC/EQVL-.5)*DTILK
         HA0=2.*SQCTTF*COS(PHIT1-PCREST)*XINT
         HB0=2.*SQCTTF*SIN(PHIT1-PCREST)*XINT
!      n=0
!       Longitudinal direction
         YH10=YH10+H(I)*HA0
         YH20=YH20+H(I)*HB0
!        Transverse direction
         YE10=YH20
         YE20=YH10
!      n=1
!        Longitudinal direction
         YH11=YH11+H(I)*HA0*XCC1
         YH21=YH21+H(I)*HB0*XCC1
!        Transverse direction
         YE11=YE11+H(I)*HB0*XCC
         YE21=YE21+H(I)*HA0*XCC
!      n=2
         YE12=YE12+H(I)*HB0*XCC*XCC
         YE22=YE22+H(I)*HA0*XCC*XCC
!      Calculate the integrals of the derivative of HA0(Z)
         DHA01=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.)**2.5)
         DHA02=SQCTTF*COS(PHIT1-PCREST)*GI*GAK/((GI*GI-1.)**2.5)
         DHA03=SQCTTF*SIN(PHIT1-PCREST)/((GI*GI-1.)**1.5)
!      n=0
!      Longitudinal direction
         YH1K00=YH1K00+H(I)*DHA01*6.*CGAM10
         YH1K0=YH1K0+H(I)*(-6.*DHA02+
     X         2.*(PHCRTK-PHTZ0)*DHA03)
!      Transverse direction
         YE2KC0=YH1K00
         YE2K0=YH1K0
!      n=1
!      Longitudinal direction
         YH1K01=YH1K01+H(I)*DHA01*XCC1*6.*CGAM10
         YH1K1=YH1K1+H(I)*XCC1*(-6.*DHA02+
     X        2.*(PHCRTK-PHTZ0)*DHA03)
!      Transverse direction
         YE2KC1=YE2KC1+H(I)*DHA01*XCC*6.*CGAM10
         YE2K1=YE2K1+H(I)*XCC*(-6.*DHA02-
     X       2.*(PHCRTK-PHTZ0)*DHA03)
!      n=2
         YE2KC2=YE2KC2+H(I)*DHA01*XCC*XCC*6.*CGAM10
         YE2K2=YE2K2+H(I)*XCC*XCC*(-6.*DHA02-
     X       2.*(PHCRTK-PHTZ0)*DHA03)
!      INTEGRALS Of  HB0(Z)
         DHB01=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.)**2.5)
         DHB02=SQCTTF*SIN(PHIT1-PCREST)*GI*GAK/((GI*GI-1.)**2.5)
         DHB03=SQCTTF*COS(PHIT1-PCREST)/((GI*GI-1.)**1.5)
!      n=0
!      LONGITUDINAL
         YH2K00=YH2K00+H(I)*DHB01*6.*CGAM10
         YH2K0=YH2K0+H(I)*(-6.*DHB02-
     X          2.*(PHCRTK-PHTZ0)*DHB03)
!      TRANSVERSE
         YE1KC0=YH2K00
         YE1K0=YH2K0
!      n=1
!      LONGITUDINAL
         YH2K01=YH2K01+H(I)*DHB01*XCC1*6.*CGAM10
         YH2K1=YH2K1+H(I)*XCC1*(-6.*DHB02-
     X       2.*(PHCRTK-PHTZ0)*DHB03)
!      TRANSVERSE
         YE1KC1=YE1KC1+H(I)*DHB01*XCC*6.*CGAM10
         YE1K1=YE1K1+H(I)*XCC*(-6.*DHB02-
     X       2.*(PHCRTK-PHTZ0)*DHB03)
!      n=2
         YE1KC2=YE1KC2+H(I)*DHB01*XCC*XCC*6.*CGAM10
         YE1K2=YE1K2+H(I)*XCC*XCC*(-6.*DHB02-
     X       2.*(PHCRTK-PHTZ0)*DHB03)
!      Calculate the integrals of PA0(Z) et PB0(Z)
         PA0=2.*SQCTTF*COS(PHIT1-PCREST)*XINT*XINT
         PB0=2.*SQCTTF*SIN(PHIT1-PCREST)*XINT*XINT
!      n=1
         YP11=YP11+H(I)*PA0*XCC1
         YP21=YP21+H(I)*PB0*XCC1
!      n=2
         YP12=YP12+H(I)*PA0*XCC1*XCC1
         YP22=YP22+H(I)*PB0*XCC1*XCC1
!      Calculate the integrals of the derivatives of PA0(Z)
         DPA01=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.)**4)
         DPA02=SQCTTF*COS(PHIT1-PCREST)*GI*GAK/((GI*GI-1.)**4)
         DPA03=SQCTTF*SIN(PHIT1-PCREST)/((GI*GI-1.)**3)
!      n=1
         YP1K01=YP1K01+H(I)*DPA01*12.*CGAM10*XCC1
         YP1K1=YP1K1+H(I)*XCC1*(-12.*DPA02+
     X         2.*(PHCRTK-PHTZ0)*DPA03)
!      n=2
         YP1K02=YP1K02+H(I)*DPA01*12.*CGAM10*XCC1*XCC1
         YP1K2=YP1K2+H(I)*XCC1*XCC1*(-12.*DPA02 +
     X         2.*(PHCRTK-PHTZ0)*DPA03)
!      INTEGRALES DERIVES PB0(Z)
         DPB01=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.)**4)
         DPB02=SQCTTF*SIN(PHIT1-PCREST)*GI*GAK/((GI*GI-1.)**4)
         DPB02=DPB02
         DPB03=SQCTTF*COS(PHIT1-PCREST)/((GI*GI-1.)**3)
!      n=1
         YP2K01=YP2K01+H(I)*DPB01*12.*CGAM10*XCC1
         YP2K1=YP2K1+H(I)*XCC1*(-12.*DPB02-
     X         2.*(PHCRTK-PHTZ0)*DPB03)
!      n=2
         YP2K02=YP2K02+H(I)*DPB01*12.*CGAM10*XCC1*XCC1
         YP2K2=YP2K2+H(I)*XCC1*XCC1*(-12.*DPB02 -
     X         2.*(PHCRTK-PHTZ0)*DPB03)
       enddo
!    in COS
!     LONGITUDINAL INTEGRALS
       YH1K00=YH1K00/2. *EQVL
       YH1K01=YH1K01/2. *EQVL
       YH1K0=YH1K0/2. *EQVL
       YH1K1=YH1K1/2. *EQVL
       YP1K1=YP1K1/2. *EQVL
       YP1K2=YP1K2/2. *EQVL
       YP1K01=YP1K01/2. *EQVL
       YP1K02=YP1K02/2. *EQVL
       YH10=YH10*EQVL/2.
       YH11=YH11*EQVL/2.
       YP11=YP11*EQVL/2.
       YP12=YP12*EQVL/2.
!     Transverse integrals
       YE1K0=YE1K0/2. *EQVL
       YE1KC0=YE1KC0/2. *EQVL
       YE1K1=YE1K1/2. *EQVL
       YE1KC1=YE1KC1/2. *EQVL
       YE1K2=YE1K2/2. *EQVL
       YE1KC2=YE1KC2/2. *EQVL
       YE10=YE10*EQVL/2.
       YE11=YE11*EQVL/2.
       YE12=YE12*EQVL/2.
!    in SIN
!     LONGITUDINAL INTEGRALS
       YH2K00=YH2K00/2. *EQVL
       YH2K01=YH2K01/2. *EQVL
       YH2K0=YH2K0/2. *EQVL
       YH2K1=YH2K1/2. *EQVL
       YP2K1=YP2K1/2. *EQVL
       YP2K2=YP2K2/2. *EQVL
       YP2K01=YP2K01/2. *EQVL
       YP2K02=YP2K02/2. *EQVL
       YH20=YH20*EQVL/2.
       YH21=YH21*EQVL/2.
       YP21=YP21*EQVL/2.
       YP22=YP22*EQVL/2.
!     TRANSVERSE INTEGRALS
       YE2K0=YE2K0/2. *EQVL
       YE2KC0=YE2KC0/2. *EQVL
       YE2K1=YE2K1/2. *EQVL
       YE2KC1=YE2KC1/2. *EQVL
       YE2K2=YE2K2/2. *EQVL
       YE2KC2=YE2KC2/2. *EQVL
       YE20=YE20*EQVL/2.
       YE21=YE21*EQVL/2.
       YE22=YE22*EQVL/2.
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE chasel
!! analysis of emittance by elimination of remote particles in the
!! z-direction
!< *******************************************************************
       SUBROUTINE chasel
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       LOGICAL CHASIT
       common/etchas/fractx,fracty,fractl
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/pool/zl(iptsz),ipin(iptsz)
       if(fractl.ge.1.) return
       do i=1,ngood
         ichas(i)=1
         zl(i)=0.
         ipin(i)=1
       enddo
       nl=int(float(ngood)*fractl)
       inz=0
       imaxf=ngood
       inx=0
!  ellipsoid of concentration (phase-dispersion)
       tx2=0.
       txp2=0.
       txxp=0.
       fprec=epsilon(txxp)       
       do i=1,ngood
         tx2=tx2+f(6,i)*f(6,i)
         txp2=txp2+fd(i)*fd(i)
         txxp=txxp+f(6,i)*fd(i)
       enddo
       tx2=tx2/float(ngood)
       txp2=txp2/float(ngood)
       txxp=txxp/float(ngood)
       delxxp=tx2*txp2-txxp*txxp
       ikept=0
       do i=1,ngood
         theta=pi/2.
         if(abs(fd(i)).gt.fprec)theta=atan(f(6,i)/fd(i))
         rpart=f(6,i)*f(6,i)+fd(i)*fd(i)
         cost=cos(theta)
         cos2=cost*cost
         sint=sin(theta)
         sin2=sint*sint
         denom=tx2*cos2+txp2*sin2-2.*txxp*cost*sint
         relpse=1.5*delxxp/denom
         if(fractl .ge. 0.97) then
           relpse=3.5*delxxp/denom
         else
           if(fractl .ge. 0.95) relpse=3.*delxxp/denom
         endif
         if(rpart.le.relpse) then
           ipin(i)=0
           ikept=ikept+1
         endif
       enddo
       write(16,*) ' CHASEL: keep',100.*fractl,'  % of ',ngood,
     *             ' particles; chase ',ngood-int(fractl*ngood),
     *            ' from the ',ngood-ikept,' most outlying particles'
       do j=1,ngood
         if(ipin(j).eq.1) then
           inz=inz+1
           if(imaxf.le.nl) go to 9990
           imaxx=0
           tx=0.
           txp=0.
           txxp=0.
           tx2=0.
           txp2=0.
           do i=1,ngood
             if(ichas(i).eq.1) then
               tx=f(6,i)+tx
               txp=fd(i)+txp
               tx2=tx2+f(6,i)*f(6,i)
               txp2=txp2+fd(i)*fd(i)
               txxp=txxp+f(6,i)*fd(i)
               imaxx=imaxx+1
             endif
           enddo
           tx=tx/float(imaxx)
           txp=txp/float(imaxx)
           tx2=tx2/float(imaxx)
           txp2=txp2/float(imaxx)
           txxp=txxp/float(imaxx)
           xcg=tx
           zcg=txp
!       betatron parameters
           xxl=tx2-tx*tx
           zzl=txp2-txp*txp
           xzl=txxp-tx*txp
           if(inz.ne.1) then
             flcrit=2.*fl2rms*log(2.*imaxx)
             if(zlma.lt.flcrit) goto 7770
           endif
           emil=sqrt(xxl*zzl-xzl*xzl)
           if (abs(emil).le.fprec) then
             al=0.
             bl=0.
             cl=0.
           else
             bl=sqrt(xxl/emil)
             cl=1./bl
             al=-xzl/emil
           endif
           tlx0=tx
           tlz0=txp
7770       fl2rms=(1.+al*al)*xxl/bl+2.*al*xzl+bl*zzl
           zlma=0.
           do i=1,ngood
             zl(i)=0.
             if(ichas(i).eq.1) then
               psx=f(6,i)-tlx0
               psz=fd(i)-tlz0
               zl(i)=psx*psx*cl*cl+(psx*al/bl+psz*bl)**2
               if (zlma.lt.zl(i)) then
                 zlma=zl(i)
                 izlma=i
               endif
             endif
           enddo
!    particle is eliminated
           imaxf=0
           if (abs(zlma).le.fprec) zlma=1.e10
           do i=1,ngood
             if(ichas(i).eq.1 .and. zl(i).lt.zlma) then
               imaxf=imaxf+1
             else
               ichas(i)=0
             endif
           enddo
         endif
       enddo
9990   continue
!       write(16,*) ' CHASEL:',imaxf,' retained'
       return
       end
!> *******************************************************************
!! SUBROUTINE chasex
!! analysis of emittance by elimination of remote particles in the
!! x-direction
!< *******************************************************************
       SUBROUTINE chasex
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       LOGICAL CHASIT
       common/etchas/fractx,fracty,fractl
       common/pool/zl(iptsz),ipin(iptsz)
       if(fractx.ge.1.) return
       do i=1,ngood
         ichas(i)=1
         zl(i)=0.
         ipin(i)=1
       enddo
       nl=int(float(ngood)*fractx)
       inz=0
       imaxf=ngood
       inx=0
!  ellipsoid of concentration (x-xp)
       tx2=0.
       txp2=0.
       txxp=0.
       fprec=epsilon(txxp)       
       do i=1,ngood
         f2=f(2,i)*1.e-02
         f3=f(3,i)*1.e-03
         tx2=tx2+f2*f2
         txp2=txp2+f3*f3
         txxp=txxp+f2*f3
       enddo
       tx2=tx2/float(ngood)
       txp2=txp2/float(ngood)
       txxp=txxp/float(ngood)
       delxxp=tx2*txp2-txxp*txxp
       ikept=0
       do i=1,ngood
         theta=pi/2.
         f2=f(2,i)*1.e-02
         f3=f(3,i)*1.e-03
         if(abs(f3).gt.fprec)theta=atan(f2/f3)
         rpart=f2*f2+f3*f3
         cost=cos(theta)
         cos2=cost*cost
         sint=sin(theta)
         sin2=sint*sint
         denom=tx2*cos2+txp2*sin2-2.*txxp*cost*sint
         relpse=1.5*delxxp/denom
         if(fractx.ge..97) then
           relpse=3.5*delxxp/denom
         else
           if(fractx.ge..95) relpse=3.*delxxp/denom
         endif
         if(rpart.le.relpse) then
           ipin(i)=0
           ikept=ikept+1
         endif
       enddo
       write(16,*) ' CHASEX: keep',100.*fractx,'  % of ',ngood,
     *             ' particles; chase ',ngood-int(fractx*ngood),
     *            ' from the ',ngood-ikept,' most outlying particles'
       do j=1,ngood
         if(ipin(j).eq.1) then
           inz=inz+1
           if(imaxf.le.nl) go to 9990
           imaxx=0
           tx=0.
           txp=0.
           txxp=0.
           tx2=0.
           txp2=0.
           do i=1,ngood
             if(ichas(i).eq.1) then
               tx=f(2,i)+tx
               txp=f(3,i)+txp
               tx2=tx2+f(2,i)*f(2,i)
               txp2=txp2+f(3,i)*f(3,i)
               txxp=txxp+f(2,i)*f(3,i)
               imaxx=imaxx+1
             endif
           enddo
           tx=tx/float(imaxx)
           txp=txp/float(imaxx)
           tx2=tx2/float(imaxx)
           txp2=txp2/float(imaxx)
           txxp=txxp/float(imaxx)
           xcg=tx
           zcg=txp
!       betatron parameters
           xxl=tx2-tx*tx
           zzl=txp2-txp*txp
           xzl=txxp-tx*txp
           if(inz.ne.1) then
             flcrit=2.*fl2rms*log(2.*imaxx)
             if(zlma.lt.flcrit) goto 7770
           endif
           emil=sqrt(xxl*zzl-xzl*xzl)
           if (abs(emil).le.fprec) then
             al=0.
             bl=0.
             cl=0.
           else
             bl=sqrt(xxl/emil)
             cl=1./bl
             al=-xzl/emil
           endif
           tlx0=tx
           tlz0=txp
7770       fl2rms=(1.+al*al)*xxl/bl+2.*al*xzl+bl*zzl
           zlma=0.
           do i=1,ngood
             zl(i)=0.
             if(ichas(i).eq.1) then
               psx=f(2,i)-tlx0
               psz=f(3,i)-tlz0
               zl(i)=psx*psx*cl*cl+(psx*al/bl+psz*bl)**2
               if (zlma.lt.zl(i)) then
                 zlma=zl(i)
                 izlma=i
               endif
             endif
           enddo
!    particle is eliminated
           imaxf=0
           if (abs(zlma).le.fprec) zlma=1.e10
           do i=1,ngood
             if(ichas(i).eq.1 .and. zl(i).lt.zlma) then
               imaxf=imaxf+1
             else
               ichas(i)=0
             endif
           enddo
         endif
       enddo
9990   continue
       return
       end
!> *******************************************************************
!! SUBROUTINE chase
!! analysis of emittance by elimination of remote particles
!! read the parameters and print them out
!< *******************************************************************
       SUBROUTINE chase
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       common/tapes/in,ifile,meta,ierr
       common/etchas/fractx,fracty,fractl
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/files/mcselect,mc
       LOGICAL CHASIT,mcselect
       character*(2) mc
       character*(80) myfile
       myfile='chase_emith.out'
       if(mcselect) myfile='mc'//mc//'chase_emith.out'       
       READ(in,*)FRACTX,FRACTY,FRACTL
       WRITE(16,1) FRACTX*100.,FRACTY*100.,FRACTL*100.
1      FORMAT('    ARE KEPT IN THE BUNCH ',/,
     X         '       (x,xp)   : ',F7.3,' %',/,
     X         '       (y,yp)   : ',F7.3,' % ',/,
     X         '       (w,phase): ',F7.3,' %')
! write heading for the reduced_emit.dat file; emmittances are RMS
       open(44,file=myfile,status='unknown')
       WRITE(44,'(A,A,A,A,A,A)') '#    z(m)      % in H  ',
     *       '  Wcog(MeV)     PHIcog(deg)',
     *       '  Eh(mm.mrad)   Ev(mm.mrad)   El(kev.ns)',
     *       '  #remain ngood   xmin(mm)      xmax(mm)      ymin(mm)',
     *       '      ymax(mm)      tmin(s)       tmax(s)     ',
     *       '  Wmin(MeV)     Wmax(MeV)'
       myfile='chase_emitv.out'
       if(mcselect) myfile='mc'//mc//'chase_emitv.out'       
       open(45,file=myfile,status='unknown')
       WRITE(45,'(A,A,A,A,A,A)') '#    z(m)      % in V  ',
     *       '  Wcog(MeV)     PHIcog(deg)',
     *       '  Eh(mm.mrad)   Ev(mm.mrad)   El(kev.ns)',
     *       '  #remain ngood   xmin(mm)      xmax(mm)      ymin(mm)',
     *       '      ymax(mm)      tmin(s)       tmax(s)     ',
     *       '  Wmin(MeV)     Wmax(MeV)'
       myfile='chase_emitl.out'
       if(mcselect) myfile='mc'//mc//'chase_emitl.out'       
       open(46,file=myfile,status='unknown')
       WRITE(46,'(A,A,A,A,A,A)') '#    z(m)      % in L  ',
     *       '  Wcog(MeV)     PHIcog(deg)',
     *       '  Eh(mm.mrad)   Ev(mm.mrad)   El(kev.ns)',
     *       '  #remain ngood   xmin(mm)      xmax(mm)      ymin(mm)',
     *       '      ymax(mm)      tmin(s)       tmax(s)     ',
     *       '  Wmin(MeV)     Wmax(MeV)'
       CHASIT=.FALSE.
       if(fractx.lt.1.) CHASIT=.TRUE.
       if(fracty.lt.1.) CHASIT=.TRUE.
       if(fractl.lt.1.) CHASIT=.TRUE.
       if(CHASIT) then
       else
         WRITE(16,*) 'All 3 fractions are set to 100%, CHASE disabled' 
       endif
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE chasey
!! analysis of emittance by elimination of remote particles in the
!! y-direction
!< *******************************************************************
       SUBROUTINE chasey
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       LOGICAL CHASIT
       common/etchas/fractx,fracty,fractl
       common/pool/zl(iptsz),ipin(iptsz)
       if(fracty.ge.1.) return
       do i=1,ngood
         ichas(i)=1
         zl(i)=0.
         ipin(i)=1
       enddo
       nl=int(float(ngood)*fracty)
       imaxf=ngood
!  ellipsoid of concentration (y-yp)
       ty2=0.
       typ2=0.
       tyyp=0.
       fprec=epsilon(tyyp)       
       do i=1,ngood
         f4=f(4,i)*1.e-02
         f5=f(5,i)*1.e-03
         ty2=ty2+f4*f4
         typ2=typ2+f5*f5
         tyyp=tyyp+f4*f5
       enddo
       ty2=ty2/float(ngood)
       typ2=typ2/float(ngood)
       tyyp=tyyp/float(ngood)
       delyyp=ty2*typ2-tyyp*tyyp
       ikept=0
       do i=1,ngood
         f4=f(4,i)*1.e-02
         f5=f(5,i)*1.e-03
         theta=pi/2.
         if(abs(f5).gt.fprec)theta=atan(f4/f5)
         rpart=f4*f4+f5*f5
         cost=cos(theta)
         cos2=cost*cost
         sint=sin(theta)
         sin2=sint*sint
         denom=ty2*cos2+typ2*sin2-2.*tyyp*cost*sint
         relpse=2.5*delyyp/denom
         if(fracty.ge..97) then
           relpse=3.5*delyyp/denom
         else
           if(fracty.ge..95) relpse=3.*delyyp/denom
         endif
         if(rpart.le.relpse) then
           ipin(i)=0
           ikept=ikept+1
         endif
       enddo
       write(16,*) ' CHASEY: keep',100.*fracty,'  % of ',ngood,
     *             ' particles; chase ',ngood-int(fracty*ngood),
     *            ' from the ',ngood-ikept,' most outlying particles'
       inz=0
       do j=1,ngood
         if(ipin(j).eq.1) then
           inz=inz+1
           if(imaxf.le.nl) go to 9990
           imaxx=0
           ty=0.
           typ=0.
           tyyp=0.
           ty2=0.
           typ2=0.
           do i=1,ngood
             if(ichas(i).eq.1) then
               ty=f(4,i)+ty
               typ=f(5,i)+typ
               ty2=ty2+f(4,i)*f(4,i)
               typ2=typ2+f(5,i)*f(5,i)
               tyyp=tyyp+f(4,i)*f(5,i)
               imaxx=imaxx+1
             endif
           enddo
           ty=ty/float(imaxx)
           typ=typ/float(imaxx)
           ty2=ty2/float(imaxx)
           typ2=typ2/float(imaxx)
           tyyp=tyyp/float(imaxx)
           xcg=ty
           zcg=typ
!       betatron parameters
           xxl=ty2-ty*ty
           zzl=typ2-typ*typ
           xzl=tyyp-ty*typ
           if(inz.ne.1) then
             flcrit=2.*fl2rms*log(2.*imaxx)
             if(zlma.lt.flcrit) goto 7770
           endif
           emil=sqrt(xxl*zzl-xzl*xzl)
           if (abs(emil).le.fprec) then
             al=0.
             bl=0.
             cl=0.
           else
             bl=sqrt(xxl/emil)
             cl=1./bl
             al=-xzl/emil
           endif
           tlx0=ty
           tlz0=typ
7770       fl2rms=(1.+al*al)*xxl/bl+2.*al*xzl+bl*zzl
           zlma=0.
           do i=1,ngood
             zl(i)=0.
             if(ichas(i).eq.1) then
               psx=f(4,i)-tlx0
               psz=f(5,i)-tlz0
               zl(i)=psx*psx*cl*cl+(psx*al/bl+psz*bl)**2
               if (zlma.lt.zl(i)) then
                 zlma=zl(i)
                 izlma=i
               endif
             endif
           enddo
!    particle is eliminated
           imaxf=0
           if (abs(zlma).le.fprec) zlma=1.e10
           do i=1,ngood
             if(ichas(i).eq.1 .and. zl(i).lt.zlma) then
               imaxf=imaxf+1
             else
               ichas(i)=0
             endif
           enddo
         endif
       enddo
9990   continue
       return
       end
!> *******************************************************************
!! SUBROUTINE corre(n,nall)
!! correction over the beam generated by MONTE
!< *******************************************************************
       SUBROUTINE corre(n,nall)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON /COM4/CORD(IPTSZ,6)
       DIMENSION A(6,6),B(6,6),C(6,6),D(6),E(6),F(6),G(6)
       DO I =1,6
         D(I)=0.0
         E(I)=0.0
         F(I)=0.0
         G(I)=0.0
         DO J =1,6
           A(I,J)=0.0
           B(I,J)=0.0
           C(I,J)=0.0
         ENDDO
       ENDDO
       DO J =1,6
         DO I =1,N
           D(J)=D(J)+CORD(I,J)
         ENDDO
         D(J)=D(J)/N
       ENDDO
       DO J =1,6
         DO I=1,NALL
           CORD(I,J)=CORD(I,J)-D(J)
         ENDDO
       ENDDO
       DO J=1,6
         DO K=1,J
           DO I=1,N
             A(J,K)=A(J,K)+ CORD(I,J)*CORD(I,K)
           ENDDO
           A(J,K)=A(J,K)/N
         ENDDO
       ENDDO
! WE MAKE MATRIX A=B*BT WHERE B,BT ARE TRIANGULAR
       DO I=1,6
         DO J=1,I
           H=A(I,J)
           J1=J-1
           IF(J.NE.1) then
             DO K=1,J1
               H=H-A(I,K)*A(J,K)
             ENDDO
           ENDIF
           IF(I.NE.J) THEN
             A(I,J)=H/A(J,J)
           ELSE
             A(I,J)=SQRT(H)
           ENDIF
           B(I,J)=A(I,J)
         ENDDO
       ENDDO
!  WE INVERT B TO GIVE AN UPDATED B
       E(1)=1.0/B(1,1)
       DO I=2,6
         E(I)= 1.0/B(I,I)
         J1=I-1
         DO JJ=1,J1
           J=I-JJ
           J3=J+1
           S=0.0
           IF(JJ.NE.1) THEN
             DO K=J3,J1
               S=S-B(K,I)*B(K,J)
             ENDDO
           ENDIF
           B(J,I)=(S-B(I,J)*E(I))/B(J,J)
         ENDDO
       ENDDO
       DO I=1,6
         B(I,I)=E(I)
       ENDDO
       DO I=1,6
         DO J=1,I
           DUM=B(I,J)
           B(I,J)=B(J,I)
           B(J,I)=DUM
         ENDDO
       ENDDO
!  WE CONVERT CORD(**) SO THAT ITS SIGMA MATRIX IS UNITY
       DO I=1,NALL
         DO K=1,6
           F(K)=0.0
           DO J=1,K
             F(K)=F(K)+ B(K,J)*CORD(I,J)
           ENDDO
         ENDDO
         DO K=1,6
           CORD(I,K)=F(K)
         ENDDO
       ENDDO
! WE TEST THE MEANS AND SIGMA MATRIX
       DO J=1,6
         DO I=1,N
           G(J)=G(J)+CORD(I,J)
         ENDDO
         G(J)=G(J)/N
       ENDDO
       DO J=1,6
         DO I=1,N
           CORD(I,J)=CORD(I,J)-G(J)
         ENDDO
       ENDDO
       DO J=1,6
         DO K=1,6
           DO I=1,N
             C(J,K)=C(J,K)+ CORD(I,J)*CORD(I,K)
           ENDDO
           C(J,K)=C(J,K)/N
         ENDDO
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE pintim
!! Shifts particle coordinates to a single point in time. Uses a
!! linear shift Divide by 100 to convert from cm to meters
!! called by SCHEFF or SCHERM
!< *******************************************************************
       SUBROUTINE pintim
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON/PART/XC(iptsz),YC(iptsz),ZC(iptsz)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/AZLIST/ICONT,IPRIN
       grmoy=0.
       trmoy=0.
       xbax=0.
       do i=1,ngood
         grmoy=grmoy+f(7,i)/xmat
         trmoy=trmoy+f(6,i)
         xbax=xbax+f(2,i)
       enddo
       trmoy=trmoy/float(ngood)
       grmoy=grmoy/float(ngood)
       brmoy=sqrt(1.-1./(grmoy*grmoy))
       xbax=xbax/float(ngood)
       apl=0.
!  Isochronism correction  (bending magnet) only with SCHERM
!    does not work with  with SCHEFF  (iscsp=3)
       if(iscsp.eq.2) then
         xb2x=0.
         xb2z=0.
         xbxz=0.
         do np=1,ngood
           gpai=f(7,np)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           zc(np)=(trmoy-f(6,np))*bpai*vl/100.
           xc(np)=(f(2,np)-xbax)/100.
           xb2z=xb2z+zc(np)*zc(np)
           xb2x=xb2x+xc(np)*xc(np)
           xbxz=xbxz+zc(np)*xc(np)
         enddo
         xb2z=xb2z/float(ngood)
         xb2x=xb2x/float(ngood)
         xbxz=xbxz/float(ngood)
         apl=atan(-2.*xbxz/(xb2x-xb2z))/2.
         write(16,*) 'slope of the bunch in plane(Oz,Ox):',apl,
     *               ' radian'
       endif
       do np=1,ngood
         gpai=f(7,np)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
!      iscsp = 3 Lorentz transformation (only with scheff)
!omment         if(iscsp.eq.3) znp=(trmoy-f(6,np))*bpai*vl*grmoy
!omment         if(iscsp.eq.2) znp=(trmoy-f(6,np))*bpai*vl
         znp=(trmoy-f(6,np))*bpai*vl
         xnp=f(2,np)
         zc(np)=znp*cos(apl)+xnp*sin(apl)
         xnp=xnp*cos(apl)-znp*sin(apl)
!        convert from mrad to rad
         f3=f(3,np)*1.e-03
         f5=f(5,np)*1.e-03
!        convert from cm   to m
         xc(np)=(xnp+zc(np)*f3)/100.
         yc(np)=(f(4,np)+zc(np)*f5)/100.
         zc(np)=zc(np)/100.
       enddo
       xbar=0.
       ybar=0.
       zbar=0.
       do np=1,ngood
!      evaluate xbar , ybar , zbar
         xbar=xbar+xc(np)
         ybar=ybar+yc(np)
         zbar=zbar+zc(np)
       enddo
       xbar=xbar/float(ngood)
       ybar=ybar/float(ngood)
       zbar=zbar/float(ngood)
!  Translate distribution by center of mass coordinates to shift
!  coordinate origin to (0,0,0)
       do np=1,ngood
         xc(np)=xc(np)-xbar
         yc(np)=yc(np)-ybar
         zc(np)=zc(np)-zbar
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE schermi1
!! Called by SCHERMI when the bunch can be represented
!! by a simple ellipse in the longitudinal direction
!< *******************************************************************
       SUBROUTINE schermi1
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
       COMMON/HERMD/AFXM(20),AFYM(20),AFZM(20)
       COMMON/HERMR/AFXR(20),AFYR(20),AFZR(20)
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/ELCG/XCGD,YCGD,ZCGD,XCGR,YCGR,ZCGR
       COMMON/INTGRT/ex,ey,ez
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/CDEK/DWP(iptsz)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/NPART/IMAXR
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/twcst/epsil
       COMMON/BEAMSA/FS(7,iptsz)
       COMMON/DCSPA/IESP
       COMMON/CMPTE/IELL
       COMMON/CGRMS/xsum,ysum,zsum
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/DIMENS/zcp(iptsz),xcp(iptsz),ycp(iptsz)
       common/posc/xpsc
       LOGICAL ichaes,iesp
       dimension afx(20),afy(20)
       fprec=epsilon(beamc)
!       IF (beamc.eq.0. .OR. scdist.eq.0.) return
       IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return
       IELL=IELL+1
       imaxf=ngood
       wavel=2.*pi*vl/fh
       xmass=xmat*1.78267581E-30
       NMAXY=5
       dxp=0.
       dyp=0.
       dw=0.
       dz=scdist/100.
       dz1=dz
       if(ngood.eq.0) then
         write(16,*) ' All the particles are lost '
         stop
       endif
! xi in Amps, beamc in mA
! epsilon =(coul*coul)/nt*(m*m)
       epsil=8.854189586e-12
       c1=1./(3.*pi*sqrt(5.))
       cl=vl/100.
! charge per macro particle
!omment       const1=c1*xi*xi*wavel*wavel/(10000.*imaxf*xmass*
!             *         epsilon*cl*cl*cl*cl)
       const3=1.E-06
       const2=1.E-06/xmat
! calculate rms beam size for beam in one point in time
       CALL sizrms(0,xrms,yrms,zrms,zz)
!6875   format(2x,e12.5,2x,e12.5,2x,e12.5)
       xrmsp=xrms
       yrmsp=yrms
       zrmsp=zrms
       CALL sizcor(ect,xrms,yrms,zrms,0)
       xrmsc=xrms
       yrmsc=yrms
       zrmsc=zrms
       xrms1=xrmsp
       yrms1=yrmsp
       zrms1=zrmsp
       xrms=xrmsp
       yrms=yrmsp
       zrms=zrmsp
       xcgd=xsum
       ycgd=ysum
       zcgd=zsum
       do i=1,ngood
         ZCP(I)=ZC(I)
         XCP(I)=XC(I)
         YCP(I)=YC(I)
       enddo
!      limits in z-direction
       zmat=0.
       zmit=1000.
       do i=1,ngood
         IF(ZCP(I).GE.ZMAT) ZMAT=ZCP(I)
         IF(ZCP(I).LT.ZMIT) ZMIT=ZCP(I)
       enddo
       zmat=zmat/zrms
       zmit=zmit/zrms
!    extends zmat
       zmat=zmat+zmat*.50
       zmit=zmit+zmit*.50
       if(zmat.gt.ect) zmat=ect
       if(abs(zmit).gt.ect) zmit=-ect
!    Hermite coefficients in x and y-direction
       nmaz=0
!6876   format(2x,i3,2x,i3)
       do k=1,20
         afzt(k)=0.
         afxt(k)=0.
         afyt(k)=0.
         afzm(k)=0.
         afxm(k)=0.
         afym(k)=0.
       enddo
       do k=1,nmaxy
         kap=k-1
         do j=1,ngood
           xcoup=abs(xcp(j)/xrms)
           ycoup=abs(ycp(j)/yrms)
           zcoup=abs(zcp(j)/zrms)
           if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
             xc(j)=xcp(j)/xrmsc
             yc(j)=ycp(j)/yrmsc
             zc(j)=zcp(j)/zrmsc
             afxm(k)=afxm(k)+herm(2*kap,xc(j))
             afym(k)=afym(k)+herm(2*kap,yc(j))
             AFZM(K)=AFZM(K)+HERM(2*KAP,ZC(J))
           endif
         enddo
         afxm(k)=afxm(k)/(fact(2*kap)*sqrt(2.*pi))
         afym(k)=afym(k)/(fact(2*kap)*sqrt(2.*pi))
         AFZm(K)=AFZm(K)/(FACT(2*KAP)*SQRT(2.*PI))
       enddo
       NMAZ=10
!   Hermite coefficients in z-direction
       zcdg=0.
       imaxx=0
       do j=1,ngood
         xcoup=abs(xcp(j)/xrms)
         ycoup=abs(ycp(j)/yrms)
         zcoup=abs(zcp(j)/zrms)
         if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
           zcdg=zcdg+zcp(j)
           imaxx=imaxx+1
         endif
       enddo
       zcdg=zcdg/float(imaxx)
       zsqsum=0.
       zcub=0.
       zcub1=0.
       do j=1,ngood
         xcoup=abs(xcp(j)/xrms)
         ycoup=abs(ycp(j)/yrms)
         zcoup=abs(zcp(j)/zrms)
         if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
           zc(j)=zcp(j)-zcdg
           zsqsum=zsqsum+zc(j)*zc(j)
           zcub=zcub+zc(j)*zc(j)*zc(j)
           zcub1=zcub1+zc(j)
         endif
       enddo
       zrmsz=zsqsum/float(imaxx)
       zrmsz=sqrt(zrmsz)
       zcub3=zcub
       zcub=zcub/(zrmsz*zrmsz*zrmsz)-3.*zcub1/zrmsz
       zcub=zcub/(6.*sqrt(2.*pi))
       do k=1,nmaz
         afzt(k)=0.
         afx(k)=0.
         afy(k)=0.
         kap=k-1
         do j=1,ngood
           xcoup=abs(xcp(j)/xrms)
           ycoup=abs(ycp(j)/yrms)
           zcoup=abs(zcp(j)/zrms)
           if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
             zc(j)=zcp(j)/zrmsc
             xc(j)=xcp(j)/xrmsc
             yc(j)=ycp(j)/yrmsc
             afzt(k)=afzt(k)+herm(kap,zc(j))
             afx(k)=afx(k)+herm(kap,xc(j))
             afy(k)=afy(k)+herm(kap,yc(j))
           endif
         enddo
         afzt(k)=afzt(k)/(fact(kap)*sqrt(2.*pi))
         afx(k)=afx(k)/(fact(kap)*sqrt(2.*pi))
         afy(k)=afy(k)/(fact(kap)*sqrt(2.*pi))
       enddo
! Do Hermite integration to determine Ex,Ey,Ez for each macro particle
! and apply space charge kick. Field components are passed through the
! common INTGRT in units Newton/Coulomb
       DO i=1,ngood
!      reprise coordonnees spaciales pour calcul des champs
         xc(i)=xcp(i)
         yc(i)=ycp(i)
         zc(i)=zcp(i)
         CALL INTGA(i,0)
         ext=ex
         eyt=ey
         ezt=ez
! calculate kick in x',y' and z' (energy)
! calculate kick in x',y' and z' (energy)
!   isochronism correction
         eztp=ezt*cos(apl)-ext*sin(apl)
         extp=ezt*sin(apl)+ext*cos(apl)
         ezt=eztp
         ext=extp
         gsc=f(7,i)/xmat
         bsc=sqrt(1.-1./(gsc*gsc))
!        *  valero
         dxp=const2*ext*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
         dyp=const2*eyt*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
         dw=const3*ezt*dz*abs(f(9,i))/gsc
!        *
         if(.not.iesp) then
!     load the entrance beam in cavities or gaps
           do js=1,7
             f(js,i)=fs(js,i)
           enddo
           f(3,i)=f(3,i)+dxp*1000.
           f(5,i)=f(5,i)+dyp*1000.
           f(2,i)=f(2,i)-dz1*dxp*100.*xpsc
           f(4,i)=f(4,i)-dz1*dyp*100.*xpsc
           dwp(i)=dw
         else
           f(3,i)=f(3,i)+dxp*1000.
           f(5,i)=f(5,i)+dyp*1000.
           f(7,i)=f(7,i)+dw
         endif
       enddo
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE schermi
!! SCHERM space charge method
!! See NIM A 309(1996) 21-40
!< *******************************************************************
       SUBROUTINE schermi
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
       COMMON/HERMD/AFXM(20),AFYM(20),AFZM(20)
       COMMON/HERMR/AFXR(20),AFYR(20),AFZR(20)
       COMMON/HERMRR/AFXRR(20),AFYRR(20),AFZRR(20)
       COMMON/SIZR/XRMS3,YRMS3,ZRMS3,ZCGR3
       COMMON/SIZT/XRMS,YRMS,ZRMS
       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
       COMMON/ELCG/XCGD,YCGD,ZCGD,XCGR,YCGR,ZCGR
       COMMON/INTGRT/ex,ey,ez
       COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
       COMMON/CDEK/DWP(iptsz)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/NPART/IMAXR
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/twcst/epsil
       COMMON/BEAMSA/FS(7,iptsz)
       COMMON/DCSPA/IESP
       COMMON/CMPTE/IELL
       COMMON/CHAMP/FXRMS(10,15),FYRMS(10,15),FZRMS(10,15),NCHAMP(10),
     X NCCHAM(10),NCHPAS,JCHAM,ITYE
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/posc/xpsc
       LOGICAL ichaes,iesp
! *************************************************
!      nquad : number of quad in the transport line
       COMMON /CHQUA/ICQD,nquad
       LOGICAL ICQD
! *************************************************
       COMMON/DIMENS/zcp(iptsz),xcp(iptsz),ycp(iptsz)
       fprec=epsilon(beamc)
!       IF (beamc.eq.0. .OR. scdist.eq.0.) return
       IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return
!    dummy: in order to have the same entry as HERSC and SCHEFF
! Initialize some constants and variables c wavel in cm
       ect=4.
       call shuffle
       call pintim
       IELL=IELL+1
       imaxf=ngood
       wavel=2.*pi*vl/fh
       xmass=xmat*1.78267581E-30
       NMAZ=14
       NMAZR=8
       NMAXY=4
       dxp=0.
       dyp=0.
       dw=0.
       dz=scdist/100.
       dz1=dz
       zsot1=0.
       if(ngood.eq.0) then
         write(16,*) ' all the particles are lost '
         stop
       endif
       WRITE(16,*)' call SCHERM N: ',iell
! xi in Amps, beamc in mA
! epsilon =(coul*coul)/nt*(m*m)
       epsil=8.854189586e-12
       c1=1./(3.*pi*sqrt(5.))
       cl=vl/100.
! charge per macro particle
       const3=1.E-06
       const2=1.E-06/xmat
!  normalized emittances(normalized) in m.radian
! calculate rms beam size for beam in one point in time
       CALL sizrms(0,xrms,yrms,zrms,zz)
       xrmsp=xrms
       yrmsp=yrms
       zrmsp=zrms
       CALL sizcor(ect,xrms,yrms,zrms,0)
       write(16,*) ' bunch RMS(m): ',xrms,yrms,zrms
!6875   format(2x,e12.5,2x,e12.5,2x,e12.5)
       xrmsc=xrms
       yrmsc=yrms
       zrmsc=zrms
       xrms=xrmsp
       yrms=yrmsp
       zrms=zrmsp
!   Total bunch charge densities in x,y,z
!      calculation of Hermite coefficients
       do i=1,ngood
         zcp(i)=zc(i)
         xcp(i)=xc(i)
         ycp(i)=yc(i)
       enddo
!      limits in z-direction
       zmat=0.
       zmit=1000.
       do i=1,ngood
         if(zcp(i).ge.zmat) zmat=zcp(i)
         if(zcp(i).lt.zmit) zmit=zcp(i)
       enddo
       zmat=zmat/zrms
       zmit=zmit/zrms
!    extend zmat
       zmat=zmat+zmat*.50
       zmit=zmit+zmit*.50
!    (xmat,ymat,zmat) >0
       if(zmat.gt.ect) zmat=ect
       if(abs(zmit).gt.ect) zmat=-ect
!   Hermite coefficients
       do k=1,nmaxy
         afxt(k)=0.
         afyt(k)=0.
         kap=k-1
         do j=1,ngood
           xcoup=abs(xcp(j)/xrms)
           ycoup=abs(ycp(j)/yrms)
           zcoup=abs(zcp(j)/zrms)
           if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
             xc(j)=xcp(j)/xrmsc
             yc(j)=ycp(j)/yrmsc
             afxt(k)=afxt(k)+herm(2*kap,xc(j))
             afyt(k)=afyt(k)+herm(2*kap,yc(j))
           endif
         enddo
         afxt(k)=afxt(k)/(fact(2*kap)*sqrt(2.*pi))
         afyt(k)=afyt(k)/(fact(2*kap)*sqrt(2.*pi))
       enddo
!6876   format(2x,i5,3x,e12.5,3x,e12.5)
       do k=1,nmaz
         afzt(k)=0.
         kap=k-1
         do j=1,ngood
           xcoup=abs(xcp(j)/xrms)
           ycoup=abs(ycp(j)/yrms)
           zcoup=abs(zcp(j)/zrms)
           if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
             zc(j)=zcp(j)/zrms
             afzt(k)=afzt(k)+herm(kap,zc(j))
           endif
         enddo
         afzt(k)=afzt(k)/(fact(kap)*sqrt(2.*pi))
       enddo
!6877   format(3x,e12.5)
!     Look for surface of the bunch
       szbt=snzt(zmit,zmat)
!     Look for the vertex of the distribution n(z)
!        between  0 and zmat/2
       zf=zmat/2.
       zi=0.
       call rchsom(zi,zf,nmaz)
       zsot=(zi+zf)/2.
       zcgd=zsot*zrms
!   Main ellipsoid (in the right of the vertex)
       imaxd=1
       do i=1,ngood
         if(zcp(i).ge.zcgd) then
           xc(imaxd)=xcp(i)
           yc(imaxd)=ycp(i)
           zc(imaxd)=zcp(i)
           imaxd=imaxd+1
         endif
       enddo
       imaxd=imaxd-1
       imaxr=ngood-2*imaxd
       if(imaxr.lt.0) then
! if imaxr<0 => use one ellipse only, rather than 2
         pcent1=float(2*imaxd)/float(ngood)
         pcent2=float(imaxr)/float(ngood)
         if(icqd)NQUAD=NQUAD-1
         iell=iell-1
         write(16,*) ' one ellipsoid in z-direction '
         call pintim
         call schermi1
         return
       endif
       IF(25*IMAXR.LT.IMAXF.OR.IMAXR.LE.30) THEN
         pcent1=float(2*imaxd)/float(ngood)
         pcent2=float(imaxr)/float(ngood)
         iell=iell-1
         if(icqd)NQUAD=NQUAD-1
! if imaxr<.04*imaxf => use one ellipse only, rather than 2
          write(16,*) 'one ellipsoid in z-direction '
         call pintim
         call schermi1
         IF (12*IMAXR.LT.ngood)
     x     write(16,*) 'one ellipsoid in z-direction '
         IF (IMAXR.LE.40)
     x     write(16,*) ' one ellipsoid in z-direction '
         return
       endif
       i1elli=0
!    C.O.G. of the principal ellipsoid (in cm)
!      longitudinal RMS of the pricipal ellipsoid
       zrmss1=sqrt(vaprz(zsot,zmat))
       zrms1=zrmss1*zrms
!   RMS in the transverse directions
       xrms1=xrms
       yrms1=yrms
!      surface n(z)
       szbd=snzd(zsot,zmat)
       rsnz=szbd/szbt
!   coefficients Hermite en x,y,z sur partie droite en z
!    principal ellipsoid
       do k=1,nmaxy
         kap=k-1
         afxm(k)=afxt(k)*rsnz
         afym(k)=afyt(k)*rsnz
         afzm(k)=prinz(zsot,zmat,k,zrmss1)
         afzm(k)=2.*afzm(k)/(fact(2*kap)*sqrt(2.*pi))
       enddo
!    limits in x,y,z of the principal ellipsoid
       do i=1,imaxd
         xc(i)=xc(i)/xrms
         yc(i)=yc(i)/yrms
         zc(i)=zc(i)/zrms
       enddo
       xmam=xc(1)
       ymam=yc(1)
       zmam=zc(1)
       do i=1,imaxd
         if(xc(i).ge.xmam) xmam=xc(i)
         if(yc(i).ge.ymam) ymam=yc(i)
         if(zc(i).ge.zmam) zmam=zc(i)
       enddo
       if(abs(xmam).ge.ect) xmam=ect
       if(abs(ymam).ge.ect) ymam=ect
       if(abs(zmam).ge.ect) zmam=ect
       xmim=xmam
       ymim=ymam
       zmim=zmam
       do i=1,imaxd
         if(xc(i).lt.xmim) xmim=xc(i)
         if(yc(i).lt.ymim) ymim=yc(i)
         if(zc(i).lt.zmim) zmim=zc(i)
       enddo
       if(abs(xmim).ge.ect) xmim=-ect
       if(abs(ymim).ge.ect) ymim=-ect
       if(abs(zmim).ge.ect) zmim=-ect
!      partition commune @ x,y,z
       xymam=ymam
       xymim=ymim
       if(xmam.ge.xymam) xymam=xmam
       if(zmam.ge.xymam) xymam=zmam
       if(xmim.lt.xymim) xymim=xmim
       if(zmim.lt.xymim) xymim=zmim
!      symmetrisation de l'intervalle
       if(abs(xymim).ge.xymam) then
         xymam=abs(xymim)
       else
         xymim=-xymam
       endif
!    vertex of the second ellipsoid
       aa=zmit
       bb=2.*zsot-zmat
       cc=zsot
       dd=zmat
       call rchsor(aa,bb,cc,dd,ee)
! second ellipsoid  around ee
!    sz2e : surface
       zrms2=varia(bb,cc,dd,ee)
       zrms2=sqrt(zrms2)
       zcgr=ee*zrms
       sz2e=codsy(bb,cc,dd,ee,1)
       afzr(1)=sz2e/sqrt(2.*pi)
       stm12=abs(afzt(1)-afzm(1)-afzr(1))
       rs2e=sz2e/szbt
       xrms2=xrms
       yrms2=yrms
       do k=1,nmaxy
         kap=k-1
         afxr(k)=afxt(k)*rs2e
         afyr(k)=afyt(k)*rs2e
         afzr(k)=codsy(bb,cc,dd,ee,k)
         afzr(k)=afzr(k)/(fact(2*kap)*sqrt(2.*pi))
       enddo
!   two ellipsoids:
       if(stm12*10.le.afzr(1)) inint=2
       if(stm12*10.gt.afzr(1)) then
!   3 ellipsoids;the principal ellipsoid,the second ellipsoid is symmetrized
!    the third ellipsoid is defined around the c. of g. of the residu
         ee1=grz(aa,bb,cc,dd,ee)
         if(ee1.gt.ee) then
           inint=2
         else
           zrms3=variz(bb,cc,dd,ee,ee1)
           zrms3=sqrt(zrms3)
           xrms3=xrms
           yrms3=yrms
           zcgr3=ee1*zrms
!      C.O.G. of the second ellipsoid
!        on suppose xcgr et ycgr nuls pour le residu
           xcgr=0.
           ycgr=0.
           sz3e=codif(bb,cc,dd,ee,ee1,1)
           rs3e=sz3e/szbt
!        correction complementaire
           srtot=sz3e/sqrt(2.*pi)+afzr(1)+afzm(1)
           srtot=srtot-afzt(1)
!       HERMITE coefficients over the residual ellipse
           do k=1,nmaxy
             kap=k-1
             afxrr(k)=afxt(k)*rs3e
             afyrr(k)=afyt(k)*rs3e
             afzrr(k)=codif(bb,cc,dd,ee,ee1,k)
             afzrr(k)=afzrr(k)/(fact(2*kap)*sqrt(2.*pi))
             if(k.eq.1) then
               tzrr=afzrr(k)-srtot
               if(tzrr.ge.0..and.abs(tzrr).ge.(afzrr(k)/10.)) then
                 afxrr(k)=afxrr(k)-srtot
                 afyrr(k)=afyrr(k)-srtot
                 afzrr(k)=afzrr(k)-srtot
               endif
             endif
           enddo
! end of calculus of 2nd ellipse
           inint=3
         endif
       endif
       if(ee1.le.ee) zrms3=zrms3*zrms
       zrms2=zrms2*zrms
!    surface of the ellipsoids in pourcent
       write(16,*) ' surface of the ellipsoids in % of the bunch:'
       if(inint.eq.2) then
         pcent1=afzm(1)/afzt(1)
         pcent2=afzr(1)/afzt(1)
         write(16,7777) iell,pcent1,pcent2
       endif
       if(inint.eq.3) then
         pcent1=afzm(1)/afzt(1)
         pcent2=afzr(1)/afzt(1)
         pcent3=afzrr(1)/afzt(1)
         write(16,7778) iell,pcent1,pcent2,pcent3
       endif
7777   format(2x,i4,2x,f7.4,2x,f7.4)
7778   format(2x,i4,2x,f7.4,2x,f7.4,2x,f7.4)
! Do Hermite integration to determine Ex,Ey,Ez for each macro particle
! and apply space charge kick. Field components are passed through the
! common INTGRT in units Newton/Coulomb
!       gsct introduit pour calcul specifique impulsion
       gsct=0.
       igsct=0
       DO i=1,ngood
!      reprise coordonnees spaciales pour calcul des champs
         xc(i)=xcp(i)
         yc(i)=ycp(i)
         zc(i)=zcp(i)
!   principal ellipsoid
         CALL INTGA(i,0)
         ext=ex
         eyt=ey
         ezt=ez
!  second ellipsoid
         CALL INTGA(i,1)
         ext=ext+ex
         eyt=eyt+ey
         ezt=ezt+ez
!  third ellipsoid
         if(inint.eq.3) then
           CALL INTGA(i,2)
           ext=ext+ex
           eyt=eyt+ey
           ezt=ezt+ez
         endif
! calculate kick in x',y' and z' (energy)
!   isochronism correction
         eztp=ezt*cos(apl)-ext*sin(apl)
         extp=ezt*sin(apl)+ext*cos(apl)
         ezt=eztp
         ext=extp
         gsc=f(7,i)/xmat
         gsct=gsct+gsc
         igsct=igsct+1
         bsc=sqrt(1.-1./(gsc*gsc))
         dxp=const2*ext*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
         dyp=const2*eyt*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
         dw=const3*ezt*dz/gsc
         if(.not.iesp) then
!     load the entrance beam parameters for cavities or gaps
           do js=1,7
             f(js,i)=fs(js,i)
           enddo
           f(3,i)=f(3,i)+dxp*1000.
           f(5,i)=f(5,i)+dyp*1000.
           f(2,i)=f(2,i)-dz1*dxp*100.*xpsc
           f(4,i)=f(4,i)-dz1*dyp*100.*xpsc
!omment           f(2,i)=f(2,i)-dz1*dxp*100.
!omment           f(4,i)=f(4,i)-dz1*dyp*100.
           dwp(i)=dw
         else
           f(3,i)=f(3,i)+dxp*1000.
           f(5,i)=f(5,i)+dyp*1000.
           f(7,i)=f(7,i)+dw
         endif
       enddo
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE entre
!! define some input beam characteristics
!!   uem : Rest mass in MeV
!!
!!          proton:938.27231  MeV
!!          H_    :939.3145   MeV
!!          mesons:33.9093    MeV
!!          pions :139.5685   MeV
!!          kaons :493.667    MeV
!!          electrons : 0.511 MeV
!!
!!   atm : Atomic number
!!   qst : charge
!!
!!   enedep: Kinetic energy
!!   tofini: Time of flight
!!
!!   REMARK : After INPUT the reference coincides with the c.o.g.
!< *******************************************************************
       SUBROUTINE entre
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/speda/dave,idave
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/faisc/f(10,iptsz),imax,ngood
       common/objet/fo(9,iptsz),imaxo
       COMMON/HISTO/CENTRE(6)
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/MASTRP/XMA(2,2),XMB(2,2),XMC(2,2)
       COMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/tapes/in,ifile,meta,ierr
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/TILT/TIPHA,TIX,TIY,SHIFW,SHIFP
       COMMON/newtlt/twissa(3),itwiss
       common/tof/tofini
       common/strip/atm,qs,atms,ths,qop,sqst(6),anp,nqst
       common/mcs/imcs,ncstat,cstat(20)
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/trace3e/tracebi(6),traceei(3)
       common/dmp/dmpdat(14)
       character trace3h*128,trace3t*128,tif*128
       logical acpt
       logical dave
!       dimension foo(9)
        DAVE=.FALSE.
       read(in,*)uem,atm,qst
       if(ncstat.eq.1) cstat(1)=qst
!    input energy(MeV) and initial time of flight(deg)
       read(in,*) enedep,tofini
! if icog=0 reference (vref,tref) is not cog
! if icog=1 reference (vref,tref) is cog
! --- xmat= rest mass
       xmat=uem*atm
       write(16,101) uem,atm,xmat,qst
101    format('  **** unit mass: ',e12.5,' MeV mass units: ',
     *     f5.1,' rest mass: ',e12.5,' MeV charge ',f4.1)
       write(16,102)enedep,tofini
102    format('  **** energy: ',e12.5,' MeV initial tof: ',e12.5,
     *        ' deg')
       tmp=tofini
       tofini=tofini*pi/(180.*fh)
       gdep=enedep/xmat+1.
       bdep=sqrt(1.-1./(gdep*gdep))
! trace3d stuff start
       write(tif,901) (tracebi(i),i=1,6)
901    format(' BEAMI(1)= ',5(f12.6,1x),f12.4)
       kt3h=kt3h+1
       trace3h(kt3h)=tif
       write(tif,902) (traceei(i),i=1,3)
902    format(' EMITI(1)= ',f12.6,1x,f12.6,1x,f12.4)
       kt3h=kt3h+1
       trace3h(kt3h)=tif
       write(tif,903) uem*atm,int(qst),fhinit/2./pi/1.E6
903    format(' ER= ',E16.7,', Q=',I3,', FREQ= ',E14.7)
       kt3h=kt3h+1
       trace3h(kt3h)=tif
       write(tif,7001) enedep
7001   format(' W= ',f12.4)
       kt3h=kt3h+1
       trace3h(kt3h)=tif
! fo(index,i), index=1 initial particle # ,
!              index=2 x
!              index=3 xp
!              index=4 y
!              index=5 yp
!              index=6 time of flight (tof)
!              index=7 energy
!              index=8 if = 0 , then particle is lost
!              index=9 charge
!              i= particle #
       do i=1,ngood
! if itwiss=1,  apply tofini in tiltbm routine
         if(itwiss.ne.1) fo(6,i)=fo(6,i)+tofini
         fo(9,i)=qst
         fo(7,i)=enedep+fo(1,i)+xmat
         if(fo(7,i).lt.xmat) fo(7,i)=xmat
         fo(1,i)=float(i)
       enddo
! --- the reference particle and the cog coincide
       bref=0.
       tref=0.
       encog=0.
       do i=1,ngood
         encog=encog+fo(7,i)
         gai=fo(7,i)/xmat
         bref=bref+sqrt(1.-1/(gai*gai))
         tref=tref+fo(6,i)
       enddo
       encog=encog/float(ngood)
       bref=bref/float(ngood)
       vref=bref*vl
       tref=tref/float(ngood)
       vrefi=vref
       trefi=tref
!       pack the table f(,) of the current beam
       do i=1,ngood
         do j=1,9
           f(j,i)=fo(j,i)
         enddo
       enddo
!   momentum of the  reference (i.e. the c.o.g.)
       gcog=1./sqrt(1.-bref*bref)
       boro=3.3356*xmat*bref*gcog/abs(qst)
       write(16,3450) boro
3450   format('  **** momentum of c.o.g. (kG.cm): ',e12.5)
       if (itwiss.eq.1) then
! Beam was defined in MCOBJET with Twiss parameters
! call TILTBM to apply Twiss alpha
         TIPHA=twissa(3)
         TIX=twissa(1)
         TIY=twissa(2)
         SHIFW=.000000
         SHIFP=.000000
         icg=1
         call tiltbm(icg)
!  write the input beam in file 'dynac_in_pr.dst'
         dum=100.
         write(11,*) ngood,dum,fh/(2000000.*pi)
         do i=1,ngood
           f(2,i)=f(2,i)+centre(2)
           f(3,i)=f(3,i)+centre(3)
           f(4,i)=f(4,i)+centre(4)
           f(5,i)=f(5,i)+centre(5)
           f(6,i)=f(6,i)+centre(6)
           f(7,i)=f(7,i)+centre(1)
           etphas=fh*(f(6,i)-tref)
           etener=f(7,i)-xmat
           write(11,777) f(2,i),f(3,i)/1000.,f(4,i),f(5,i)/1000.,
     *                   etphas,etener
         enddo
777      format(6(F13.8,1x))
       else
!  in case of itwiss.ne.1 apply CENTRE and write input beam in TILTBM
         TIPHA=0.
         TIX=0.
         TIY=0.
         SHIFW=.000000
         SHIFP=.000000
         icg=1
         call tiltbm(icg)
       endif
       call emiprt(0)
! store START data for .dmp file
       dmpdat(1)=0.
       dmpdat(2)=100.
       dmpdat(3)=0.
       dmpdat(4)=tmp
       dmpdat(5)=bdep
       dmpdat(6)=enedep
       dmpdat(7)=tref*180.*fh/pi
       dmpdat(8)=bdep
       dmpdat(9)=enedep
! dmpdat(10), dmpdat(11), dmpdat(12) loaded in emiprt
!       dmpdat(13)=0.
!       dmpdat(14)=0.
!       nd=0
!       write(50,*) '# start   Z       trans   ',
!     *   'dummy    TOF(COG)    COG        Wcog          TOF(REF)   ',
!     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
!     *   'El,RMS       dummy         dummy'
!       write(50,*) '#  #     (m)       (%)    ',
!     *  '          (deg)      beta       (MeV)          (deg)      ',
!     *  '   beta       (MeV)       (mm.mrad)    (mm.mrad)    (ns.keV)'
!       write(50,7023) nd,(dmpdat(i),i=1,14)
!7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
!     *   2(e14.7,1x,f7.5,1x,e14.7,1x),7(e12.5,1x))
       return
       end
!> *******************************************************************
!! SUBROUTINE monte
!! random generation of the 6D coordinates of the cloud of particles
!!   LOI : 1 IMAX particles are generated randomly in three phase
!!           plane ellipse with uniform distribution in real space
!!           (x,y,z), then xp,yp, and zp from within each phase-plane
!!           ellipse. z,zp are converted to phi,w
!!   LOI : 2 IMAX particles are generated randomly in a six
!!           dimensional ellipsoid
!!   LOI : 3 IMAX particles are generated randomly in three phase
!!           plane ellipse in real space (x,y,z),with distribution
!!           corrresponding to an equilibrium stationary sphere at the
!!           limit of the of the current acceptable (see help_DYNAC).
!!           Then xp,yp, and zp from within each phase-plane for
!!           each phase-plane ellipse. z,zp are converted to phi,w
!!   LOI : 4 IMAX particles are generated randomly in a six
!!           dimensional ellipsoid from a distribution corresponding
!!           to an equilibrium stationary sphere
!!   LOI : 5 IMAX particles are generated randomly in a six
!!           dimensional cylinder (axis in z-direction)
!!           with uniform distribution in transverse directions
!!   LOI : 6 IMAX particles are generated randomly in a six
!!           dimensional cylinder (axis in z-direction)
!!           with gaussian distribution in transverse directions
!!   ITWISS=1   read Twiss parameters for emittance definition
!!   ITWISS<>1  reading emittance bounderies for upright ellipse
!!
!! This routine uses the CERN random # routine RLUX (named ranlux in
!! the CERN library)
!< *******************************************************************
       SUBROUTINE monte
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/DCSPA/IESP
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON /COM4/CORD(IPTSZ,6)
       common/faisc/f(10,iptsz),imax,ngood
       common/objet/fo(9,iptsz),imaxo
       COMMON/QMOYEN/QMOY
       COMMON/HISTO/CENTRE(6)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       common/ranec1/dummy(6)
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/newtlt/twissa(3),itwiss
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/speda/dave,idave
       common/ragau/ntir
!********************************************
! v28/04/2015
       common/fcont/ifcont
       logical ifcont
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/trace3e/tracebi(6),traceei(3)
       character trace3h*128,trace3t*128,tif*128
       logical iesp,chasit,dave,acpt
!       dimension fn(9,iptsz),foo(9),so(6),vecx(1)
       dimension vecx(1)
       read(in,*)LOI,itwiss
       WRITE(16,*) ' Generate particles based on law ',loi
       if(loi.gt.8) then
         write(ierr,*)' ERROR in GEBEAM: law .gt. 8 invalid !! '
         write(16,*) ' ERROR in GEBEAM: law .gt. 8 invalid !! '
         stop
       endif
       read(in,*)FH,IMAX
       WRITE(16,102) FH
 102   FORMAT(//,30x,' FREQUENCY : ',E12.5,' Hz',//)
       FH=FH*2.*pi
       FHINIT=FH
!   Center of the beam ellipsoid
!    X X' Y Y' Z' Z
       read(in,*)(CENTRE(J),J=2,5),CENTRE(1),CENTRE(6)
       if (itwiss.ne.1) then
         read(in,*)YMAX,TMAX,ZMAX,PMAX,DMAX,TTMAX
         kt3h=kt3h+1
         trace3h(kt3h)='ERROR: GEBEAM ITWISS.NE.1 not yet implemented'
       else
         read(in,*) alphax,betax,emitx
         read(in,*) alphay,betay,emity
         read(in,*) alphaz,betaz,emitz
         gammax=(1.+alphax*alphax)/betax
         gammay=(1.+alphay*alphay)/betay
         ymax=0.1*sqrt(emitx/gammax)
         tmax=sqrt(emitx*gammax)
         zmax=0.1*sqrt(emity/gammay)
         pmax=sqrt(emity*gammay)
         twissa(1)=-alphax*ymax
         twissa(2)=-alphay*zmax
!         if(loi.ne.5) then
         if(loi.lt.5 .or. loi.gt.6) then
           gammaz=(1.+alphaz*alphaz)/betaz
           dmax=0.001*sqrt(emitz*gammaz)
           ttmax=pi*sqrt(emitz/gammaz)/(fh*180.)
           twissa(3)=alphaz*sqrt(emitz/gammaz)
         endif
         if(loi.eq.5 .or. loi.eq.6) then
           dmax=alphaz
           twissa(3)=0.
           ttmax=pi/fh
         endif
         if(loi.eq.6) then
           sig=betaz
           if(sig.lt.1.) then
             write(6,*)'ERROR: BETAZ in GEBEAM equal to zero'
             write(16,*)'ERROR: BETAZ in GEBEAM equal to zero'
             STOP
           endif  
         endif
! store parameters for trace3d, write them in ENTRE
         tracebi(1)=alphax
         tracebi(2)=betax
         tracebi(3)=alphay
         tracebi(4)=betay
         tracebi(5)=alphaz
         tracebi(6)=betaz
         traceei(1)=emitx
         traceei(2)=emity
         traceei(3)=emitz
       endif
! --- beam centre is activated in SUBROUTINE entre
       cph=centre(6)*fh*180/pi
       WRITE(16,123) (CENTRE(J),J=2,5),CENTRE(1),CENTRE(6),cph
123    FORMAT(' *** Beam centre defined as:',/,
     X  4X,' Transverse direction :',/,6X,
     X' HORZ PLANE X(CM) = ',E12.5,'       XP(MRD) = ',E12.5,/,6X,
     X' VERT PLANE Y(CM) = ',E12.5,'       YP(MRD) = ',E12.5,/,4X,
     X' Longitudinal direction :',/,5X,
     X' DELTA ENERGY(MeV) = ',E12.5,'     TIME(SEC) = ',E12.5,/,
     X  41x,' PHASE(DEG) = ',E12.5,//)
       PTMAX=ttmax*fh*180./pi
       if(itwiss.ne.1) then
         WRITE(16,99)YMAX,TMAX,ZMAX,PMAX,DMAX,TTMAX,PTMAX
99       FORMAT(3X,' *** Limits of the random distribution ',/,
     X  4X,' Transverse direction :',/,6X,
     X' HORZ PLANE X(CM) = ',E12.5,'       XP(MRD) = ',E12.5,/,6X,
     X' VERT PLANE Y(CM) = ',E12.5,'       YP(MRD) = ',E12.5,/,4X,
     X' Longitudinal direction :',/,5X,
     X' DELTA ENERGY(MeV) = ',E12.5,'     TIME(SEC) = ',E12.5,/,
     X  41x,' PHASE(DEG) = ',E12.5,//)
       else
!        if(loi.eq.5) then
         if(loi.ge.5) then
           write(16,*) ' Beam distribution based on Twiss parameters'
           write(16,199) alphax,betax,emitx,alphay,betay,emity
           write(16,399) ptmax,dmax
399       format(4x,' Continuous beam in the longitudinal direction :',
     *    /,6x,' half phase length (deg): ',e12.5,/,6x,
     *    ' half energy width (MeV): ',e12.5)
! continuous beam
           ifcont=.true.
         else
           write(16,*) ' Beam distribution based on Twiss parameters'
           write(16,199) alphax,betax,emitx,alphay,betay,emity
199       format(4x,' Transverse direction :',/,6x,
     *    ' Horz plane: alpha: ',e12.5,' beta(mm/mrad): ',e12.5,
     *    ' emit(pi*mm*mrad): ',e12.5,/,6x,
     *    ' Vert plane: alpha: ',e12.5,' beta(mm/mrad): ',e12.5,
     *    ' emit(pi*mm*mrad): ',e12.5)
           write(16,299) alphaz,betaz,emitz
299        format(4x,' Longitudinal direction :',/,6x,
     *    ' alpha: ',e12.5,' beta(deg/keV): ',e12.5,
     *    ' emit(pi*deg*keV): ',e12.5)
         endif
       endif
!     len : starting value of the random vector for the routine rlux
       len=1
       do j=1,6
         cord(1,j)=0.0
       enddo
       if(loi.eq.1) then
         do i=2,imax
           DO
             call rlux(vecx,len)
             r1=2.*vecx(1)-1.
             call rlux(vecx,len)
             r3=2.*vecx(1)-1.
             call rlux(vecx,len)
             r6=2.*vecx(1)-1.
!  make round in x,y,z plane
             rho=r1**2+r3**2+r6**2
             if (rho.le.1.) EXIT
           ENDDO
           DO 
             call rlux(vecx,len)
             r2=2.*vecx(1)-1.
! make beam round in x,x' plane
             if((r1*r1+r2*r2).le.1.) EXIT
           ENDDO
           DO  
             call rlux(vecx,len)
             r4=2.*vecx(1)-1.
!  make beam round in y,yp plane
             if((r4*r4+r3*r3).le.1.) EXIT
           ENDDO
           DO  
             call rlux(vecx,len)
             r5=2.*vecx(1)-1.
!   make beam round in plane z, zp
             if((r6*r6+r5*r5).le.1.) EXIT
           ENDDO  
!        store random numbers in preparation for rms correction
           cord(i,1)=r1
           cord(i,2)=r2
           cord(i,3)=r3
           cord(i,4)=r4
           cord(i,5)=r5
           cord(i,6)=r6
         enddo
       endif
       if(loi.eq.7) then
         do i=2,imax
           DO
             call rlux(vecx,len)
             r1=2.*vecx(1)-1.
             call rlux(vecx,len)
             r3=2.*vecx(1)-1.
             call rlux(vecx,len)
             r6=2.*vecx(1)-1.
!  make round in x,y,z plane 
             rho3=r1**2+r3**2+r6**2
             if (rho3.le.1.) EXIT
           ENDDO
           DO
             DO 
               call rlux(vecx,len)
               r2=2.*vecx(1)-1.
! make beam round in x,x' plane
               if((r1*r1+r2*r2).le.1.) EXIT
             ENDDO
             DO  
               call rlux(vecx,len)
               r4=2.*vecx(1)-1.
!  make beam round in y,yp plane
               if((r4*r4+r3*r3).le.1.) EXIT
             ENDDO
             DO  
               call rlux(vecx,len)
               r5=2.*vecx(1)-1.
!   make beam round in plane z, zp
               if((r6*r6+r5*r5).le.1.) EXIT
             ENDDO  
             if((r2*r2+r4*r4+r5*r5).le.1.) EXIT
           ENDDO  
!        store random numbers in preparation for rms correction
           cord(i,1)=r1
           cord(i,2)=r2
           cord(i,3)=r3
           cord(i,4)=r4
           cord(i,5)=r5
           cord(i,6)=r6
         enddo
       endif
       if(loi.eq.2) then
         do i=2,imax
           DO
             DO
               call rlux(vecx,len)
               r1=2.*vecx(1)-1.
               call rlux(vecx,len)
               r2=2.*vecx(1)-1.
!   make round x,xp
               rho=r1*r1+r2*r2
               if(rho.le.1) EXIT
             ENDDO  
             DO
               call rlux(vecx,len)
               r3=2.*vecx(1)-1.
               call rlux(vecx,len)
               r4=2.*vecx(1)-1.
!  make beam round in y,yp plane
               if((r4*r4+r3*r3).le.1.) EXIT
             ENDDO
             DO  
               call rlux(vecx,len)
               r5=2.*vecx(1)-1.
               call rlux(vecx,len)
               r6=2.*vecx(1)-1.
!   make beam round in plane z, zp
               if((r6*r6+r5*r5).le.1.) EXIT
             ENDDO  
!   make round x,xp,y,yp,z,zp
             rho=r1**2+r2**2+r3**2+r4**2+r5**2+r6**2
             if (rho.le.1.) EXIT
           ENDDO  
!        store random numbers in preparation for rms correction
           cord(i,1)=r1
           cord(i,2)=r2
           cord(i,3)=r3
           cord(i,4)=r4
           cord(i,5)=r5
           cord(i,6)=r6
         enddo
       endif
       if(loi.eq.3) then
         ntir=24
         s=.2493
         am=0.
         do i=2,imax
           DO
             call gcern (len,s,am,vec)
             r1=vec
             call gcern (len,s,am,vec)
             r3=vec
             call gcern (len,s,am,vec)
             r6=vec
!  make round in x,y,z plane
             rho=r1**2+r3**2+r6**2
             if (rho.le.1.) EXIT
           ENDDO
           DO  
             call gcern (len,s,am,vec)
             r2=vec
! make beam round in x,x' plane
             if((r1*r1+r2*r2).le.1.) EXIT
           ENDDO
           DO
             call gcern (len,s,am,vec)
             r4=vec
!  make beam round in y,yp plane
             if((r4*r4+r3*r3).le.1.) EXIT
           ENDDO
           DO
             call gcern (len,s,am,vec)
             r5=vec
!   make beam round in plane z, zp
             if((r6*r6+r5*r5).le.1.) EXIT
           ENDDO  
!        store random numbers in preparation for rms correction
           cord(i,1)=r1
           cord(i,2)=r2
           cord(i,3)=r3
           cord(i,4)=r4
           cord(i,5)=r5
           cord(i,6)=r6
         enddo
       endif
       if(loi.eq.4) then
         ntir=12
         s=.2493
         am=0.
         do i=2,imax
           DO
             DO
               call gcern (len,s,am,vec)
               r1=vec
               call gcern (len,s,am,vec)
               r2=vec
! make beam round in x,xp plane
               rho=r1*r1+r2*r2
               if (rho.le.1.) EXIT
             ENDDO
             DO  
               call gcern (len,s,am,vec)
               r3=vec
               call gcern (len,s,am,vec)
               r4=vec
! make beam round in y,yp plane
               if((r3*r3+r4*r4).le.1.) EXIT
             ENDDO
             DO  
               call gcern (len,s,am,vec)
               r5=vec
               call gcern (len,s,am,vec)
               r6=vec
!   make beam round in plane z, zp
               if((r6*r6+r5*r5).le.1.) EXIT
             ENDDO  
!        store random numbers in preparation for rms correction
!   make round x,xp,y,yp,z,zp
             rho=r1**2+r2**2+r3**2+r4**2+r5**2+r6**2
             if (rho.le.1.) EXIT
           ENDDO  
           cord(i,1)=r1
           cord(i,2)=r2
           cord(i,3)=r3
           cord(i,4)=r4
           cord(i,5)=r5
           cord(i,6)=r6
         enddo
       endif
       if(loi.eq.5) then
         do i=2,imax
           DO
             DO
               call rlux(vecx,len)
               r1=2.*vecx(1)-1.
               call rlux(vecx,len)
               r3=2.*vecx(1)-1.
!  make round in x,y plane
               rho=r1**2+r3**2
               if (rho.le.1.) EXIT
             ENDDO
             DO 
               call rlux(vecx,len)
               r2=2.*vecx(1)-1.
! make beam round in x,x' plane
               if((r1*r1+r2*r2).le.1.) EXIT
             ENDDO
             DO  
               call rlux(vecx,len)
               r4=2.*vecx(1)-1.
!  make beam round in y,yp plane
               if((r4*r4+r3*r3).le.1.) EXIT
             ENDDO  
!   make round x,xp,y,yp
             rho=r1**2+r2**2+r3**2+r4**2
             if (rho.le.1.) EXIT
           ENDDO  
!*et*2010-11-23  do NOT make beam round in z,zp plane
           call rlux(vecx,len)
           r5=2.*vecx(1)-1.
           call rlux(vecx,len)
           r6=2.*vecx(1)-1.
!        store random numbers in preparation for rms correction
           cord(i,1)=r1
           cord(i,2)=r2
           cord(i,3)=r3
           cord(i,4)=r4
           cord(i,5)=r5
           cord(i,6)=r6
         enddo
       endif
       if(loi.eq.6) then
! Gaussian
         do i=2,imax
           CALL RGAUS2(SIG,Y1,Y2,Y3,Y4)
! do NOT make beam gaussian in z,zp plane
           call rlux(vecx,len)
           r5=2.*vecx(1)-1.
           call rlux(vecx,len)
           r6=2.*vecx(1)-1.
!
!        store random numbers in preparation for rms correction
           cord(i,1)=y1
           cord(i,2)=y2
           cord(i,3)=y3
           cord(i,4)=y4
           cord(i,5)=r5
           cord(i,6)=r6
         enddo
         y1x=abs(cord(2,1))
         y2x=abs(cord(2,2))
         y3x=abs(cord(2,3))
         y4x=abs(cord(2,4))
         do i=3,imax
           if(abs(cord(i,1)).gt.y1x)y1x=abs(cord(i,1))
           if(abs(cord(i,2)).gt.y2x)y2x=abs(cord(i,2))
           if(abs(cord(i,3)).gt.y3x)y3x=abs(cord(i,3))
           if(abs(cord(i,4)).gt.y4x)y4x=abs(cord(i,4))
         enddo
         do i=2,imax
           cord(i,1)=cord(i,1)/y1x
           cord(i,2)=cord(i,2)/y2x
           cord(i,3)=cord(i,3)/y3x
           cord(i,4)=cord(i,4)/y4x
         enddo
       endif
       call corre(imax,imax)
!       fimax=ttmax*fh*180./pi
! maximum extent in case of continous beam is +/-pi (i.e. +/-180 deg)
       tcorct=abs(.5*cord(2,6)*ttmax)
       ecorct=abs(.5*cord(2,5)*dmax)
!   in fo(1,) is stored the energy extent (MeV)
       do i=2,imax
         fo(1,i)=.5*cord(i,5)*dmax
         fo(2,i)=.5*cord(i,1)*ymax
         fo(3,i)=.5*cord(i,2)*tmax
         fo(4,i)=.5*cord(i,3)*zmax
         fo(5,i)=.5*cord(i,4)*pmax
         fo(6,i)=.5*cord(i,6)*ttmax
         if(abs(fo(1,i)).gt.ecorct) ecorct=abs(fo(1,i))
         if(abs(fo(6,i)).gt.tcorct) tcorct=abs(fo(6,i))
       enddo
!    first particle
!ccc        imax=imax+1
       ichas(1)=1
       fo(8,1)=1.
       do j=1,6
         fo(j,1)=0.
       enddo
!        if(loi.lt.5) then
       if(loi.lt.5 .or. loi.gt.6) then
         do i=2,imax
           fo(8,i)=1
           ICHAS(I)=1
         enddo
       else
! correct the phase length and energy spread for a continuous beam (force +/- 180 deg)
         if(ecorct.le.epsilon(ecorct)) ecorct=1.
         if(tcorct.le.epsilon(tcorct)) tcorct=1.
         ecorct=dmax/ecorct
         tcorct=ttmax/tcorct
         do i=2,imax
           fo(8,i)=1
           ICHAS(I)=1
           fo(1,i)=fo(1,i)*ecorct
           fo(6,i)=fo(6,i)*tcorct
         enddo
       endif
       ngood=imax
       imaxo=imax
       WRITE(16,8)LOI,IMAX
8      FORMAT(8X ,'  ****law ',i2,'  with ',i7,' particles',/)
       RETURN
       END
!> *******************************************************************
!! subroutine rgaus2(sigma,y1,y2,y3,y4)
!! called by subroutine MONTE
!< *******************************************************************
       subroutine rgaus2(sigma,y1,y2,y3,y4)
       implicit real(8) (a-h,o-z)
       dimension vecx(1)
       fprec=epsilon(sigma)
       len=1
       w1=0.
!        do while ((w1.ge.1.0).or.(w1.eq.0.))
       do while ((w1.ge.1.0).or.(abs(w1).le.fprec))
         call rlux(vecx,len)
         x1 = 2.0 * vecx(1) - 1.0
         call rlux(vecx,len)
         x3 = 2.0 * vecx(1) - 1.0
         w1 = x1 * x1 + x3 * x3
       enddo
       w2=0.
!        do while ((w2.ge.1.0).or.(w2.eq.0.))
       do while ((w2.ge.1.0).or.(abs(w2).le.fprec))
         call rlux(vecx,len)
         x2 = 2.0 * vecx(1) - 1.0
         call rlux(vecx,len)
         x4 = 2.0 * vecx(1) - 1.0
         w2 = x2 * x2 + x4 * x4
       enddo
       w1 = sigma*sqrt( (-2.0 * log( w1 ) ) / w1 )
       w2 = sigma*sqrt( (-2.0 * log( w2 ) ) / w2 )
       y1 = x1 * w1
       y2 = x2 * w2
       y3 = x3 * w1
       y4 = x4 * w2
       return
       end
!> *******************************************************************
!! SUBROUTINE rlux(RVEC,LENV)
!! ranlux.f Rev 1.2  1997/09/22 13:45:47  mclareni
!! Correct error in initializing RANLUX by using RLUXIN with the
!! output of RLUXUT from a previous run.
!! CERN Mathlib gen
!!
!!         Subtract-and-borrow random number generator proposed by
!!         Marsaglia and Zaman, implemented by F. James with the name
!!         RCARRY in 1991, and later improved by Martin Luescher
!!         in 1993 to produce "Luxury Pseudorandom Numbers".
!!         Fortran 77 coded by F. James, 1993
!!
!!   LUXURY LEVELS.
!!   ------ ------      The available luxury levels are:
!!
!!  level 0  (p=24): equivalent to the original RCARRY of Marsaglia
!!           and Zaman, very long period, but fails many tests.
!!  level 1  (p=48): considerable improvement in quality over level 0,
!!           now passes the gap test, but still fails spectral test.
!!  level 2  (p=97): passes all known tests, but theoretically still
!!           defective.
!!  level 3  (p=223): DEFAULT VALUE.  Any theoretically possible
!!           correlations have very small chance of being observed.
!!  level 4  (p=389): highest possible luxury, all 24 bits chaotic.
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!  Calling sequences for RANLUX:                                  ++
!!      CALL RANLUX (RVEC, LEN)   returns a vector RVEC of LEN     ++
!!               32-bit random floating point numbers between      ++
!!               zero (not included) and one (also not incl.).     ++
!!      CALL RLUXGO(LUX,INT,K1,K2) initializes the generator from  ++
!!               one 32-bit integer INT and sets Luxury Level LUX  ++
!!               which is integer between zero and MAXLEV, or if   ++
!!               LUX .GT. 24, it sets p=LUX directly.  K1 and K2   ++
!!               should be set to zero unless restarting at a break++
!!               point given by output of RLUXAT (see RLUXAT).     ++
!!      CALL RLUXAT(LUX,INT,K1,K2) gets the values of four integers++
!!               which can be used to restart the RANLUX generator ++
!!               at the current point by calling RLUXGO.  K1 and K2++
!!               specify how many numbers were generated since the ++
!!               initialization with LUX and INT.  The restarting  ++
!!               skips over  K1+K2*E9   numbers, so it can be long.++
!!   A more efficient but less convenient way of restarting is by: ++
!!      CALL RLUXIN(ISVEC)    restarts the generator from vector   ++
!!                   ISVEC of 25 32-bit integers (see RLUXUT)      ++
!!      CALL RLUXUT(ISVEC)    outputs the current values of the 25 ++
!!                 32-bit integer seeds, to be used for restarting ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
       SUBROUTINE rlux(RVEC,LENV)
       implicit real(8) (a-h,o-z)
       DIMENSION RVEC(LENV)
       DIMENSION SEEDS(24), ISEEDS(24)
       PARAMETER (MAXLEV=4, LXDFLT=3)
       DIMENSION NDSKIP(0:MAXLEV)
       DIMENSION NEXT(24)
       PARAMETER (IGIGA=1000000000,JSDFLT=314159265)
       PARAMETER (ITWO24=2**24, ICONS=2147483563)
       SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24, TWOM12, LUXLEV
       SAVE NSKIP, NDSKIP, IN24, NEXT, KOUNT, MKOUNT, INSEED
       INTEGER LUXLEV
       LOGICAL NOTYET
       DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
       DATA I24,J24,CARRY/24,10,0./
!                               default
!  Luxury Level   0     1     2   *3*    4
       DATA NDSKIP/0,   24,   73,  199,  365 /
! corresponds to p=24    48    97   223   389
!     time factor 1     2     3     6    10   on slow workstation
!                 1    1.5    2     3     5   on fast mainframe
!
!  NOTYET is .TRUE. if no initialization has been performed yet.
!              Default Initialization by Multiplicative Congruential
       fprec=epsilon(carry)
       IF (NOTYET) THEN
         NOTYET = .FALSE.
         JSEED = JSDFLT
         INSEED = JSEED
         WRITE(16,'(A,I12)')' RANLUX DEFAULT INITIALIZATION: ',JSEED
         LUXLEV = LXDFLT
         NSKIP = NDSKIP(LUXLEV)
         LP = NSKIP + 24
         IN24 = 0
         KOUNT = 0
         MKOUNT = 0
         WRITE(16,'(A,I2,A,I4)')' RANLUX DEFAULT LUXURY LEVEL =  ',
     +        LUXLEV,'      p =',LP
         TWOM24 = 1.
         DO I= 1, 24
           TWOM24 = TWOM24 * 0.5
           K = JSEED/53668
           JSEED = 40014*(JSEED-K*53668) -K*12211
           IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
           ISEEDS(I) = MOD(JSEED,ITWO24)
         ENDDO
         TWOM12 = TWOM24 * 4096.
         DO I= 1,24
           SEEDS(I) = REAL(ISEEDS(I))*TWOM24
           NEXT(I) = I-1
         ENDDO
         NEXT(1) = 24
         I24 = 24
         J24 = 10
         CARRY = 0.
         IF (abs(SEEDS(24)) .LE. fprec) CARRY = TWOM24
!         IF (SEEDS(24) .EQ. 0.) CARRY = TWOM24
       ENDIF
!
!          The Generator proper: "Subtract-with-borrow",
!          as proposed by Marsaglia and Zaman,
!          Florida State University, March, 1989
!
       DO IVEC= 1, LENV
         UNI = SEEDS(J24) - SEEDS(I24) - CARRY
         IF (UNI .LT. 0.)  THEN
           UNI = UNI + 1.0
           CARRY = TWOM24
         ELSE
           CARRY = 0.
         ENDIF
         SEEDS(I24) = UNI
         I24 = NEXT(I24)
         J24 = NEXT(J24)
         RVEC(IVEC) = UNI
!  small numbers (with less than 12 "significant" bits) are "padded".
         IF (UNI .LT. TWOM12)  THEN
           RVEC(IVEC) = RVEC(IVEC) + TWOM24*SEEDS(J24)
!          and zero is forbidden in case someone takes a logarithm
           IF (abs(RVEC(IVEC)) .LE. fprec)  RVEC(IVEC) = TWOM24*TWOM24
!           IF (RVEC(IVEC) .EQ. 0.)  RVEC(IVEC) = TWOM24*TWOM24
         ENDIF
!        Skipping to luxury.  As proposed by Martin Luscher.
         IN24 = IN24 + 1
         IF (IN24 .EQ. 24)  THEN
           IN24 = 0
           KOUNT = KOUNT + NSKIP
           DO ISK= 1, NSKIP
             UNI = SEEDS(J24) - SEEDS(I24) - CARRY
             IF (UNI .LT. 0.)  THEN
               UNI = UNI + 1.0
               CARRY = TWOM24
             ELSE
               CARRY = 0.
             ENDIF
             SEEDS(I24) = UNI
             I24 = NEXT(I24)
             J24 = NEXT(J24)
           ENDDO
         ENDIF
       ENDDO
       KOUNT = KOUNT + LENV
       IF (KOUNT .GE. IGIGA)  THEN
         MKOUNT = MKOUNT + 1
         KOUNT = KOUNT - IGIGA
       ENDIF
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE RLUXIN(ISDEXT)
!! ranlux.f Rev 1.2  1997/09/22 13:45:47  mclareni
!! Correct error in initializing RANLUX by using RLUXIN with the
!! output of RLUXUT from a previous run.
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!           RLUXIN(ISVEC)    restarts the generator from vector   ++
!!                   ISVEC of 25 32-bit integers (see RLUXUT)      ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
       SUBROUTINE RLUXIN(ISDEXT)
       implicit real(8) (a-h,o-z)
       DIMENSION SEEDS(24), ISDEXT(25)
       PARAMETER (MAXLEV=4, LXDFLT=3)
       DIMENSION NDSKIP(0:MAXLEV)
       DIMENSION NEXT(24)
       SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24, TWOM12, LUXLEV
       SAVE NSKIP, NDSKIP, IN24, NEXT, KOUNT, MKOUNT, INSEED
       INTEGER LUXLEV
       LOGICAL NOTYET
       DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
       DATA I24,J24,CARRY/24,10,0./
!                               default
!  Luxury Level   0     1     2   *3*    4
       DATA NDSKIP/0,   24,   73,  199,  365 /
!orresponds to p=24    48    97   223   389
!     time factor 1     2     3     6    10   on slow workstation
!                 1    1.5    2     3     5   on fast mainframe
!
!
!           Entry to input and float integer seeds from previous run
       NOTYET = .FALSE.
       TWOM24 = 1.
       DO I= 1, 24
         NEXT(I) = I-1
         TWOM24 = TWOM24 * 0.5
       ENDDO
       NEXT(1) = 24
       TWOM12 = TWOM24 * 4096.
       WRITE(16,'(A)')'FULL INITIALIZATION OF RANLUX WITH 25',
     *                  ' INTEGERS'
       WRITE(16,'(5X,5I12)') ISDEXT
       DO I= 1, 24
         SEEDS(I) = REAL(ISDEXT(I))*TWOM24
       ENDDO
       CARRY = 0.
       IF (ISDEXT(25) .LT. 0)  CARRY = TWOM24
       ISD = IABS(ISDEXT(25))
       I24 = MOD(ISD,100)
       ISD = ISD/100
       J24 = MOD(ISD,100)
       ISD = ISD/100
       IN24 = MOD(ISD,100)
       ISD = ISD/100
       LUXLEV = ISD
       IF (LUXLEV .LE. MAXLEV) THEN
         NSKIP = NDSKIP(LUXLEV)
         WRITE (6,'(A,I2)')'RANLUX LUXURY LEVEL SET BY RLUXIN TO: ',
     +                         LUXLEV
       ELSE  IF (LUXLEV .GE. 24) THEN
         NSKIP = LUXLEV - 24
         WRITE (6,'(A,I5)')'RANLUX P-VALUE SET BY RLUXIN TO:',LUXLEV
       ELSE
         NSKIP = NDSKIP(MAXLEV)
         WRITE (6,'(A,I5)')'RANLUX ILLEGAL LUXURY RLUXIN: ',LUXLEV
         LUXLEV = MAXLEV
       ENDIF
       INSEED = -1
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE RLUXUT(ISDEXT)
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!      CALL RLUXUT(ISVEC)    outputs the current values of the 25 ++
!!                 32-bit integer seeds, to be used for restarting ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
       SUBROUTINE RLUXUT(ISDEXT)
       implicit real(8) (a-h,o-z)
       DIMENSION SEEDS(24), ISDEXT(25)
       PARAMETER (MAXLEV=4, LXDFLT=3)
       DIMENSION NDSKIP(0:MAXLEV)
       PARAMETER (TWOP12=4096.)
       SAVE NOTYET, I24, J24, CARRY, SEEDS, LUXLEV
       SAVE NDSKIP, IN24, KOUNT, MKOUNT
       INTEGER LUXLEV
       LOGICAL NOTYET
       DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
       DATA I24,J24,CARRY/24,10,0./
!                               default
!  Luxury Level   0     1     2   *3*    4
       DATA NDSKIP/0,   24,   73,  199,  365 /
!orresponds to p=24    48    97   223   389
!     time factor 1     2     3     6    10   on slow workstation
!                 1    1.5    2     3     5   on fast mainframe
!
!
!                    Entry to output seeds as integers
       DO I= 1, 24
         ISDEXT(I) = INT(SEEDS(I)*TWOP12*TWOP12)
       ENDDO
       ISDEXT(25) = I24 + 100*J24 + 10000*IN24 + 1000000*LUXLEV
       IF (CARRY .GT. 0.)  ISDEXT(25) = -ISDEXT(25)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE RLUXAT(LOUT,INOUT,K1,K2)
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!      CALL RLUXAT(LUX,INT,K1,K2) gets the values of four integers++
!!               which can be used to restart the RANLUX generator ++
!!               at the current point by calling RLUXGO.  K1 and K2++
!!               specify how many numbers were generated since the ++
!!               initialization with LUX and INT.  The restarting  ++
!!               skips over  K1+K2*E9   numbers, so it can be long.++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
       SUBROUTINE RLUXAT(LOUT,INOUT,K1,K2)
       implicit real(8) (a-h,o-z)
       PARAMETER (LXDFLT=3)
       SAVE NOTYET, LUXLEV
       SAVE IN24, KOUNT, MKOUNT, INSEED
       INTEGER LUXLEV
       LOGICAL NOTYET
       DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
!                    Entry to output the "convenient" restart point
       LOUT = LUXLEV
       INOUT = INSEED
       K1 = KOUNT
       K2 = MKOUNT
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE RLUXGO(LUX,INS,K1,K2)
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!      CALL RLUXGO(LUX,INT,K1,K2) initializes the generator from  ++
!!               one 32-bit integer INT and sets Luxury Level LUX  ++
!!               which is integer between zero and MAXLEV, or if   ++
!!               LUX .GT. 24, it sets p=LUX directly.  K1 and K2   ++
!!               should be set to zero unless restarting at a break++
!!               point given by output of RLUXAT (see RLUXAT).     ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
       SUBROUTINE RLUXGO(LUX,INS,K1,K2)
       implicit real(8) (a-h,o-z)
       DIMENSION SEEDS(24), ISEEDS(24)
       PARAMETER (MAXLEV=4, LXDFLT=3)
       DIMENSION NDSKIP(0:MAXLEV)
       DIMENSION NEXT(24)
       PARAMETER (IGIGA=1000000000,JSDFLT=314159265)
       PARAMETER (ITWO24=2**24, ICONS=2147483563)
       SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24, TWOM12, LUXLEV
       SAVE NSKIP, NDSKIP, IN24, NEXT, KOUNT, MKOUNT, INSEED
       INTEGER LUXLEV
       LOGICAL NOTYET
       DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
       DATA I24,J24,CARRY/24,10,0./
!                               default
!  Luxury Level   0     1     2   *3*    4
       DATA NDSKIP/0,   24,   73,  199,  365 /
!orresponds to p=24    48    97   223   389
!     time factor 1     2     3     6    10   on slow workstation
!                 1    1.5    2     3     5   on fast mainframe
!
!
!                    Entry to initialize from one or three integers
       IF (LUX .LT. 0) THEN
         LUXLEV = LXDFLT
       ELSE IF (LUX .LE. MAXLEV) THEN
         LUXLEV = LUX
       ELSE IF (LUX .LT. 24 .OR. LUX .GT. 2000) THEN
         LUXLEV = MAXLEV
         WRITE (6,'(A,I7)')'RANLUX ILLEGAL LUXURY RLUXGO: ',LUX
       ELSE
         LUXLEV = LUX
         DO ILX= 0, MAXLEV
           IF (LUX .EQ. NDSKIP(ILX)+24)  LUXLEV = ILX
         ENDDO
       ENDIF
       IF (LUXLEV .LE. MAXLEV)  THEN
         NSKIP = NDSKIP(LUXLEV)
         WRITE(16,'(A,I2,A,I4)')'RANLUX LUXURY LEVEL SET BY RLUXGO :',
     +        LUXLEV,'     P=', NSKIP+24
       ELSE
         NSKIP = LUXLEV - 24
         WRITE(16,'(A,I5)')'RANLUX P-VALUE SET BY RLUXGO TO:',LUXLEV
       ENDIF
       IN24 = 0
       IF (INS .LT. 0)  WRITE (6,'(A)')
     +   ' Illegal initialization by RLUXGO, negative input seed'
       IF (INS .GT. 0)  THEN
         JSEED = INS
         WRITE(16,'(A,3I12)')'RANLUX INITIALIZED BY ',
     +     'RLUXGO FROM SEEDS',JSEED, K1,K2
       ELSE
         JSEED = JSDFLT
         WRITE(16,'(A)')'RANLUX INITIALIZED BY RLUXGO FROM DEFAULT',
     +                    ' SEED'
       ENDIF
       INSEED = JSEED
       NOTYET = .FALSE.
       TWOM24 = 1.
       DO I= 1, 24
         TWOM24 = TWOM24 * 0.5
         K = JSEED/53668
         JSEED = 40014*(JSEED-K*53668) -K*12211
         IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
         ISEEDS(I) = MOD(JSEED,ITWO24)
       ENDDO
       TWOM12 = TWOM24 * 4096.
       DO I= 1,24
         SEEDS(I) = REAL(ISEEDS(I))*TWOM24
         NEXT(I) = I-1
       ENDDO
       NEXT(1) = 24
       I24 = 24
       J24 = 10
       CARRY = 0.
       fprec=epsilon(seeds(24))
!       IF (SEEDS(24) .EQ. 0.) CARRY = TWOM24
       IF (abs(SEEDS(24)).LE.fprec) CARRY = TWOM24
!        If restarting at a break point, skip K1 + IGIGA*K2
!        Note that this is the number of numbers delivered to
!        the user PLUS the number skipped (if luxury .GT. 0).
       KOUNT = K1
       MKOUNT = K2
       IF (K1+K2 .NE. 0)  THEN
         DO IOUTER= 1, K2+1
           INNER = IGIGA
           IF (IOUTER .EQ. K2+1)  INNER = K1
           DO ISK= 1, INNER
             UNI = SEEDS(J24) - SEEDS(I24) - CARRY
             IF (UNI .LT. 0.)  THEN
               UNI = UNI + 1.0
               CARRY = TWOM24
             ELSE
               CARRY = 0.
             ENDIF
             SEEDS(I24) = UNI
             I24 = NEXT(I24)
             J24 = NEXT(J24)
           ENDDO
         ENDDO
!         Get the right value of IN24 by direct calculation
         IN24 = MOD(KOUNT, NSKIP+24)
         IF (MKOUNT .GT. 0)  THEN
           IZIP = MOD(IGIGA, NSKIP+24)
           IZIP2 = MKOUNT*IZIP + IN24
           IN24 = MOD(IZIP2, NSKIP+24)
         ENDIF
!       Now IN24 had better be between zero and 23 inclusive
         IF (IN24 .GT. 23) THEN
           WRITE (6,'(A/A,3I11,A,I5)')
     +    '  Error in RESTARTING with RLUXGO:',' The values',INS,
     +       K1, K2, ' cannot occur at luxury level', LUXLEV
           IN24 = 0
         ENDIF
       ENDIF
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE gcern(len,s,am,v)
!! random number generator based on normal law
!!        s : sigma of the distribution
!!        am: distribution average
!!        v : random number based on normal law
!< *******************************************************************
       SUBROUTINE gcern(len,s,am,v)
       implicit real(8) (a-h,o-z)
       common/ragau/ntir
       dimension vecx(1)
       a=0.
       do i=1,ntir
         call rlux(vecx,len)
         y=vecx(1)
         a=a+y
       enddo
       v=(a-float(ntir)/2.)*s+am
       return
       end
!> *******************************************************************
!! SUBROUTINE adjrfq
!! read the coordinates of particles from file
!< *******************************************************************
       SUBROUTINE adjrfq
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/speda/dave,idave
       COMMON/DYN/TREF,VREF
       common/faisc/f(10,iptsz),imax,ngood
       common/objet/fo(9,iptsz),imaxo
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/tapes/in,ifile,meta,ierr
       common/isxpyp/iflag
       common/mcs/imcs,ncstat,cstat(20)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/strip/atm,qs,atms,ths,qop,sqst(6),anp,nqst
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/trace3e/tracebi(6),traceei(3)
       common/t3dfld/fldctr(15),zend(15),T3D
       common/disttype/bindst
       LOGICAL T3D,bindst
       character trace3h*128,trace3t*128,tif*128
       logical dave,acpt
       read(in,*) iflag
       if(iflag.eq.0 .or. iflag.eq.100)
     *   write(16,*)'Standard file, phase in rad'
       if(iflag.eq.1 .or. iflag.eq.101)
     *   write(16,*)'File with particle number, ',
     *              'phase in rad'
       if(iflag.eq.2 .or. iflag.eq.102)
     *   write(16,*)'File with several charge states',
     *              ', phase in rad'
       if(iflag.eq.3 .or. iflag.eq.103)
     *   write(16,*)'File with charge state and ',
     *              'particle number, phase in rad'
       if(iflag.eq.9 .or. iflag.eq.109)
     *   write(16,*)'File with charge state and rest ',
     *              'mass, phase in rad'
       if(iflag.eq.10 .or. iflag.eq.110)
     *   write(16,*)'Standard file, phase in ns'
       if(iflag.eq.11 .or. iflag.eq.111)
     *   write(16,*)'File with particle number, ',
     *              'phase in ns'
       if(iflag.eq.12 .or. iflag.eq.112)
     *   write(16,*)'File with several charge states',
     *              ', phase in ns'
       if(iflag.eq.13 .or. iflag.eq.113)
     *   write(16,*)'File with charge state and ',
     *              'particle number, phase in ns'
       if(iflag.eq.19 .or. iflag.eq.119)
     *   write(16,*)'File with charge state and rest',
     *              ' mass, phase in ns'
! ---  input: freq.(MHertz) tofini: phase offset (deg) to be applied both to the reference and the beam
       read(in,*) freq,tofini
       write(16,*) 'Frequency [MHz]:',freq
       fh=2.*pi*freq*1.e06
       FHINIT=FH
       read(in,*)uem,atm
       xmat=uem*atm
! --- reference:
!   enedep:energy(MeV), qst: charge of the reference
!   when iflag =0 or iflag = 1 qst is the charge of the beam
       read(in,*) enedep,qst
       tofini=tofini*pi/(180.*fh)
       gdep=enedep/xmat+1.
       bdep=sqrt(1.-1./(gdep*gdep))
       vref=bdep*vl
       vrefi=vref
       tref=tofini
       trefi=tofini
       ncstat=1
       boro=3.3356*xmat*bdep*gdep/qst
       write(16,101) uem,atm,qst,tofini,enedep,bdep,boro
101    format(' **** unit mass: ',e12.5,' MeV, mass units: ',f6.1,/,
     *      ' **** reference charge ',f4.1,' time of flight ',e12.5,
     *      ' sec',/,' **** reference : energy ',e12.5,' MeV beta ',
     *      e12.5,' momentum ',e12.5,' kG.cm')
       if(bindst) then
         read(55) imax,ift,idum
       else
         read(55,*) imax,dumf,dum
         ift=int(dumf)
       endif  
       write(16,*)'File type listed in particle distribution file:',ift
       write(16,*)'File type listed in DYNAC    input        file:',
     *  iflag
       if(ift.ne.iflag) then
         WRITE(6,*) 'IFLAG in distribution file different from ',
     *               'IFLAG listed in DYNAC input file'
         WRITE(16,*) 'IFLAG in distribution file different from ',
     *               'IFLAG listed in DYNAC input file'
         stop
       endif
       write(16,*)'Number of macro particles in distribution file:',
     *  imax
       if(imax+2.gt.iptsz) then
         WRITE(6,*) 'Too many particles in distribution file'
         WRITE(16,*) 'too many particles '
         stop
       endif
       if(ncstat.eq.1) cstat(1)=qst
       if(iflag.eq.0 .or. iflag.eq.10 .or. iflag.eq.100 .or. 
     *    iflag.eq.110) then
!  iflag = 0 standard file:f(1,)=x, f(2,)=xp, f(3,)=y, f(4,)=yp, f(5,)=phase, f(6,)=kinetic energy
         if(bindst) then
           do j=1,imax
             read(55) (f(i,j),i=1,6)
           enddo  
         else  
           read(55,*) ((f(i,j),i=1,6),j=1,imax)
         endif  
       elseif(iflag.eq.1 .or. iflag.eq.11 .or. iflag.eq.101 .or.
     *        iflag.eq.111) then
!  iflag = 1  File with particle number: f(1,)=x, f(2,)=xp, f(3,)=y, f(4,)=yp, f(5,)=phase, f(6,)=kinetic energy, dum1
         if(bindst) then
           do j=1,imax
             read(55) (f(i,j),i=1,6),dum1
           enddo  
         else  
           read(55,*) ((f(i,j),i=1,6),dum1,j=1,imax)
         endif  
       elseif(iflag.eq.2 .or. iflag.eq.12 .or. iflag.eq.102 .or.
     *        iflag.eq.112) then
!  iflag = 2 beam with different charges: f(7,) = charge; 
!  figure out how many different ones there are and store them
         ncstat=1
         if(bindst) then
           read(55) (f(i,1),i=1,7)
         else  
           read(55,*) (f(i,1),i=1,7)
         endif  
         cstat(1)=f(7,1)
         do j=2,imax
           if(bindst) then
             read(55) (f(i,j),i=1,7)
           else  
             read(55,*) (f(i,j),i=1,7)
           endif  
           mcstat=0
           do k=1,ncstat
             if(int(f(7,j)).eq.int(cstat(k))) then
               mcstat=1
             endif
           enddo
           if(mcstat.eq.0) then
             ncstat=ncstat+1
             cstat(ncstat)=f(7,j)
           endif
         enddo
         write(16,*) 'Number of charge states: ',ncstat
         write(16,*) 'Charge state(s): ',(cstat(j),j=1,ncstat)
         if(ncstat.gt.1) imcs=1
       elseif(iflag.eq.3 .or. iflag.eq.13 .or. iflag.eq.103 .or.
     *        iflag.eq.113) then
!  iflag = 3 beam with different charges and particle number: f(7,) = charge; dum1
!  figure out how many different ones there are and store them
         ncstat=1
         if(bindst) then
           read(55) (f(i,1),i=1,7),dum1
         else  
           read(55,*) (f(i,1),i=1,7),dum1
         endif  
         cstat(1)=f(7,1)
         do j=2,imax
           if(bindst) then
             read(55) (f(i,j),i=1,7),dum1
           else  
             read(55,*) (f(i,j),i=1,7),dum1
           endif  
           mcstat=0
           do k=1,ncstat
             if(int(f(7,j)).eq.int(cstat(k))) then
               mcstat=1
             endif
           enddo
           if(mcstat.eq.0) then
             ncstat=ncstat+1
             cstat(ncstat)=f(7,j)
           endif
         enddo
         write(16,*) 'Number of charge states: ',ncstat
         write(16,*) 'Charge state(s): ',(cstat(j),j=1,ncstat)
         if(ncstat.gt.1) imcs=1
       elseif(iflag.eq.9 .or. iflag.eq.19 .or. iflag.eq.109 .or.
     *        iflag.eq.119) then
!  iflag = 9  File with charge state and rest mass: f(1,)=x, f(2,)=xp, f(3,)=y, f(4,)=yp, f(5,)=phase, f(6,)=kinetic energy, dum1, dum2
         if(bindst) then
           do j=1,imax
             read(55) (f(i,j),i=1,6),dum1,dum2
           enddo  
         else  
           do j=1,imax
             read(55,*) (f(i,j),i=1,6),dum1,dum2
           enddo  
         endif  
       endif
       call intfac(tofini)
       if(T3D) then
         write(tif,901) (tracebi(i),i=1,6)
901      format(' BEAMI(1)= ',5(f12.6,1x),f12.4)
         kt3h=kt3h+1
         trace3h(kt3h)=tif
         write(tif,902) (traceei(i),i=1,3)
902      format(' EMITI(1)= ',f12.6,1x,f12.6,1x,f12.4)
         kt3h=kt3h+1
         trace3h(kt3h)=tif
         write(tif,903) uem*atm,int(qst),fhinit/2./pi/1.E6
903      format(' ER= ',E16.7,', Q=',i3,' FREQ= ',E14.7)
         kt3h=kt3h+1
         trace3h(kt3h)=tif
         write(tif,7001) enedep
7001     format(' W= ',f12.4)
         kt3h=kt3h+1
         trace3h(kt3h)=tif
       endif
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE intfac(tofini)
!! convert the particles coordinates to DYNAC units
!< *******************************************************************
       SUBROUTINE intfac(tofini)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/SHIF/DTIPH,SHIFT
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/objet/fo(9,iptsz),imaxo
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/DYN/TREF,VREF
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/speda/dave,idave
       common/isxpyp/iflag
       common/mcs/imcs,ncstat,cstat(20)
       common/dmp/dmpdat(14)
       dimension foo(20,9),NDP(20)
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/trace3e/tracebi(6),traceei(3)
       common/t3dfld/fldctr(15),zend(15),T3D
       logical T3D
       character trace3h*128,trace3t*128,tif*128
       logical shift,chasit,dave
!      FH :INITIAL FREQENCY (hertz)
! Use frequency from part. dist. file to calculate f(6,i)
!    iflag = 0 : standard file, phase in rad
!    iflag = 1 : special file, phase in rad
!    iflag = 2 : several charge states, phase in rad
!    iflag = 10 : standard file, phase in ns
!    iflag = 11 : special file, phase in ns
!    iflag = 12 : several charge states, phase in ns
       imcs=0
!       if(iflag.eq.2 .or. iflag.eq.12)  imcs=1
       if(iflag.eq.2 .or. iflag.eq.12 .or. iflag.eq.102 .or. 
     *    iflag.eq.112)  imcs=1
       QMOY=QST
       j=1
       breft=vref/vl
       treft=tref
       tcog=0.
!   the table fo(,) is built from the input beam stored in the table f(,)
       if(iflag.le.2 .or. iflag.eq.100 .or. iflag.eq.101 .or. 
     *    iflag.eq.102) then
         do i=1,imax
           fo(7,i)=f(6,j)+xmat
           if(iflag.le.1 .or. iflag.eq.100 .or. 
     *        iflag.eq.101) fo(9,i)=qst
           if(iflag.eq.2 .or. iflag.eq.102) fo(9,i)=f(7,i)
           ichas(i)=1
           fo(8,i)=1.
!           fo(1,i)=float(j+1)
           fo(1,i)=float(j)
           fo(2,i)=f(1,j)
           fo(3,i)=f(2,j)*1000.
           fo(4,i)=f(3,j)
           fo(5,i)=f(4,j)*1000.
           fo(6,i)=tofini+f(5,j)/fh
           tcog=tcog+fo(6,i)
           j=j+1
         enddo
       else
         do i=1,imax
           fo(7,i)=f(6,j)+xmat
           if(iflag.le.11 .or. iflag.eq.110 .or. iflag.eq.111) 
     *        fo(9,i)=qst
           if(iflag.eq.12 .or. iflag.eq.112) fo(9,i)=f(7,i)
           ichas(i)=1
           fo(8,i)=1.
!           fo(1,i)=float(j+1)
           fo(1,i)=float(j)
           fo(2,i)=f(1,j)
           fo(3,i)=f(2,j)*1000.
           fo(4,i)=f(3,j)
           fo(5,i)=f(4,j)*1000.
           fo(6,i)=tofini+f(5,j)*1.e-09
           tcog=tcog+fo(6,i)
           j=j+1
         enddo
       endif
       tcog=tcog/float(imax)
!   cog of the beam
       if(iflag.eq.0 .or. iflag.eq.1 .or. iflag.eq.10 .or. iflag.eq.11
     *   .or. iflag.eq.100 .or. iflag.eq.101 .or. iflag.eq.110 .or. 
     *        iflag.eq.111)then
! single charge state
         NDP(1)=imax
         do j=2,7
           foo(1,j)=0.
         enddo
         do i=1,imax
           do j=2,7
             foo(1,j)=foo(1,j)+fo(j,i)
           enddo
         enddo
       else
! multi charge state
         kt3h=kt3h+1
         trace3h(kt3h)='ERROR: RDBEAM reads more than 1 charge state'
         DO k=1,ncstat
           NDP(k)=0
           do j=2,7
             foo(k,j)=0.
           enddo
         ENDDO
         DO i=1,imax
           DO k=1,ncstat
             if(int(fo(9,i)).eq.int(cstat(k))) then
               NDP(k)=NDP(k)+1
               do j=2,7
                 foo(k,j)=foo(k,j)+fo(j,i)
               enddo
             endif
           ENDDO
         ENDDO
       endif
       DO k=1,ncstat
         do j=2,7
           foo(k,j)=foo(k,j)/float(NDP(k))
         enddo
       ENDDO
       ngood=imax
       if(iflag.eq.0 .or. iflag.eq.1 .or. iflag.eq.10 .or. iflag.eq.11
     *   .or. iflag.eq.100 .or. iflag.eq.101 .or. iflag.eq.110 .or. 
     *        iflag.eq.111)then
! --- COG
         gref=foo(1,7)/xmat
         bref=sqrt(1.-1./(gref*gref))
         xe=(gref-1.)*xmat
!   magnetic rigidity
         bor=3.3356*xmat*bref*gref/qst
         write(16,*) '**** COG : energy ',xe,'MeV beta ',bref,
     *     ' momentum ',boro,' kG.cm'
       else
         DO k=1,ncstat
           gref=foo(k,7)/xmat
           bref=sqrt(1.-1./(gref*gref))
           xe=(gref-1.)*xmat
!   magnetic rigidity
           bor=3.3356*xmat*bref*gref/cstat(k)
           write(16,*) ' Q: ',cstat(k),' COG : energy ',xe,
     *     ' MeV beta ',bref,' momentum ',bor,' kG.cm'
         ENDDO
       endif
       vrefi=vref
       trefi=tref
! now save data back to f
       do i=1,ngood
         do k=1,9
           f(k,i)=fo(k,i)
         enddo
       enddo
!9999   format(6(2x,e12.5))
       imaxo=ngood
       call emiprt(0)
! store START data for .dmp file
       dmpdat(1)=0.
       dmpdat(2)=100.
       dmpdat(3)=0.
       dmpdat(4)=tcog*180.*fh/pi
       dmpdat(5)=bref
       dmpdat(6)=xe
       dmpdat(7)=treft*180.*fh/pi
       dmpdat(8)=breft
       dmpdat(9)=(sqrt(1./(1.-breft*breft))-1.)*xmat
! dmpdat(10), dmpdat(11), dmpdat(12) loaded in emiprt
!       dmpdat(13)=0.
!       dmpdat(14)=0.
!       nd=0
!       write(50,*) '# start   Z       trans   ',
!     *   'dummy    TOF(COG)    COG        Wcog          TOF(REF)   ',
!     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
!     *   'El,RMS       dummy         dummy'
!       write(50,*) '#  #     (m)       (%)    ',
!     *  '          (deg)      beta       (MeV)          (deg)      ',
!     *  '   beta       (MeV)       (mm.mrad)    (mm.mrad)    (ns.keV)'
!       write(50,7023) nd,(dmpdat(i),i=1,14)
!7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
!     *   2(e14.7,1x,f7.5,1x,e14.7,1x),7(e12.5,1x))
       if(T3D) then
         call emit3d
       endif
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE stapl(zpos)
!!   the statistics in EXT2
!!
!!   sprfx(cm): 2.*sqrt( sum(x*x) )
!!   sprfy(cm): 2.*sqrt( sum(y*y) )
!!   sprfw:     2.*sqrt( sum(dp/p * dp/p) )*beta*beta =
!!                     (energy spread)/(energy of c.o.g)
!!   sprfp(deg):2.*sqrt( sum(dphi * dphi) )
!!   sprfz(cm) :   sqrt( sum(dt * dt) )
!!   sprfl(m) : t.o.f of the reference
!!   sprww(MeV):kinetic energy of the c.o.g
!!   eprfw(ns.keV) : longitudinal emittance
!!   eprnx(mm.mrad): normalized emittance in x-direction
!!   eprny(mm.mrad): normalized emittance in y-direction
!< *******************************************************************
       SUBROUTINE stapl(zpos)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/pltprf/sprfx(6001),sprfy(6001),sprfl(6001),sprfw(6001),
     *               sprfp(6001),SPRNG(6001),PRLAB(6001),IPRF
       common/pltprf1/sprww(6001),eprfw(6001),eprnx(6001),eprny(6001),
     *                sprfz(6001)
       common/pltprf2/sxmn(6001),sxmx(6001),symn(6001),symx(6001),
     *                stmn(6001),stmx(6001),spmn(6001),spmx(6001),
     *                swmn(6001),swmx(6001),disprx(6001),dispry(6001),
     *            dispcx(6001),dispcy(6001),sdwbeam(6001),swref(6001),
     *            stref(6001),stcog(6001),sxbar(6001),sybar(6001)
       common/etcom/cog(8),exten(17),fd(iptsz)
       common /consta/ vl, pi, xmat, rpel, qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/faisc/f(10,iptsz),imax,ngood
       common/grot/rzot,izrot
       COMMON/DYN/TREF,VREF
       CHARACTER*(8) PRLAB
       logical izrot
!  izrot: logical flag set as .true. in the routine ZROTA
       if(izrot) call zrotap(-rzot)
       iarg=0
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       CALL EXT2(iarg)
       sqmdv=4.*sqrt(exten(10)*exten(3)-exten(11)*exten(11))    
       eprfw(iprf)=sqmdv*1.e12/fh
       sprfx(iprf)=2.*sqrt(exten(4))
       sprfy(iprf)=2.*sqrt(exten(6))
       trqtx=exten(4)*exten(5)-exten(8)*exten(8)
       trqpy=exten(6)*exten(7)-exten(9)*exten(9)
       surxth=4.*pi*sqrt(trqtx)
       suryph=4.*pi*sqrt(trqpy)
       eprnx(iprf)=bcog*surxth*10./(pi*sqrt(1.-bcog*bcog))
       eprny(iprf)=bcog*suryph*10./(pi*sqrt(1.-bcog*bcog))
! horizontal and vertical dispersion in meter (w.r.t. reference)
!       disprx(iprf)=0.01*exten(12)/exten(14)
!       dispry(iprf)=0.01*exten(13)/exten(14)
! horizontal and vertical dispersion in meter (w.r.t. COG)
       dispcx(iprf)=0.01*exten(15)/exten(17)
       dispcy(iprf)=0.01*exten(16)/exten(17)
       trqfi=0.
       tof=0.
       chxmx=f(2,1)
       chxmn=f(2,1)
       chymx=f(4,1)
       chymn=f(4,1)
       chpmx=f(6,1)-tcog
       chpmn=f(6,1)-tcog
       chwmx=f(7,1)-encog
       chwmn=f(7,1)-encog
       chdmx=chpmx*fh*180./pi
       chdmn=chpmn*fh*180./pi
       do i=1,ngood
         gpai=f(7,i)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         fdp=(gpai*bpai)/(gcog*bcog)-1.
         trqfi=trqfi+fdp*fdp
         tf=(tcog-f(6,i))*bpai*vl
         tof=tof+tf*tf
         if(f(2,i).gt.chxmx)chxmx=f(2,i)
         if(f(2,i).lt.chxmn)chxmn=f(2,i)
         if(f(4,i).gt.chymx)chymx=f(4,i)
         if(f(4,i).lt.chymn)chymn=f(4,i)
         if(f(6,i)-tcog.gt.chpmx) then
           chpmx=f(6,i)-tcog
           chdmx=chpmx*fh*180./pi
         endif
         if(f(6,i)-tcog.lt.chpmn) then
           chpmn=f(6,i)-tcog
           chdmn=chpmn*fh*180./pi
         endif
         if(f(7,i)-encog.gt.chwmx)chwmx=f(7,i)-encog
         if(f(7,i)-encog.lt.chwmn)chwmn=f(7,i)-encog
       enddo
       trqfi=trqfi/float(ngood)
       tof=tof/float(ngood)
       sprfz(iprf)=sqrt(tof)
       cmult=(gcog+1.)/gcog
       sprfw(iprf)=2.*sqrt(trqfi)*cmult
       sprfp(iprf)=2.*sqrt(exten(3))*180./pi
       sprww(iprf)=cog(1)-xmat
!   t.o.f of the reference in m
       sprfl(iprf)=zpos/1000.
       sprng(iprf)=ngood
!*et*2014-Sep-25 Add recording of min. and max. positions in x,y and z,z'
       sxmx(iprf)=chxmx*10.
       sxmn(iprf)=chxmn*10.
       symx(iprf)=chymx*10.
       symn(iprf)=chymn*10.
       stmx(iprf)=chpmx
       stmn(iprf)=chpmn
       spmx(iprf)=chdmx
       spmn(iprf)=chdmn
       swmx(iprf)=chwmx
       swmn(iprf)=chwmn
!*et*2014-Sep-25 Add recording of energy spread and Wref
       sdwbeam(iprf)=sqrt(exten(10))
       bref=vref/vl
       gref=1./sqrt(1.-bref*bref)
       swref(iprf)=(gref-1.)*xmat
!*et*2017-Feb-05 Add recording of Tref, Tcog, Xbar and Ybar
       stref(iprf)=tref
       stcog(iprf)=tcog
       sxbar(iprf)=10.*cog(4)
       sybar(iprf)=10.*cog(6)
! evolve pointer iprf
       iprf=iprf+1
       if(izrot) call zrotap(-rzot)
       return
       end
!> *******************************************************************
!! SUBROUTINE eugwrt
!! This routine writes the dynac.print file
!< *******************************************************************
       SUBROUTINE eugwrt
       implicit real(8) (a-h,o-z)
       common/pltprf/sprfx(6001),sprfy(6001),sprfl(6001),sprfw(6001),
     *               sprfp(6001),SPRNG(6001),PRLAB(6001),IPRF
       common/pltprf1/sprww(6001),eprfw(6001),eprnx(6001),eprny(6001),
     *                sprfz(6001)
       common/pltprf2/sxmn(6001),sxmx(6001),symn(6001),symx(6001),
     *                stmn(6001),stmx(6001),spmn(6001),spmx(6001),
     *                swmn(6001),swmx(6001),disprx(6001),dispry(6001),
     *            dispcx(6001),dispcy(6001),sdwbeam(6001),swref(6001),
     *            stref(6001),stcog(6001),sxbar(6001),sybar(6001)
       CHARACTER*(8) PRLAB
! l(m) x(mm) y(mm) z(deg) z(mm) Ex(mm.mrd) Ey(mm.mrd) Ez(keV.ns) Wcog(MeV) xmin(mm) xmax(mm) ymin(mm) ymax(mm)
!  tmin(ns) tmax(ns) pmin(deg) pmax(deg) wmin(MeV) wmax(MeV) Dxcog(m) Dycog(m) dW(MeV) Wref(MeV)
       write(71,9)
9      format(1x,'# ELEMENT    l(m)  ',1x,'     x(mm)  ',
     *        1x,'     y(mm)  ',3x,'    z(deg) ',1x,'     z(mm)  ',
     *        2x,'Ex,n,RMS(mm.mrd)',2x,'Ey,n,RMS(mm.mrd)',
     *        1x,'Ez,RMS(keV.ns)',2x,'Wcog(MeV)   ',1x,'#particles',
     *        2x,'xmin(mm)',5x,'xmax(mm)',5x,'ymin(mm)',5x,'ymax(mm)',
     *        5x,'tmin(s)',6x,'tmax(s)',5x,'phmin(deg)',
     *        4x,'phmax(deg)',3x,'Wmin(MeV)',4x,'Wmax(MeV)',
     *        4x,'Dx(m)',8x,'Dy(m)',8x,'dW(MeV)',6x,'Wref(MeV)',
     *        4x,'Tref(s)',6x,'Tcog(s)',6x,'xbar(mm)',5x,'ybar(mm)')
       iprf1=iprf-1
       do i=1,iprf1
!     x and y: cm-->mm
        sprx=sprfx(i)*10./2.
        spry=sprfy(i)*10./2.
        sprp=sprfp(i)/2.
        sprz=sprfz(i)*10.
        write(71,10)prlab(i),sprfl(i),sprx,spry,sprp,sprz,eprnx(i)/4.,
     *              eprny(i)/4.,eprfw(i)/4.,sprww(i),int(sprng(i)),
     *              sxmn(i),sxmx(i),symn(i),symx(i),stmn(i),stmx(i),
     *              spmn(i),spmx(i),swmn(i),swmx(i),
     *              dispcx(i),dispcy(i),sdwbeam(i),swref(i),
     *              stref(i),stcog(i),sxbar(i),sybar(i)
!     *               disprx(i),dispry(i),dispcx(i),dispcy(i)
       enddo
10    format(1x,A8,6(1x,e12.5),2(6x,e12.5),2x,e12.5,1x,i7,3x,
     *       18(1x,e12.5))
!10    format(1x,A8,6(1x,e12.5),2(6x,e12.5),2x,e12.5,1x,i7,3x,
!     *       14(1x,e12.5))
       return
       end
!> *******************************************************************
!! SUBROUTINE etgap
!! single cell of a DTL (CAVSC)
!!
!!   etcell(1)=cell#, etcell(2)=energy (MeV), etcell(3)=beta
!!   etcell(4)=cell length (cm), etcell(5)=T, etcell(6)=TP,
!!   etcell (7)=S, etcell(8)=SP
!!   etcell(9)=quad length (cm), etcell (10)=quad. strength (kG/cm),
!!   etcell(11)=Eo (MV/m), etcell(12)= phase of RF at middle(deg),
!!   etcell(13)= actual length(cm), etcell(14)=TPP,
!!   etcell(15)=frequency (MHz), etcell(16)=field factor
!< *******************************************************************
       SUBROUTINE etgap
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell=3000,maxcell1=4004)
       COMMON/TTFS/DYNT(MAXCELL),DYNTP(MAXCELL),DYNTPP(MAXCELL),
     *   DYNE0(MAXCELL),DYNPH(MAXCELL),DYNLG(MAXCELL),FHPAR,NC
       COMMON/POSI/IST
       COMMON/MIDGAP/ENMIL,VAPMI
       COMMON/AZMTCH/DLG,XMCPH,XMCE
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
!      TRANSIT TIME COEFFICIENTS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/TTFC1/T3K,T4K,S3K,S4K
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *                AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/JACOB/GAKS,GAPS
       common/iter1/DXDKI,DPHII,PHI,DKMSKE,DKMSPHI,RETPH,XKMI,XKM,
     *              DXK00,TKE,T1KE,SKE,S1KE,PHIWC,XK1I,XK1II,XK2II
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/CDEK/DWP(iptsz)
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/compt1/ndtl,ncavmc,ncavnm
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/tapes/in,ifile,meta,ierr
       COMMON/RANEC1/DUMMY(6)
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/speda/dave,idave
       COMMON/SHIF/DTIPH,SHIFT
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/DCSPA/IESP
       COMMON/fct/FAKT
!       common/mode/eflvl,rflvl
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       common/appel/irstay,ilost,iavp,ispcel
       common/posc/xpsc
       common/femt/iemgrw,iemqesg
       common/aerp/vphase,vfield,ierpf
       common/tofev/ttvols
       common/pstpla/tstp
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       character trace3h*128,trace3t*128,tif*128
! --- synchronous particle:
! *****     DWRFS(MeV): energy gain
! *****     SPHRFS(rad): phase jump
! *****     PHRFS(rad):phase RF
! *****       common/parmrf/DWRFS,SPHRFS,PHRFS,ngdrf
       logical iesp,irstay,iavp,ispcel,iemgrw
!         SHIFT =TRUE: cog and synchronous particle are independent
!         SHIFT =FALSE: cog and synchronous particle are coinciding
       LOGICAL SHIFT,CHASIT,ITVOL,IMAMIN,DAVE,ICHAES
       dimension etcell(maxcell)
! --- iesp, irstay, ispcel logical flags used in the routines of space sharge computations
!       iesp=false: accelerating element
!       ispcel = .true.: space charge computation
       iesp=.false.
       irstay=.false.
       ispcel=.true.
       ilost=0
       FACT=1.
       NDTL=NDTL+1
       nrres=nrres+1
! allow for print out on terminal of gap# on one and the same line
       call PROGRESS(NRTRE,NDTL)
       WRITE(16,*)'ACCELERATING GAP N :',NDTL
       read(IN,*) (etcell(iet),iet=1,16)
       FH=etcell(15)
       FAKT=etcell(16)
       fprec=epsilon(FAKT)
       if (abs(FAKT).le.fprec) FAKT=1.e-12
       FH=FH*2.*PI*1000000.
! --- YLG : CELL LENGTH (cm)
! --- YE0 : ELECTRIC FIELD (MV/cm)
       YLG=etcell(4)
       scdist=ylg
       YE0=etcell(11)/100.
!      TRANSIT TIME COEFFICIENTS (at the middle OF THE CELL)
       T0=etcell(5)*YLG*YE0
       TP0=-etcell(6)*YLG*YLG*YE0
       TPP0=-etcell(14)*YLG*YLG*YLG*YE0
!      TRANSIT TIME factors at the ENTRANCE OF THE CELL
!       with kg=2*PI/ylg:
!         TK0=T0*COS(kg*ylg/2) = -T0
!         SK0=T0*SIN(kg*ylg/2) = 0
!         TPK0=d(TK0)/dk
!         SPK0=d(SK0)/dk
!         TPPK0=d(TPK0)/dk
!         SPPK0=d(SPK0)/dk
       TK0=-T0
       SK0=0.
       TPK0=-TP0
       SPK0=-YLG*T0/2.
       TPPK0=YLG*YLG*T0/4.-TPP0
       SPPK0=-YLG*TP0/2.
       TK=TK0
       T1K=TPK0
       T2K=TPPK0
       SK=SK0
       S1K=SPK0
       S2K=SPPK0
       TP3K0=0.
       TP4K0=0.
       SP3K0=0.
       SP4K0=0.
!  MULTIPLY TRANSIT TIME factors WITH FAKT
       T0=T0*FAKT
       TP0=TP0*FAKT
       TPP0=TPP0*FAKT
       TK0=-T0
       TPK0=-TP0
       SPK0=-YLG*T0/2.
       TPPK0=YLG*YLG*T0/4.-TPP0
       SPPK0=-YLG*TP0/2.
       TK=TK0
       T1K=TPK0
       T2K=TPPK0
       SK=SK0
       S1K=SPK0
       S2K=SPPK0
!       IPOINR=IPOINR+1
!   print in file: 'short.data'
! --- ylg : CELL LENGTH (cm) ==> (mm)
! --- ye0 : ELECTRIC FIELD (MV/cm) ==> (Kv/mm)
! --- davtot (mm)
       idav=idav+1
       iitem(idav)=17
       dav1(idav,1)=ylg*10.
       dav1(idav,2)=ye0*100.
       tstp=(davtot+ylg*xpsc)*10.
       davtot=davtot+ylg
       dav1(idav,24)=davtot*10.
! 21.11.09       dav1(idav,40)=fh
       FH0=FH/VL
!      STATISTICS FOR PLOT
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(dav1(idav,24))
       endif
!      reference particle
       iarg=1
       call cdg(iarg)
       ecog=cog(1)
       enold=ecog
       gcog=ecog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       IF(SHIFT) THEN
!        reference particle and cog are independent
         BEREF=VREF/VL
         GAMREF=1./SQRT(1.-(BEREF*BEREF))
         ENREF=XMAT*GAMREF
         TREFDG=TREF*FH*180./PI
         tcogdg=tcog*fh*180./pi
         dav1(idav,3)=1.
       ELSE
!        reference and c.o.g. are coinciding
         vref=bcog*vl
         tref=tcog
         gamref=gcog
         beref=bcog
         enref=cog(1)
         TREFDG=TREF*FH*180./PI
         tcogdg=tcog*fh*180./pi
         dav1(idav,3)=0.
       ENDIF
! --- ttvol: time of flight at entrance (sec)
       ttvol=0.
       if(itvol)ttvol=ttvols*fh
! ***** reference is placed in the position ngdrf=ngood+1 in array f(10,i)
! *****         ngdrf=ngood+1
! *****         BEREF=VREF/VL
! *****         GAMREF=1./SQRT(1.-(BEREF*BEREF))
! *****         ENREF=XMAT*GAMREF
! ****         f(1,ngdrf)=ngdrf
! ****         f(2,ngdrf)=0.
! ****         f(3,ngdrf)=0.
! ****         f(4,ngdrf)=0.
! ****         f(5,ngdrf)=0.
! ****         f(6,ngdrf)=tref
! ****         f(7,ngdrf)=enref
! ****         f(8,ngdrf)=1.
! ****         f(9,ngdrf)=qst
! ****         f(10,ngdrf)=0.
         if(int(dav1(idav,3)).eq.1) write(16,*)
     *   ' ****reference and cog are different'
         if(int(dav1(idav,3)).eq.0) write(16,*)
     *   ' **** reference and cog coincide '
       WRITE(16,178)
178    FORMAT(/,' DYNAMICS AT THE INPUT ',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
       WRITE(16,1788) bcog,gcog,ecog-xmat,tcogdg,tcog
1788   FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       WRITE(16,165) beref,gamref,enref-xmat,TREFDG,TREF
165    FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       tofprt=tref
!      iprint=1: full print ( in case of pbmes)
       iprint=0
       call statis
       XK1=FH/VREF
! ---  predictor of the average beta:BEMY.
       BEREF=VREF/VL
       GAMREF = 1./SQRT(1.-(BEREF*BEREF))
!      DPHASE : PHASE  AT THE MIDDLE OF THE CELL (rad)
       dphete=etcell(12)
       dphase=etcell(12)*pi/180.
! 15/12/09       dpherd=dphase
! 15/12/09       ttvol=0.
! --- The option TOF is passive in the DTL
!   t.o.f. at the middle of the cell
! 15/12/09       if(itvol) then
! 15/12/09        tvolm=ylg/(2.*vref)
! 15/12/09        ttvol=(ttvols+tvolm)
! 15/12/09       endif
! 15/12/09 adjust the phase of RF w.r.t. TOF
! 15/12/09       if(itvol.and.imamin) then
! 15/12/09        odphase=dphase
! 15/12/09        ottvol=fh*ttvol*180./pi
! 15/12/09        attvol=ottvol
! 15/12/09        xkpi=ottvol/360.
! 15/12/09        ixkpi=int(xkpi)
! 15/12/09        xkpi=(xkpi-float(ixkpi))*360.
! 15/12/09        dphase=dphase-xkpi*pi/180.
! 15/12/09       endif
       aqst=abs(qst)
       ddw=aqst*t0*cos(dphase)
       ENREFS=ENREF+DDW
       GAMS= ENREFS/XMAT
       BETS=SQRT(1.-1./(GAMS*GAMS))
       XK2=FH/(BETS*VL)
       BEMY=(GAMS*BETS+GAMREF*BEREF)/(GAMS+GAMREF)
       XKM=FH/(BEMY*VL)
       XKG=2.*PI/YLG
! --- average phase of RF at entrance
       saphi=dphase
       SAPHO=SAPHI
       EQVL=YLG
       DKG=(XKM-XKG)
       DTS=TP0/T0
       FK1=2.*DTS
       FPK0=(TP0*TP0+T0*TPP0)/(T0*T0)
       FPK1=2.*TP0**2/(T0*T0)
       FPK=2.*(FPK0-FPK1)
       PCREST=ATAN(-SK/TK)
       DDW=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))/2.
       IF(DDW.LT.0.) PCREST=PCREST+PI
       PEQVL=YLG/2.
       SCLEN=YLG
! 15/12/09       if(.not.imamin) then
        WRITE(16,1555)FH/(2.*pi),YLG,DPHASE*180./PI
1555    FORMAT(4X,'FREQENCY :',E12.5,' Hertz',/,4x,
     x        'GAP LENGTH :',e12.5,' cm',/,4x,
     x        'PHASE of RF (middle of the gap)  :',e12.5,'deg',/)
! 15/12/09       else
! 15/12/09        WRITE(16,1556)FH/(2.*pi),YLG,DPHASE*180./PI,odphase
! 15/12/09 1556    FORMAT(4X,'FREQENCY :',E12.5,' Hertz',/,4x,
! 15/12/09     x        'GAP LENGTH :',e12.5,' cm',/,4x,
! 15/12/09     x        'phase of RF after adjustement:',e12.5,'deg',/,4x,
! 15/12/09     *        'phase of RF before adjustment',e12.5,'deg')
! 15/12/09       endif
! ---  Follow ITERATIONS giving:
!            The equivalent field length   (cm)
!            The asociated drift length    (cm)
!            The slip of phase             (rd)
!            The energy gain               (MeV)
!            The phase jump                (rd)
!            The average k                 (cm-1)
!            The transit time coefficients (MeV,cm)
!            The phase crest               (rad)
!            The phase offset at entrance  (rad)
       EQVL=YLG
       DKG=(XKM-XKG)
       FPK=2.*(FPK0-FPK1)
       TIL2=0.
       DO IT=1,3
!        slip of phase and equivalent field length
         IF(IT.EQ.1) PHSLIP=-4.*ATAN(3.2*DTS/EQVL)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           TIL2=PHSLIP/2.
           DO IIII=1,4
             GX=1./TAN(TIL2)-1./TIL2
             GPX=-1./(SIN(TIL2)*SIN(TIL2)) + 1./(TIL2*TIL2)
             GPPX=2.*COS(TIL2)/(SIN(TIL2)**3) - 2./(TIL2*TIL2*TIL2)
             HX=GPX/(GX*GX) -2.*FPK/(FK1**2)
             DHX=-(2.*GX*GPX*GPX-GX*GX*GPPX)/(GX**4)
             TIL2=TIL2-HX/DHX
             EQVL=SQRT(ABS(2.*FPK/GPX))
             IF(ABS(HX).LE.1.E-05) EXIT
           ENDDO
           PHSLIP=TIL2*2.
         ENDIF
         PEQVL=YLG/2.
         ASDL=PEQVL-EQVL/2.
!      ENERGY GAIN AND PHASE JUMP (i.e. DELPHR)
         saphi=sapho-pcrest+ttvol
         F0=XITL0(GAMREF,GAMS,BEMY,SAPHI,AQST)
         DELWRM=(F0-GAMREF)*XMAT
         ENRS=ENREF+DELWRM
         GAMS= ENRS/XMAT
         bets=sqrt(1.-1./(gams*gams))
         xk2=fh0/bets
         coeph=fh*aqst/(vl*xmat)
         F2=XITL2(GAMREF,GAMS,BEMY,SAPHI,AQST)
         DELPHR= COEPH * F2
         XKM=DELPHR/EQVL + XK2*(1.+ASDL/EQVL) - XK1*ASDL/EQVL
         BEMY=FH0/XKM
!    TRANSIT TIME FACTORS
         DKG=(XKM-XKG)
         TK=TK0+DKG*TPK0+DKG*DKG*TPPK0/2.+DKG**3*TP3K0/6.+
     X     DKG**4*TP4K0/24.
         T1K=TPK0+DKG*TPPK0+DKG*DKG*TP3K0/2.+DKG**3*TP4K0/6.
         T2K=TPPK0+DKG*TP3K0+DKG*DKG*TP4K0/2.
         T3K=TP3K0+DKG*TP4K0
         T4K=TP4K0
         SK=SK0+DKG*SPK0+DKG*DKG*SPPK0/2.+DKG**3*SP3K0/6.+
     X     DKG**4*SP4K0/24.
         S1K=SPK0+DKG*SPPK0+DKG*DKG*SP3K0/2.+DKG**3*SP4K0/6.
         S2K=SPPK0+DKG*SP3K0+DKG*DKG*SP4K0/2.
         S3K=SP3K0+DKG*SP4K0
         S4K=SP4K0
!      PHASE CREST
         PCREST=ATAN(-SK/TK)
         DDW=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))/2.
         IF(DDW.LT.0.) PCREST=PCREST+PI
       ENDDO
!      CREST VALUE = SQCTTF*(PHSLIP/2)/SIN(PHSLIP/2)
       SQCTTF=TIL2*SQRT(TK*TK+SK*SK)/SIN(TIL2) *2.
!      THE synchronous particle IS BASED ON CHARGE STATE : QMOY =AQST
       CFH=FH/(VL*2.*XMAT)
       CKH=QMOY*QMOY/(4.*XMAT*XMAT)
       call gap(gamref,saphi,gams,delphr)
!      output of the element
!  new PHARES,TREFS to be in accordance with GENAC
       PHARES=SAPHI+FH*YLG/VREF+DELPHR
       trefs=tref+ylg/(bets*vl)+delphr/fh
       PHARED=(PHARES-SAPHI)*180./PI
       TREDG=fh*TREFS *180./PI
       write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
       write(16,*) '************************************************'
       write(16,*) ' ENERGY GAIN(MeV): ',delwrm,' TOF(DEG) ',tredg
!       write(16,*) ' PHASE JUMP(DEG): ',sphrfs*180./PI
       write(16,*) ' CREST PHASE OF RF (DG): ',
     *               PCREST*180./PI
       write(16,*) ' PHASE OF RF AT THE MIDDLE (DG): ',sapho*180./pi
       write(16,*) ' PHASE OF RF AT THE ENTRANCE (DG): ',saphi*180./pi
       write(16,*) ' AVERAGE k (cm-1) (freq./velocity): ',XKM
       write(16,*) ' TRANSIT TIME FACTORS (MeV-cm):'
       write(16,*) ' T dT/dk d2T/dk2 ',TK,T1K,T2K
       WRITE(16,*) ' S dS/dk d2S/dk2 ',SK,S1K,S2K
       write(16,*) ' PHASE SLIP(DEG) ',PHSLIP*180./PI
       write(16,*)
       write(16,*) ' PARAMETERS RELATING TO THE EQUIVALENT FIELD '
       write(16,*) '************************************************'
       WRITE(16,171)EQVL
171    FORMAT(' length :',e12.5,' cm ')
       write(16,*) ' Associated drift length: ',asdl,' cm'
       WRITE(16,*)' magnitude: ',SQCTTF,' MV/cm'
        iarg=1
        call cdg(iarg)
        encog=cog(1)
        gcog=encog/xmat
        bcog=sqrt(1.-1./(gcog*gcog))
        tcog=cog(3)
        CALL EXT2D(1)
! sup        phnew=-(int(tcog*fh/pi+0.5)-tcog*fh/pi)*180.
! sup        dav1(idav,7)=phnew
        dav1(idav,37)=saphi*180./pi
! 15/12/09        if(itvol) then
! 15/12/09        dav1(idav,38)=dphete
! 15/12/09        dav1(idav,39)=dphase*180./pi
! 15/12/09        else
        dav1(idav,38)=dphete
! 15/12/09        endif
!  end print in the file: 'short.data'
       WRITE(16,3777)
3777   FORMAT(/,3X,3(1H*),' DYNAMICS AT THE OUTPUT: ',/,
     2 5X,'   BETA     dW(MeV)    ENERGY(MeV) ',
     4 '   TOF(deg)     TOF(sec)')
       write(16,3473) bets,delwrm,enrs-xmat,fh*trefs*180./pi,trefs
3473   FORMAT(' REF ',f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)
       WRITE(16,1789) bcog,encog-enold,encog-xmat,tcog*fh*180./pi,tcog
1789   FORMAT(' COG ',f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)
! trace3d
! split cell into drif-gap-drift
       kt3t=kt3t+1
       write(tif,6001) kt3t,kt3t,10.*etcell(4)/2.
6001   format('  nt(',i4,')= 1, a(1,',i4,')=',f12.6)
       trace3t(kt3t)=tif
!
       trphase=etcell(12)
!       tre0tl=etcell(11)*etcell(5)*etcell(4)/100.
       tre0tl=delwrm/cos(pi*trphase/180.)
       kt3t=kt3t+1
       write(tif,6005) kt3t,kt3t,tre0tl,trphase,fid
6005   format('  nt(',i4,')=10, a(1,',i4,')=',f9.5,' , ',f9.2,
     &        ', 1., 1.,',f5.3,',')
       trace3t(kt3t)=tif
!
       kt3t=kt3t+1
       write(tif,6001) kt3t,kt3t,10.*etcell(4)/2.
       trace3t(kt3t)=tif
! end trace3d drift-gap-drift
       TESTCA=exten(1)*exten(2)*exten(3)
       epsil=1.E-40
       IF(abs(TESTCA).gt.epsil) THEN
         qdisp=2.*sqrt(exten(1))
         qmd=exten(1)*exten(3)-exten(2)**2
         SQMDV=4.*PI*SQRT(QMD)
         SURM=4.*PI*SQRT(QMD)*180./PI
         qdp=2.*sqrt(exten(3))
         cor12=exten(2)/sqrt(exten(1)*exten(3))
         QDPDE=QDP*180./PI
       ELSE
         QDISP=0.
         QMD=0.
         SQMDV=0.
         SURM=0.
         QDP=0.
         COR12=0.
         PENT12=0.
         PENT21=0.
         QDPDE=0.
       ENDIF
       TRQTX=exten(4)*exten(5)-exten(8)**2
       TRQPY=exten(6)*exten(7)-exten(9)**2
       QDITAX=2.*SQRT(exten(4))
       QDIANT=2.*SQRT(exten(5))
       QDITAY=2.*SQRT(exten(6))
       QDIANP=2.*SQRT(exten(7))
       SURXTH=4.*PI*SQRT(TRQTX)
       SURYPH=4.*PI*SQRT(TRQPY)
       IF(SHIFT) THEN
         vref=bets*vl
         tref=trefs
       ELSE
         vref=bcog*vl
         tref=tcog
       ENDIF
       if(itvol) then
        ttvols=tref
! 15/12/09        attvol=fh*ttvols*180./pi
! 15/12/09        write(16,7456) ottvol,attvol
       endif
! 15/12/09 7456   format(2x,'***tof at input: ',e12.5,' deg',/,
! 15/12/09     *           2x,'***tof at output: ',e12.5,' deg')
       call statis
!      PROFIL (plot)
       PRLAB(IPRF)='CAVSC   '
       CALL STAPL(dav1(idav,24))
       dltaw=qdisp*xmat*bcog*bcog/sqrt(1.-bcog*bcog)
! sup       WRITE(16,9998) SQMDV
! sup9998   FORMAT(2X,'   EMITTANCE (norm): ',
! sup     *        E12.5,' PI*MEV*RAD')
!   print in the file: 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!  dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
       dav1(idav,16)=bcog*surxth*10./(pi*sqrt(1.-bcog*bcog))
!  dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
       dav1(idav,21)=bcog*suryph*10./(pi*sqrt(1.-bcog*bcog))
       dav1(idav,25)=ndtl
       emns=1.e12*sqmdv/(pi*fh)
       trfprt=fh*tref*180./pi
       tcgprt=fh*tcog*180./pi
!       n2kp=int(tofprt/360.)
!       tofprt=tofprt-float(n2kp)*360.
!       if(tofprt.gt.180.) tofprt=tofprt-360.
! cavity number, z(m), transmission (%), synchronous phase (deg), time of flight (deg) (cog), COG relativistic beta (@ output)
! COG output energy (MeV), time of flight (deg) (REF), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
       trnsms=100.*float(ngood)/float(imax)
       if(ndtl.eq.1) write(50,*) '# gap.dmp'
       if(ndtl.eq.1) write(50,*) '# gap     Z       trans   ',
     *   'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ',
     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
     *   'El,RMS        dWref        EffVolt'
       if(ndtl.eq.1) write(50,*) '#  #     (m)       (%)    ',
     *  '(deg)     (deg)        beta     (MeV)          (deg)      ',
     *  '   beta        (MeV)      (mm.mrad)    (mm.mrad)    ',
     *  '(ns.keV)      (MeV)          (MV)'
       write(50,7023) ndtl,0.01*davtot,trnsms,dphete,tcgprt,
     *  bcog,encog-xmat,trfprt,bets,enrs-xmat,
     *  0.25*dav1(idav,16),0.25*dav1(idav,21),0.25*emns,delwrm,tre0tl
7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
     *   2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x))
!      RIGIDITY of the ref. prtcle
       gref=1./sqrt(1.-bets*bets)
       XMOR=XMAT*bets*gref
       BORO=33.356*XMOR*1.E-01/QST
       WRITE(16,*) ilost,' particles are lost in element ',ndtl
       write(16,*)
       call emiprt(0)
       return
       end
!> *******************************************************************
!! SUBROUTINE gap(GAMREF,SAPHI,GAMS,DELPHR)
!! ETGAP or RESTAY ==> GAP
!! dynamics in the accelerating element
!< *******************************************************************
       SUBROUTINE gap(GAMREF,SAPHI,GAMS,DELPHR)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell=3000,maxcell1=4004)
       COMMON/TTFS/DYNT(MAXCELL),DYNTP(MAXCELL),DYNTPP(MAXCELL),
     *   DYNE0(MAXCELL),DYNPH(MAXCELL),DYNLG(MAXCELL),FHPAR,NC
       COMMON/POSI/IST
       COMMON/MIDGAP/ENMIL,VAPMI
       COMMON/AZMTCH/DLG,XMCPH,XMCE
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
!      TRANSIT TIME COEFFICIENTS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
! ***************************************************************
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *                AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/JACOB/GAKS,GAPS
       common/iter1/DXDKI,DPHII,PHI,DKMSKE,DKMSPHI,RETPH,XKMI,XKM,
     *              DXK00,TKE,T1KE,SKE,S1KE,PHIWC,XK1I,XK1II,XK2II
!         functions in COS(DXDPT)
       common/iterco/YH11T,YH1K1T,YH1K01T,YH10PKT,YH11PKT,YH1P1T,
     *                H1AKIT,H1AKIMT,H1AKMT,HAPIT,HAPPIT
!         functions in SIN(DXDPT)
       common/itersi/YH21T,YH2K1T,YH2K01T,YH2P1T,YH20PKT,YH21PKT,
     *                H1BKIT,H1BKIMT,H1BKMT,HBPIT,HBPPIT
       common/tranrs/SA11,SA12,SA21,SA22,SACT11,SACT12,SACT21,SACT22
! --- routine XTYPL1
       COMMON/TYPL1/YH1K0,YH1K1,YP1K1,YP1K2,YH1K00,YH1K01,YP1K01,
     X              YP1K02,YH10,YH11,YP11,YP12
       COMMON/TYPL2/YH2K0,YH2K1,YP2K1,YP2K2,YH2K00,YH2K01,YP2K01,
     X              YP2K02,YH20,YH21,YP21,YP22
       COMMON/TYPI1/YE1K0,YE1K1,YE1K2,YE1KC0,YE1KC1,YE1KC2,
     X              YE10,YE11,YE12
       COMMON/TYPI2/YE2K0,YE2K1,YE2K2,YE2KC0,YE2KC1,YE2KC2,
     X              YE20,YE21,YE22
       COMMON/THAD2/H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM,
     X              H1AKI,H1AKIM,H1AKM,H1BKI,H1BKIM,H1BKM
! --- routine XTYPLP1
       COMMON/TYPLP1/YH1P1,YH2P1,HAPI,HBPI
! --- routine XTYPL2
       COMMON/TYPLP2/HAPPI,HBPPI
! --- routine XTYLPK
       COMMON/TYPLPK/YH10PK,YH11PK,YH20PK,YH21PK
!     Integrals of E(z)**2
! --- routine XTYPJ
       COMMON/TYPJ/YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2,
     X              YFSKC0,YFSKC1,YFSKC2,YFSCK0,YFSCK1,YFSCK2,
     X              YFSCP0,YFSCP1,YFSCP2,YFS0,YFS1,YFS2
! --- routine XTYPM
       COMMON/TYPM/YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2,
     X              YNSK0C,YNSK1C,YNSK2C,YNS0,YNS1,YNS2
! ********************************************************************
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/BEAMSA/FS(7,iptsz)
       COMMON/CDEK/DWP(iptsz)
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON /CONSTA/ VL, PI, XMAT, RPEL,QST
       COMMON/DYN/TREF,VREF
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/speda/dave,idave
       COMMON/SHIF/DTIPH,SHIFT
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/DCSPA/IESP
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/appel/irstay,ilost,iavp,ispcel
       common/posc/xpsc
       common/pstpla/tstp
       common/rander/ialin
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       logical iesp,ichaes,irstay,iavp,ispcel,ialin
       LOGICAL SHIFT,CHASIT,ITVOL,IMAMIN,DAVE
       CHARACTER*(8) PRTLAB
! *****      DWRFS(MeV):  gain of energy of the fictitious reference
! *****     SPHRFS(rad): phase jump
! *****      PHRFS(rad):  phase
! *****     NGDRF:  position of the reference in the array f(10,iptsz)
! ****       common/parmrf/DWRFS,SPHRFS,PHRFS,ngdrf
       FH0=FH/VL
!   iesp is used in s.c. routines : iesp=.false. == > accel. element
       iesp=.false.
       iavp=.true.
       ipas=2
       DCUM=YLG
       PRTLAB='GAP     '
!       random errors in alignment
       if(ialin) call randali
!       Random variation on the phase for each particle
       VARPHA=0.
!   INTEGRALS REQUIRED BY THE EXPANSIONS IN LONGITUDINAL MOTION (ALL THE ELEMENT)
!   ( computations of the average k and slip of phase from which are computed deltk delphi,..)
!    *   valero 08/08/07
       aqmoy=abs(qst)
!omment       aqmoy=qst
!    *
       CALL XTYPL1(GAMREF,SAPHI,AQMOY,DCUM)
!  see here equations 88 and 106 of Part. Acc. 1994 vol44 pp215-255
       CXLG=aqmoy/(4.*XMAT*EQVL)
       GAMI=GAMREF
       DKMP= (GAMI*GAMI-1.)**(1.5)*(GAMS*GAMS-1.)**(-1.5)
       DKMS= DKMP*(1.+ASDL/EQVL)
     X       +YH1K01*FH0*CXLG/EQVL -ASDL/EQVL
       DKM1= -GAKS*(GAMS*GAMS-1.)**(-1.5)*FH0*(1.+ASDL/EQVL)
!    DKMSKE :(eq.106, see article of Part.Acc.)
       DKMSKE=DKMS/(1.-YH1K1*CXLG*FH0/EQVL-DKM1)
       CALL XTYPL2(GAMREF,SAPHI,AQMOY,DCUM)
       CALL XTYPLP1(GAMREF,SAPHI,AQMOY,DCUM)
       CALL XTYLPK(GAMREF,SAPHI,AQMOY,DCUM)
       dphsph1=(yh1p1-yh21)*cxlg*fh0
       DKMSPHI=-FH0*(GAMS*GAMS-1.)**(-1.5)*GAPS*(1.+ASDL/EQVL)+
     X          DPHSPH1/EQVL
!   These integrals are saved
       gakst=gaks
       gapst=gaps
!         functions in COS(DXDPT)
       YH11T=YH11
       YH1K1T=YH1K1
       YH1K01T=YH1K01
       YH10PKT=YH10PK
       YH11PKT=YH11PK
       YH1P1T=YH1P1
       H1AKIT=H1AKI
       H1AKIMT=H1AKIM
       H1AKMT=H1AKM
       HAPIT=HAPI
       HAPPIT=HAPPI
!         functions in SIN(DXDPT)
       YH21T=YH21
       YH2K1T=YH2K1
       YH2K01T=YH2K01
       YH2P1T=YH2P1
       YH20PKT=YH20PK
       YH21PKT=YH21PK
       H1BKIT=H1BKI
       H1BKIMT=H1BKIM
       H1BKMT=H1BKM
       HBPIT=HBPI
       HBPPIT=HBPPI
       if(ichaes.and.ispcel) then
         ipas=1
         write(16,*)'  SPACE CHARGE ACTING ON LENGTH: ',scdist,' CM'
         dcum=ylg*xpsc
         write(16,*)'  POSITION OF S.C. COMPUTATION:  ',dcum,' CM'
!     computation of the integrals in the middle of the cavity
! INTEGRALS  E(z)*(BG)**-3 *z**n   n=0,1
! INTEGRALS  dE(z)/dt*(BG)**-3 *z**n   n=0,1,2
         call xtypl1(gamref,saphi,aqmoy,dcum)
         istm=ist-1
!     INTEGRALS ON SECOND DERIVATIVES k HA0(Z) & HB0(Z)
         call xtypl2(gamref,saphi,aqmoy,dcum)
!      1st,2nd,3rd DERIVATIVES ON PHASE,HA0(Z) & HB0(Z)
         call xtyplp1(gamref,saphi,aqmoy,dcum)
!    DERIVATIVES  COUPLED ON PHASE, K FUNCTIONS HA0(Z) & HB0(Z)
         call xtylpk(gamref,saphi,aqmoy,dcum)
!     TRANSVERSE INTEGRALS  TYPE J & M
         call xtypj(gamref,saphi,aqmoy,dcum)
         call xtypm(gamref,saphi,aqmoy,dcum)
       endif
       DO
         if(ipas.eq.2) then
           dcum=ylg
           gaks=gakst
           gaps=gapst
! --- COS(DXDPT)
           yh11=yh11t
           yh1k1=yh1k1t
           yh1k01=yh1k01t
           yh10pk=yh10pkt
           yh11pk=yh11pkt
           yh1p1=yh1p1t
           h1aki=h1akit
           h1akim=h1akimt
           h1akm=h1akmt
           hapi=hapit
           happi=happit
! ---  SIN(DXDPT)
           yh21=yh21t
           yh2k1=yh2k1t
           yh2k01=yh2k01t
           yh2p1=yh2p1t
           yh20pk=yh20pkt
           yh21pk=yh21pkt
           h1bki=h1bkit
           h1bkim=h1bkimt
           h1bkm=h1bkmt
           hbpi=hbpit
           hbppi=hbppit
           call xtypl1(gamref,saphi,aqmoy,dcum)
!     INTEGRALS ON SECOND DERIVATIVES k HA0(Z) & HB0(Z)
           call xtypl2(gamref,saphi,aqmoy,dcum)
!      1st,2nd,3rd DERIVATIVES ON PHASE,HA0(Z) & HB0(Z)
           call xtyplp1(gamref,saphi,aqmoy,dcum)
!    DERIVATIVES  COUPLED ON PHASE, K FUNCTIONS HA0(Z) & HB0(Z)
           call xtylpk(gamref,saphi,aqmoy,dcum)
!       TRANSVERSE INTEGRALS  TYPE J & M
           call xtypj(gamref,saphi,aqmoy,dcum)
           call xtypm(gamref,saphi,aqmoy,dcum)
         endif
         SA11=1.
         SA12=0.
         SA21=0.
         SA22=1.
         SACT11=1.
         SACT12=0.
         SACT21=0.
         SACT22=1.
!    SAVE BEAM
         do is=1,ngood
           do js=1,7
             fs(js,is)=f(js,is)
           enddo
         enddo
         call boucle(ipas,gamref,saphi,dcum,delphr)
!  Reshuffles f(i,j) array after boucle
         call shuffle
         IF(IPAS.EQ.1) THEN
!   compute the space charge on the beam (except the reference)
!  call stapl at the position of space charge computation
!*et*26-Jul-2014         call stapl(tstp)
           if(iscsp.eq.1) then
             ini=1
             call hersc(ini)
             ini=2
             call hersc(ini)
           endif
           if(iscsp.eq.2) CALL SCHERMI
           if(iscsp.eq.3) CALL SCHEFF1(1)
! -----  window control
           write(16,*) 'Checking for lost particles'
           call reject(ilost,PRTLAB)
!    second step of the gap
           ipas=2
           iavp=.false.
         ELSE
!      end of space charge computation
           exit
         ENDIF
       ENDDO
!       charateristics of the beam
! 18/03/2009       if (dave) then
! 18/03/2009         gimax=f(7,ngood)/xmat
! 18/03/2009         bimax=sqrt(1.-1./(gimax*gimax))
! 18/03/2009         dav1(idav,3)=bimax
! 18/03/2009         dav1(idav,4)=f(7,ngood)-xmat
! 18/03/2009         dav1(idav,5)=-(INT(f(6,ngood)*FH/PI+0.5)-
! 18/03/2009     *                f(6,ngood)*FH/PI)*180.
! 18/03/2009         dav1(idav,38)=dphase*180./pi
! 18/03/2009       endif
! ----       WINDOW CONTROL
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE cogetc
!! COG of TOF with respect to the various charge states
!< *******************************************************************
       SUBROUTINE cogetc
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       itot=0
       n=1
       do i=1,20
         nbch(i)=0
       enddo
       charm(n)=f(9,1)
100    continue
       do i=1,ngood
         if(int(f(9,i)).eq.int(charm(n))) nbch(n)=nbch(n)+1
       enddo
!   the following charge states
       itot=itot+nbch(n)
       if(itot.lt.ngood) then
         do i=1,ngood
           do j=1,n
             if(int(f(9,i)).eq.int(charm(j))) go to 120
           enddo
           if(int(f(9,i)).ne.int(charm(n))) then
             n=n+1
             charm(n)=f(9,i)
             go to 100
           endif
120        continue
         enddo
       endif
!   compute the cog of TOF for each charge state
       do i=1,n
         cgtdv(i)=0.
         do j=1,ngood
           if(int(f(9,j)).eq.int(charm(i))) cgtdv(i)=cgtdv(i)+f(6,j)
         enddo
         cgtdv(i)=cgtdv(i)/float(nbch(i))
!        write(16,*)'i,nch,cgtdv=',i,nbch(i),cgtdv(i),charm(i)
       enddo
       netac=n
       return
       end
!> *******************************************************************
!! SUBROUTINE boucle(ipas,gamref,saphi,dcum,delphr)
!! RESTAY or ETGAP ==> GAP ==> BOUCLE
!! compute the dynamics of the fictitious reference and of particles
!< *******************************************************************
       SUBROUTINE boucle(ipas,gamref,saphi,dcum,delphr)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/POSI/IST
       COMMON/MIDGAP/ENMIL,VAPMI
       COMMON/AZMTCH/DLG,XMCPH,XMCE
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/ITVOLE/ITVOL,IMAMIN
       common/iter1/DXDKI,DPHII,PHI,DKMSKE,DKMSPHI,RETPH,XKMI,XKM,
     *              DXK00,TKE,T1KE,SKE,S1KE,PHIWC,XK1I,XK1II,XK2II
       common/tranrs/SA11,SA12,SA21,SA22,SACT11,SACT12,SACT21,SACT22
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       common/blvl/bflvl
!      TRANSIT TIME COEFFICIENTS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/TTFCB/T3K,T4K,S3K,S4K
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *                AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/JACOB/GAKS,GAPS
       COMMON/TYPL1/YH1K0,YH1K1,YP1K1,YP1K2,YH1K00,YH1K01,YP1K01,
     X              YP1K02,YH10,YH11,YP11,YP12
       COMMON/TYPL2/YH2K0,YH2K1,YP2K1,YP2K2,YH2K00,YH2K01,YP2K01,
     X              YP2K02,YH20,YH21,YP21,YP22
       COMMON/TYPI1/YE1K0,YE1K1,YE1K2,YE1KC0,YE1KC1,YE1KC2,
     X              YE10,YE11,YE12
       COMMON/TYPI2/YE2K0,YE2K1,YE2K2,YE2KC0,YE2KC1,YE2KC2,
     X              YE20,YE21,YE22
       COMMON/THAD2/H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM,
     X              H1AKI,H1AKIM,H1AKM,H1BKI,H1BKIM,H1BKM
! --- routine XTYPLP1
       COMMON/TYPLP1/YH1P1,YH2P1,HAPI,HBPI
! --- routine XTYPL2
       COMMON/TYPLP2/HAPPI,HBPPI
! --- routine XTYLPK
       COMMON/TYPLPK/YH10PK,YH11PK,YH20PK,YH21PK
!     integrals of E(z)**2
! --- routine XTYPJ
       COMMON/TYPJ/YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2,
     X              YFSKC0,YFSKC1,YFSKC2,YFSCK0,YFSCK1,YFSCK2,
     X              YFSCP0,YFSCP1,YFSCP2,YFS0,YFS1,YFS2
!     E(z)**2 INTEGRALS (COMPLEMENTARY ELECTRIC FIELD)
! --- routine XTYPM
       COMMON/TYPM/YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2,
     X              YNSK0C,YNSK1C,YNSK2C,YNS0,YNS1,YNS2
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/BEAMSA/FS(7,iptsz)
       COMMON/CDEK/DWP(iptsz)
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/CONSTA/ VL, PI, XMAT, RPEL,QST
       COMMON/DYN/TREF,VREF
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/tapes/in,ifile,meta,ierr
       COMMON/DCSPA/IESP
       common/tcav/SV1P(iptsz),SV2P(iptsz),SXV1P(iptsz),SXV2P(iptsz),
     *       DWCIS(iptsz),BEINI1(iptsz),PHIP(iptsz),
     *       TEGLP(iptsz),DXDPIP(iptsz),DXDKIP(iptsz),
     *       DXDPTP(iptsz),DXK00P(iptsz),DPHIIP(iptsz),sauphcs(iptsz)
       common/iterco/YH11T,YH1K1T,YH1K01T,YH10PKT,YH11PKT,YH1P1T,
     *                H1AKIT,H1AKIMT,H1AKMT,HAPIT,HAPPIT
       common/itersi/YH21T,YH2K1T,YH2K01T,YH2P1T,YH20PKT,YH21PKT,
     *                H1BKIT,H1BKIMT,H1BKMT,HBPIT,HBPPIT
       common/appel/irstay,ilost,iavp,ispcel
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       common/tofev/ttvols
       common/aerp/vphase,vfield,ierpf
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
! 2018-Feb-2018
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
! *****     DWRFS(MeV): gain of energy of the fictitious reference
! *****     SPHRFS(rad):phase jump
! *****     PHRFS(rad):phase
! *****     NGDRF:  position of the reference in the array f(10,iptsz)
! *****       common/parmrf/DWRFS,SPHRFS,PHRFS,ngdrf
       logical itvol,imamin,ispcel
       logical iesp,iavp,ichaes,irstay
       dimension vecx(1)
       character*(8) PRTLAB
       dimension lossreason(iptsz)
! lossreason= -2 --> energy       
! lossreason= -1 --> phase       
! lossreason=  0 --> not lost       
! lossreason=  1 --> radius       
! lossreason=  2 --> x position       
! lossreason=  3 --> y position
       PRTLAB='CAV     '       
       ttvol=ttvols*fh
       FH0=FH/VL
       beref=sqrt(1.-1./(gamref*gamref))
       call cogetc
       tcog=0.
       gcog=0.
       do i=1,ngood
         gcog=gcog+f(7,i)/xmat
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       gcog=gcog/float(ngood)
       bcog=sqrt(1.-1./(gcog*gcog))
       wcg=(gcog-1.)*xmat
! ----- convert wdisp in dp/p (window control)
! ---- ifw = 0  ===> wdisp = dW/W, where this is w.r.t. the COG 
! ---- ifw = 1  ===> wdisp = dW (MeV), where this is w.r.t. the COG
! ---- ifw = 10 ===> wdisp = dW/W, where this is w.r.t. the reference
! ---- ifw = 11 ===> wdisp = dW (MeV), where this is w.r.t. the reference
! ----- convert wdisp in dp/p
       if(ifw.eq.0) dispr=gcog*gcog*wdisp/(gcog*(gcog+1.))
       if(ifw.eq.1) dispr=gcog*gcog*wdisp/(gcog*(gcog+1.)*wcg)
       if(ifw.eq.10)dispr=gamref*gamref*wdisp/(gamref*(gamref+1.))
       if(ifw.eq.11)dispr=gamref*gamref*wdisp/(gamref*(gamref+1.)*wcg)

       DO 19 I=1,ngood
         IF(I.EQ.ICONT) THEN
           WRITE(16,*)'******************************************'
           WRITE(16,*)'*** FOLLOWED PARTICLE NUMBER: ',I
           IF(IPAS.EQ.1)
     *         WRITE(16,*) ' AT SPACE CHARGE POSITION'
           IF(IPAS.EQ.2) WRITE(16,*) ' AT OUTPUT '
           WRITE(16,*)'******************************************'
         ENDIF
         if(iavp) then
           gini=f(7,i)/xmat
           beini=sqrt(1.-1./(gini*gini))
           fd(i)=(gini*beini)/(gcog*bcog)
           f6i=0.
           do istc=1,netac
             if(int(f(9,i)).eq.int(charm(istc)))
     *        f6i=f(6,i)-cgtdv(istc)
           enddo
!       LONGITUDINAL WINDOW CONTROL
           if(fh*abs(f6i).ge.wphas) then
             f(8,i)=0.
             lossreason(i)=-1                      
           endif  
           IF(ABS(FD(I)-1.).GE.DISPR) then
             f(8,i)=0.
             lossreason(i)=-2                      
           endif  
!       TRANSVERSE WINDOW CONTROL
           RADIU=SQRT(F(2,I)*F(2,I)+F(4,I)*F(4,I))
           if(RADIU.gt.rlim) then
             f(8,i)=0.
             lossreason(i)=1                      
           endif  
           if(abs(f(2,i)).gt.wx) then
             f(8,i)=0.
             lossreason(i)=2                      
           endif  
           if(abs(f(4,i)).gt.wy) then
             f(8,i)=0.
             lossreason(i)=3                      
           endif  
!           if(f(8,i).eq.0) then
           if(int(f(8,i)).eq.0) then
             write(49,3928) PRTLAB,NRRES,davtot/100.,i,int(f(1,i)),
     *       f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180./pi,f(7,i)-xmat,
     *       f(9,i),lossreason(i)     
3928         FORMAT(1x,A8,1x,I4,1x,E12.5,1x,i5,1x,i5,1x,6(f12.3,1x),
     *              1x,f5.2,3x,i2)
             ilost=ilost+1
             if(ilost.ge.ngood) stop
             go to 19
           endif
!   COMPUTATION OF AVERAGE K AND JUMP OF PHASE FOR THE CELL
!  START IF BLOCK on ICONT
           IF(I.EQ.ICONT) THEN
             WRITE(16,558) F(2,I),F(3,I),F(4,I),F(5,I)
558          FORMAT(1x,'* INPUT OF THE ELEMENT: ',/,1x,
     X       '* X :',E12.5,' CM  XP :',E12.5,' MRD',/,1x,
     X       '* Y :',E12.5,' CM  YP: ',E12.5,' MRD',/,1x,'*')
              f6dg=fh*f(6,i)*180./pi
             WRITE(16,*)' Tof(deg): ',f6dg,' ENER(MeV) ',f(7,i)-xmat
           ENDIF
           RADIU=SQRT(F(2,I)*F(2,I)+F(4,I)*F(4,I))
           IF(RADIU.LT.1.e-06) THEN
             DRADIU=.001*SQRT(F(3,I)*F(3,I)+F(5,I)*F(5,I))
           ELSE
             DRADIU=F(3,I)*.001*F(2,I)/RADIU+F(4,I)*F(5,I)*.001/RADIU
           ENDIF
! --- retph: phase delay between the actual particle  and the reference
           RETPH=FH*(f(6,i)-TREF)
! --- systematic or random defaults on the phase RF (not for the reference)
           if(ierpf.ne.0) then
             vphasi=vphase*pi/180.
! --- systematic default on the phase offset
             if(ierpf.eq.1) retph=retph+vphasi
! --- random error on  phase offset
             if(ierpf.gt.1) then
               len=1
               call rlux(vecx,len)
               r1=(2.*vecx(1)-1.)*vphasi
               retph=retph+r1
             endif
           endif
           PHI=SAPHI+RETPH
           IF(I.EQ.ICONT) write(16,*)
     *    '* PHASE DELAY RELATIVE TO REFERENCE ',retph*180./pi,' DEG'
! --- the TTF are the ones of the reference particle based on the charge state qst (input)
! ---  They are corrected in order to take into account the charge state of the current particle
! ****       cort=-(1.-(qst/f(9,i)))
           cort=0.
           TKC=TK*cort+TK
           T1KC=T1K*cort+T1K
           T2KC=T2K*cort+T2k
           T3KC=T3K*cort+T3k
           T4KC=T4K*cort+T4k
           SKC=SK*cort+SK
           S1KC=S1K*cort+S1K
           S2KC=S2K*cort+S2K
           S3KC=S3K*cort+S3K
           S4KC=S4K*cort+S4K
!       cort1=qst/f(9,i)
           cort1=1.
! ************************************
!   Predictor
           PHASE=PHI
!  DXKI0 : difference of energy betwen the reference and the actual particle
           DXKI0=FH0*(1./beini-1./BEREF)
           DXDTE=DXKI0
           TKE=TKC+DXDTE*T1KC+DXDTE*DXDTE*T2KC/2.+DXDTE**3*T3KC/6.+
     X     DXDTE**4*T4KC/24.
           SKE=SKC+DXDTE*S1KC+DXDTE*DXDTE*S2KC/2.+DXDTE**3*S3KC/6.+
     X     DXDTE**4*S4KC/24.
!  ******************************************
! --- systematic or random defaults on the field level (not for the reference)
           if(ierpf.ne.0) then
             if(ierpf.eq.1) then
               TKE=TKE*(1.+vfield)
               SKE=SKE*(1.+vfield)
             endif
             if(ierpf.gt.1) then
               len=1
               call rlux(vecx,len)
               r1=(2.*vecx(1)-1.)*vfield
               TKE=TKE*(1.+r1)
               SKE=SKE*(1.+r1)
             endif
           endif
           PHIWC=PHI+PAVPH
! *****************************************************
           DDWP=abs(f(9,i))*(TKE*COS(PHIWC)-SKE*SIN(PHIWC))
           ENPMT=f(7,i)+DDWP
           GAMPS=ENPMT/XMAT
           if(gamps.le.1.) f(8,i)=0.
           if(int(f(8,i)).eq.0) then
             ilost=ilost+1
             if(ilost.ge.ngood) stop
             go to 19
           endif
           BETPS=SQRT(1.-1./(GAMPS*GAMPS))
           XK1II=FH0/BEINI
           XK2II=FH0/BETPS
           XKMI=XK2II+(XK2II-XK1II)*ASDL/EQVL + DELPHR/EQVL
           XK1I=XK1II-XKMI
           XK2I=XK2II-XKMI
           BEMPY=FH0/XKMI
           SAUPHC=DELPHR
           DXDKI=XKMI-XKM
           DPHII=(XK1II-XK2II)*EQVL/10.+(XKP1+XKP2)/120.*EQVL**2
     X          + XK1I*ASDL
           DO IJK=1,3
! --- boucle IJK to improve  TTF
             TKE=TKC+DXDKI*T1KC+DXDKI*DXDKI*T2KC/2.+DXDKI**3*T3KC/6.+
     X           DXDKI**4*T4KC/24.
             T1KE=T1KC+DXDKI*T2KC+DXDKI*DXDKI*T3KC/2.+DXDKI**3*T4KC/6.
             SKE=SKC+DXDKI*S1KC+DXDKI*DXDKI*S2KC/2.+DXDKI**3*S3KC/6.+
     X           DXDKI**4*S4KC/24.
             S1KE=S1KC+DXDKI*S2KC+DXDKI*DXDKI*S3KC/2.+DXDKI**3*S4KC/6.
! **********************************************************
! --- systematic or random defaults on the field level (not for the reference)
             if(ierpf.eq.1) then
               TKE=TKE*(1.+vfield)
               SKE=SKE*(1.+vfield)
               T1KE=T1KE*(1.+vfield)
               S1KE=S1KE*(1.+vfield)
             endif
             if(ierpf.gt.1) then
               len=1
               call rlux(vecx,len)
               r1=(2.*vecx(1)-1.)*vfield
               TKE=TKE*(1.+r1)
               SKE=SKE*(1.+r1)
               T1KE=T1KE*(1.+r1)
               S1KE=S1KE*(1.+r1)
             endif
             PCRESI=0.
             DPHCI0=0.
!             if(f(9,i).ne.qst) then
! --- new crest phase is PCRESI
!cc              PCRESI=ATAN(-SKE/TKE)
!cc              DDWC=abs(f(9,i))*(TKE*COS(PCRESI)-SKE*SIN(PCRESI))
!cc              IF(DDWC.LT.0.) PCRESI=PCRESI+PI
! --- DPHCI0 is the difference between the previous crest phase and the present one
!cc              DPHCI0=PCREST-PCRESI
!             endif
             PHIWC=PHI+DPHII
! ***********************************
             DWCI=abs(f(9,i))*(TKE*COS(PHIWC)-SKE*SIN(PHIWC))
             ENRC=f(7,i)+DWCI
             GACR=ENRC/XMAT
             BECR=SQRT(1.-1./(GACR*GACR))
             XK2II=FH0/BECR
             CXLG=abs(f(9,i))/(4.*XMAT*EQVL)
             DXDPI=RETPH-DPHCI0
! --- see Part. Acc., 1994, vol 44., pp. 215-255
! ----     relation 86
             DXDPT=DXDPI+DXK00*(1.-DKMSKE)*ASDL-DXDPI*DKMSPHI*ASDL
             DXK00=FH0*(1./BEINI-1./BEREF)
             XLH11=(YH11T+DXK00*(DKMSKE*YH1K1T+YH1K01T))*COS(DXDPT)
             XLH11=XLH11+DXDPI*YH1P1T*COS(DXDPT)
!        second derivative of Ha0(Z) (division by 2 has been made)
             XLH112=DXK00*DXK00*(H1AKIT+H1AKIMT*DKMSKE+
     X              H1AKMT*DKMSKE*DKMSKE)*COS(DXDPT)
             XLH112=XLH112+DXDPI*DXDPI*HAPIT*COS(DXDPT)
             XLH112=XLH112+DXDPI*DXK00*(YH10PKT+
     X            DKMSKE*YH11PKT)*COS(DXDPT)
!        third derivative of Ha0(Z)
             XLH113=(DXDPI**3)/3.*HAPPIT*COS(DXDPT)
             XLH11=XLH11+XLH112+XLH113
!        first derivative of Hb0(Z)
             XLH21=(YH21T+DXK00*(DKMSKE*YH2K1T+YH2K01T))*SIN(DXDPT)
             XLH21=XLH21+DXDPI*YH2P1T*SIN(DXDPT)
!        second derivative of Hb0(Z) (division by 2 has been made)
             XLH212=DXK00*DXK00*(H1BKIT+H1BKIMT*DKMSKE +
     X              H1BKMT*DKMSKE**2)*SIN(DXDPT)
             XLH212=XLH212+DXDPI*DXDPI*HBPIT*SIN(DXDPT)
             XLH212=XLH212+DXDPI*DXK00*(YH20PKT+
     X              DKMSKE*YH21PKT)*SIN(DXDPT)
!      third derivative of of Hb0(Z)
             XLH213=(DXDPI**3)/3.*HBPPIT*SIN(DXDPT)
             XLH21=XLH21+XLH212+XLH213
             XLH1I=CXLG*(XLH11-XLH21)
! --- SAUPHC is the jump of phase
             SAUPHC=FH0*XLH1I
! ---     XKMI:  AVERAGE factor k (k = frequency/velovity)
             XKMI=XK2II+SAUPHC/EQVL+(XK2II-XK1II)*ASDL/EQVL
             BEMPY=FH0/XKMI
             XK1I=XK1II-XKMI
             DXDKI=XKMI-XKM
             DPHII=(XK1II-XK2II)*EQVL/10.+(XKP1+XKP2)/120.*EQVL**2
     X            + XK1I*ASDL
           ENDDO
! ****       ENDDO IJK=1,3
!    Compute the shift of phase: PHSLIL
           DTS=(TKE*T1KE+SKE*S1KE)/(TKE*TKE+SKE*SKE)
           TILTAL=-4.*ATAN(DTS*3.2/EQVL)
           fprec=epsilon(TILTAL)
!           IF(TILTAL.NE.0.) THEN
           IF(abs(TILTAL).GT.fprec) THEN
             TIL2=TILTAL/2.
             XLREI=EQVL
             DO IIII=1,4
               FTIL=1./TAN(TIL2) - 1./TIL2 -DTS*2./XLREI
               DFTIL=-1./(SIN(TIL2)*SIN(TIL2)) + 1./(TIL2*TIL2)
!               IF(DFTIL.NE.6.*0.) then
               IF(abs(DFTIL).GT.fprec) then
                 TIL2=TIL2 - FTIL/DFTIL
                 GX=1./TAN(TIL2) - 1./TIL2
                 XLREI=2.*DTS/GX
               endif
             ENDDO
             TILTAL=TIL2*2.
           ENDIF
           PHSLIL=TILTAL
           TEGL1=PHSLIL*PHSLIL/(SIN(PHSLIL/2.)*SIN(PHSLIL/2.))
           TEGL2=(TKE*TKE+SKE*SKE)
           TEGL=TEGL1*TEGL2/(EQVL*32.)
           TEGL=TEGL/EQVL
! ---   Transverse motion  (field E(z)**2)
           PHITTI=PHIWC+XK1I*ASDL-PHSLIP/2.
           PHITSI=PHIWC+XK2I*ASDL+PHSLIP/2.
           CETF1=f(9,i)*f(9,i)/(16.*XMAT*XMAT*EQVL*EQVL)
! **************************
           CFV1=(GINI*GINI+2.)/((GINI*GINI-1.)**2)
           CFV2=(GACR*GACR+2.)/((GACR*GACR-1.)**2)
           SV1=CFV1*(TKE*COS(PHITTI)-SKE*SIN(PHITTI))**2
           SV1=CETF1*SV1*(PHSLIL/SIN(PHSLIL/2.))**2
           SV2=CFV2*(TKE*COS(PHITSI)-SKE*SIN(PHITSI))**2
           SV2=CETF1*SV2*(PHSLIL/SIN(PHSLIL/2.))**2
!       Transverse motion  (field dE(z)/dt)
           CETI=FH0*abs(f(9,i))/(4.*XMAT*EQVL)
! **************************
           CXV1=(GINI*GINI-1.)**1.5
           CXV2=(GACR*GACR-1.)**1.5
           SXV1=(TKE*SIN(PHITTI)+SKE*COS(PHITTI))*PHSLIL/SIN(PHSLIL/2.)
           SXV1=-CETI*SXV1/CXV1
           SXV2=(TKE*SIN(PHITSI)+SKE*COS(PHITSI))*PHSLIL/SIN(PHSLIL/2.)
           SXV2=-CETI*SXV2/CXV2
! --- save all parameters
           SV1P(I)=SV1
           SV2P(I)=SV2
           SXV1P(I)=SXV1
           SXV2P(I)=SXV2
           DWCIS(I)=DWCI
           sauphcs(i)=SAUPHC
           BEINI1(I)=BEINI
           PHIP(I)=PHI
           TEGLP(I)=TEGL
           DXDPIP(I)=DXDPI
           DXDKIP(I)=DXDKI
           DXDPTP(I)=DXDPT
           DXK00P(I)=DXK00
           DPHIIP(I)=DPHII
!  END IF BLOCK  on APV
         ENDIF
! --- ipas = 2: the dynamics is computed over the full element
         if(ipas.eq.2) then
!    Recover all previous parameters
           SAUPHC=sauphcs(i)
           XLH1I=SAUPHC/FH0
           DWCI=DWCIS(I)
           SV1=SV1P(I)
           SV2=SV2P(I)
           SXV1=SXV1P(I)
           SXV2=SXV2P(I)
           BEINI=BEINI1(I)
           GINI = 1./SQRT(1.-BEINI*BEINI)
           PHI=PHIP(I)
           TEGL=TEGLP(I)
           DXDPI=DXDPIP(I)
           DXDKI=DXDKIP(I)
           DXDPT=DXDPTP(I)
           DXK00=DXK00P(I)
           DPHII=DPHIIP(I)
         else
!  compute the jump of phase at position of space charge computation
           CXLG=abs(f(9,i))/(4.*XMAT*EQVL)
!     FUNCTION Ha0(Z)
           XLH11=(YH11+DXK00*(DKMSKE*YH1K1+YH1K01))*COS(DXDPT)
           XLH11=XLH11+DXDPI*YH1P1*COS(DXDPT)
!     SECOND DERIVATIVES OF Ha0(Z) (division by 2 has been made)
           XLH112=DXK00*DXK00*(H1AKI+H1AKIM*DKMSKE+
     X          H1AKM*DKMSKE*DKMSKE)*COS(DXDPT)
           XLH112=XLH112+DXDPI*DXDPI*HAPI*COS(DXDPT)
           XLH112=XLH112+DXDPI*DXK00*(YH10PK+
     X          DKMSKE*YH11PK)*COS(DXDPT)
!      THIRD DERIVATIVE of Ha0(Z)
           XLH113=(DXDPI**3)/3.*HAPPI*COS(DXDPT)
           XLH11=XLH11+XLH112+XLH113
!     FUNCTION Hb0(Z)
           XLH21=(YH21+DXK00*(DKMSKE*YH2K1+YH2K01))*SIN(DXDPT)
           XLH21=XLH21+DXDPI*YH2P1*SIN(DXDPT)
!     SECOND DERIVATIVE OF Hb0(Z) (division by 2 has been made)
           XLH212=DXK00*DXK00*(H1BKI +H1BKIM*DKMSKE+
     X          H1BKM*DKMSKE**2)*SIN(DXDPT)
           XLH212=XLH212+DXDPI*DXDPI*HBPI*SIN(DXDPT)
           XLH212=XLH212+DXDPI*DXK00*(YH20PK+
     X          DKMSKE*YH21PK)*SIN(DXDPT)
!      THIRD DERIVATIVE OF Hb0(Z)
           XLH213=(DXDPI**3)/3.*HBPPI*SIN(DXDPT)
           XLH21=XLH21+XLH212+XLH213
           XLH1I=CXLG*(XLH11-XLH21)
           SAUPHC=FH0*XLH1I
         endif
         CXLG=abs(f(9,i))/(4.*XMAT*EQVL)
         XLH01=(YH10+DXDKI*YH1K0+DXK00*YH1K00)*COS(DXDPT)
         XLH02=(YH20+DXDKI*YH2K0+DXK00*YH2K00)*SIN(DXDPT)
         XLH0I=CXLG*(XLH01-XLH02)
! -- COUPLING INTEGRALS
         XLP11=(YP11+ DXDKI*YP1K1 + DXK00*YP1K01)*COS(DXDPT)
         XLP21=(YP21+ DXDKI*YP2K1 + DXK00*YP2K01)*SIN(DXDPT)
         XLP1I=CXLG*(XLP11-XLP21)
         XLP12=(YP12+ DXDKI*YP1K2 + DXK00*YP1K02)*COS(DXDPT)
         XLP22=(YP22+ DXDKI*YP2K2 + DXK00*YP2K02)*SIN(DXDPT)
         XLP2I=CXLG*(XLP12-XLP22)
         RADIU=SQRT(F(2,I)*F(2,I)+F(4,I)*F(4,I))
         IF(RADIU.LT.1.e-06) THEN
           DRADIU=.001*SQRT(F(3,I)*F(3,I)+F(5,I)*F(5,I))
         ELSE
           DRADIU=F(3,I)*.001*F(2,I)/RADIU+F(4,I)*F(5,I)*.001/RADIU
         ENDIF
         RP=RADIU
         RPP=DRADIU
!        Picht coordinates
         RRP=RP*SQRT(BEINI*GINI)
         RRPP=RPP*SQRT(BEINI*GINI)
! --- ipas = 1: the dynamics is computed until the position of space charge computation
!       gain of energy at the position of space charge computation (not for the reference)
         if(ipas.eq.1) then
! *****           PHIWC=PHI+DPHII-DPHCI0
           PHIWC=PHI+DPHII
!       istm: flag ==> the energy is compute at the position of space charge computation
           istm=ist-1
           GACR=GAMCI(PHIWC,PCRESI,GINI,ISTM,abs(f(9,i)))
           DWCI=(GACR-GINI)*XMAT
         endif
         DWPI=DWCI+XMAT*FH0*FH0*RRP*RRP/4.*XLH0I +
     X        XMAT*RRP*RRPP*FH0*FH0/2. *XLH1I
!       PHASE JUMP
         DELPHI=SAUPHC+ FH0**3*RRP*RRP/4. *XLP1I +
     X          FH0**3*RRP*RRPP/2. *XLP2I
         IF(IPAS.EQ.2) THEN
!    kicks of energy from space charge effects are in dwp(i)
           IF(ICHAES) THEN
             F(7,i)=F(7,I)+DWPI+DWP(I)
             GAMSOR = F(7,i)/XMAT
             IF(GAMSOR.LE.1.) f(8,i)=0.
!     particle is lost
             IF(int(F(8,i)).EQ.0) go to 19
             BESOR=SQRT(1. -1./(GAMSOR*GAMSOR))
!       phase jump resulting from space charge
             DELGAM=DWP(I)/XMAT
             GAMKK0=F(7,I)/XMAT
             BEKK0=SQRT(1. -1./(GAMKK0*GAMKK0))
             DBEK21=DELGAM/(BEKK0**3 * GAMKK0**3)
             DELSC=FH0*SCDIST*DBEK21/2.
             DELPHI=DELPHI+DELSC
             DITEMP=YLG/(BESOR*VL)+DELPHI/FH
             f(6,i)=fs(6,i)+ditemp
           ELSE
             f(7,i)=f(7,i)+DWPI
             GAMSOR = f(7,i)/XMAT
             IF(GAMSOR.LE.1.) f(8,i)=0.
!     particle is lost
             if(int(f(8,i)).eq.0) then
               f6i=f(6,i)-tcog
               lossreason(i)=-1 
               write(49,3928) PRTLAB,NRRES,davtot/100.,i,int(f(1,i)),
     *         f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180./pi,f(7,i)-xmat,
     *         f(9,i),lossreason(i)     
               if(ilost.ge.ngood) stop
               ilost=ilost+1
               go to 19
             ENDIF
             BESOR=SQRT(1. -1./(GAMSOR*GAMSOR))
             DITEMP=YLG/(besor*vl)+DELPHI/FH
             f(6,i)=f(6,i)+DITEMP
           ENDIF
         ENDIF
         IF(ipas.eq.1) THEN
           f(7,i)=f(7,i)+DWPI
           GAMSOR = f(7,i)/XMAT
           if(GAMSOR.LE.1.) f(8,i)=0.
           if(int(f(8,i)).eq.0) then
             lossreason(i)=-2 
             write(49,3928) PRTLAB,NRRES,davtot/100.,i,int(f(1,i)),
     *       f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180./pi,f(7,i)-xmat,
     *       f(9,i),lossreason(i)     
             if(ilost.ge.ngood) stop
             ilost=ilost+1
             go to 19
           endif
           BESOR=SQRT(1. -1./(GAMSOR*GAMSOR))
           DITEMP=YLG/(2.*BESOR*VL)+DELPHI/FH
! ****************************
           f(6,i)=f(6,i)+DITEMP
         ENDIF
         IF(I.EQ.ICONT) THEN
           IF(IPAS.EQ.2) THEN
             WRITE(16,*) '* DYNAMICS AT THE OUTPUT :'
             WRITE(16,994) DELPHI*180./PI,DELSC*180./PI,DWP(I)
994          FORMAT(1x,'* PHASE JUMP ',E12.5,' DEG  CORRECTED BY :',
     X       E12.5,' DEG ',' SC KICK(MEV) ',E12.5)
             ENRPRIN=f(7,i)-XMAT
           WRITE(16,88) DWPI,ENRPRIN,BESOR,f(9,i),DITEMP
88           FORMAT(1x,'* ENERGY GAIN : ',E14.7,' MEV','   ENERGY :',
     X       E14.7,' MEV',/,1X,'* BETA :',E12.5,/,
     X       1X,'* CHARGE :',F5.0,' TRANSIT TIME :',E12.5,' SEC',/,
     X       1X,'*')
            write(16,*) 'TK TKE ',TK,TKE
            write(16,*) 'SK SKE ',SK,SKE
            write(16,*) 'PCREST  PCRESI',PCREST,PCRESI
           ENDIF
           if(ipas.eq.1) then
             WRITE(16,*) '* DYNAMICS AT THE POSITION OF SPACE CHARGE :'
             ENRPRIN=f(7,i)-XMAT
             WRITE(16,9944) DELPHI*180./PI,DWPI,ENRPRIN,DITEMP
9944         FORMAT(1x,'* PHASE JUMP ',E12.5,' DEG ',' ENERGY GAIN : ',
     X       E14.7,' MeV',' ENERGY :',E14.7,' MEV',/,
     X       ' TRANSIT TIME :',E12.5,' SEC',/,
     X       1X,'*')
           ENDIF
         ENDIF
         AMORT=SQRT(BEINI*GINI/(BESOR*GAMSOR))
!     INTEGRALS OF THE TRANSVERSE MOTION (not computed for the reference)
!     ******************
! ******       if(i.ne.ngdrf) then
! ----  integrals of E(Z)**2
! ----     (G**2+2/(G**2-1)**2)*E(z)**2
         CETF=f(9,i)*f(9,i)*SQCTTF*SQCTTF/(16.*XMAT*XMAT*EQVL*EQVL)
! *************************************
         XJF0I=YFS0+DXDKI*(YFSK0+YFSCK0) + DXDPI*(YFSP0 +YFSCP0) +
     X         DXK00*YFSKC0
         XJF0I=XJF0I*CETF
         XJF1I=YFS1+DXK00*DKMSKE*(YFSK1+YFSCK1)+DXDPI*(YFSP1+YFSCP1)+
     X         DXK00*YFSKC1
         XJF1I=XJF1I*CETF
         XJF2I=YFS2+DXK00*DKMSKE*(YFSK2+YFSCK2)+DXDPI*(YFSP2+YFSCP2)+
     X         DXK00*YFSKC2
         XJF2I=XJF2I*CETF
         V1=SV1
         V2=SV2
! ----     (G**2+2/(G**2-1)**2)
         CETM=f(9,i)*f(9,i)*TEGL/(XMAT*XMAT)
! *************************************
         XMN0I=YNS0+DXDKI*YNSK0+DXDPI*YNSP0+DXK00*YNSK0C
         XMN0I=XMN0I*CETM
         XMN1I=YNS1+DXK00*DKMSKE*YNSK1+DXDPI*YNSP1+DXK00*YNSK1C
         XMN1I=XMN1I*CETM
         XMN2I=YNS2+DXK00*DKMSKE*YNSK2 + DXDPI*YNSP2 +DXK00*YNSK2C
         XMN2I=XMN2I*CETM
         F0=XJF0I + XMN0I
         F1=XJF1I + XMN1I
         F2=XJF2I + XMN2I
! ---     1/(B*G)**3 *dE(z)/dt
         CETI=FH0*abs(f(9,i))/(8.*XMAT*EQVL)
! **************************
         XIE01= (YE10+DXDKI*YE1K0+DXK00*YE1KC0)*COS(DXDPT)
         XIE02= (YE20+DXDKI*YE2K0+DXK00*YE2KC0)*SIN(DXDPT)
         XIE0I=-CETI*(XIE01+XIE02)
         XIE11= (YE11+DXDKI*YE1K1+DXK00*YE1KC1)*COS(DXDPT)
         XIE12= (YE21+DXDKI*YE2K1+DXK00*YE2KC1)*SIN(DXDPT)
         XIE1I=-CETI*(XIE11+XIE12)
         XIE21= (YE12+DXDKI*YE1K2+DXK00*YE1KC2)*COS(DXDPT)
         XIE22= (YE22+DXDKI*YE2K2+DXK00*YE2KC2)*SIN(DXDPT)
         XIE2I=-CETI*(XIE21+XIE22)
         XV1=SXV1
         XV2=SXV2
         XI0=XIE0I
         XI1=XIE1I
         XI2=XIE2I
!      Transport matrix in 'PICHT' coordonates
         XQ0=XI0-F0
         XQ1=XI1-F1
         XQ2=XI2-F2
         XQ01=(XQ1+ASDL*XQ0)
         XQ12=(XQ2+ASDL*XQ1)
         V1=XV1-V1
         V2=XV2-V2
         A11=-XQ01*(1.+ (V1+V2)*EQVL*EQVL/120.)
         A12=-(XQ2+2.*ASDL*XQ1+ASDL*ASDL*XQ0 +
     X       EQVL*EQVL*((V1+V2)/120. + EQVL*V2/120.)*XQ01)
         ZA=-(XQ12/EQVL +V2*EQVL*EQVL*XQ01/120.)
         ZB=-((EQVL+ASDL)*XQ12/EQVL -
     X       EQVL*XQ01/10. +V2*(EQVL+ASDL)*EQVL*EQVL*XQ01/120.)
         A21=XQ0*(1.+ (V1+V2)*EQVL*EQVL/120.)
         A22= XQ1 + XQ0*(ASDL+ASDL*EQVL*EQVL*(V1+V2)/120. +
     X       EQVL**3*V2/120.)
         ZC=XQ1/EQVL + V2*EQVL*EQVL*XQ0/120.
         ZD= (ASDL+EQVL)*XQ1/EQVL -
     X      ( EQVL/10. + V2*(EQVL+ASDL)*EQVL*EQVL/120.)*XQ0
!
         TMA=1./(1.-ZA-ZC*ZB/(1.-ZD))
         T11= (A11+ZB*A21/(1.-ZD)) *TMA
         T12=( A12+ZB*A22/(1.-ZD) )*TMA
         T21=(A21+ZC*T11)/(1.-ZD)
         T22=(A22+ZC*T12)/(1.-ZD)
         VR11=(1.+T11+DCUM*T21)
         VR12=(T12+DCUM*(1.+T22))
         VR21=T21
         VR22=1.+T22
         IF(I.EQ.ICONT) THEN
           DETRE=VR11*VR22-VR12*VR21
           WRITE(16,8921) VR11,VR12,VR21,VR22,DETRE
8921       FORMAT(2X,' TRANSVERSE CANONICAL MATRIX:(cm,radian) ',/,
     X     2X,' VR11:',E12.5,'   VR12:',E12.5,/,
     X     2X,' VR21:',E12.5,'   VR22:',E12.5,/,
     X     2X,' DETERMINANT       :',E12.5,//)
         ENDIF
!       REAL MATRIX
         A11=VR11*AMORT
         A12=VR12*AMORT
         A21=VR21*AMORT
         A22=VR22*AMORT
!omment       ** cumulative matrix (particle 1)
!omment          tables R(,) ET T(,,,)
!omment         IF (I .EQ. 1.AND.IPAS.EQ.2) THEN
!omment           STA11=VR11*SA11+VR12*SA21
!omment           STA12=VR11*SA12+VR12*SA22
!omment           STA21=VR21*SA11+VR22*SA21
!omment           STA22=VR21*SA12+VR22*SA22
!omment           SA11=STA11
!omment           SA12=STA12
!omment           SA21=STA21
!omment           SA22=STA22
!omment           SAA11=SA11*AMORT
!omment           SAA12=SA12*AMORT
!omment           SAA21=SA21*AMORT
!omment           SAA22=SA22*AMORT
!omment           RS(1,1) =SAA11
!omment           RS(1,2) =SAA12
!omment           RS(2,1) =SAA21
!omment           RS(2,2) =SAA22
!omment           RS(3,3) =SAA11
!omment           RS(3,4) =SAA12
!omment           RS(4,3) =SAA21
!omment           RS(4,4) =SAA22
!omment           DO IA=1,6
!omment             DO IB=1,6
!omment               R(IA,IB)=RCUL(IA,IB)
!omment             ENDDO
!omment           ENDDO
!omment           CALL MFORDRE(RCUL,RS,R)
!omment         ENDIF
!      BEAM COORDINATES
         FXT1=A11*F(2,I)+A12*F(3,I)*1.E-03
         FXT2=A21*F(2,I)+A22*F(3,I)*1.E-03
         FXT3=A11*F(4,I)+A12*F(5,I)*1.E-03
         FXT4=A21*F(4,I)+A22*F(5,I)*1.E-03
         F(2,I)=FXT1
         F(3,I)=FXT2*1.E03
         F(4,I)=FXT3
         F(5,I)=FXT4*1.E03
         IF(I.EQ.ICONT) THEN
!        ** CURRENT MATRIX
           STTA11=VR11*SACT11+VR12*SACT21
           STTA12=VR11*SACT12+VR12*SACT22
           STTA21=VR21*SACT11+VR22*SACT21
           STTA22=VR21*SACT12+VR22*SACT22
           SACT11=STTA11
           SACT12=STTA12
           SACT21=STTA21
           SACT22=STTA22
           SAA11=SACT11*AMORT
           SAA12=SACT12*AMORT
           SAA21=SACT21*AMORT
           SAA22=SACT22*AMORT
           DET=A11*A22-A12*A21
           WRITE(16,992) A11,A12*1.E-3,A21*1.E3,A22,DET,AMORT
992        FORMAT(1x,'*  TRANSVERSE MATRIX (cm,mrd)',/,1x,
     X           '*',E12.5,3X,E12.5,/,1x,
     X           '*',E12.5,3X,E12.5,/,1x,
     X           '* DETERMINANT :',E12.5,' DUMPING OF ENERGY :',E12.5)
           write(16,*)'*'
           WRITE(16,559) F(2,I),F(3,I),F(4,I),F(5,I)
559        FORMAT(
     X     ' * TRANVERSE COORDINATES AT OUTPUT  ',/,1x,
     X     '* X :',E12.5,' CM  XP :',E12.5,' MRD ',/,1x,
     X     '* Y :',E12.5,' CM  YP :',E12.5,' MRD')
           IF(IPAS.EQ.2)
     X       WRITE(16,*) '********** END OF FOLLOWED PARTICLE ********'
         ENDIF
19     CONTINUE
       return
       end
!> *******************************************************************
!! SUBROUTINE bunparm(v,dp,harm,prlim)
!! BUNCHER  (NO SPACE CHARGE EFFECT)
!< *******************************************************************
       SUBROUTINE bunparm(v,dp,harm,prlim)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/RIGID/BORO
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/corec/tref1
       COMMON/QMOYEN/QMOY
       common/aerp/vphase,vfield,ierpf
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/SHIF/DTIPH,SHIFT
       common/tofev/ttvols
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       common/fcont/ifcont
       logical ifcont
       CHARACTER cr*1
       dimension vecx(1)
       LOGICAL chasit,itvol,imamin,shift
!      ENVELOPE
       PRLAB(IPRF)='BUNCHER '
       PRTLAB=PRLAB(IPRF)
       call stapl(davtot*10.)
!xx       ilost=0
       twopi=2.*pi
       freq=fh/twopi
       wavel=vl/freq
       fcpi=fh*180./pi
! print out on terminal of transport element # on one and the same line
       nrbunc=nrbunc+1
       cr=char(13)
       WRITE(6,8254,advance='no') nrtre,nrbunc,cr
8254   format('Transport element:',i5,
     *        '      Buncher             :',i5,a1)
       if (harm.le.0.) harm=1.
       rhs=prlim*prlim
!   test window
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       tcog=0.
       bcog=0.
       do np=1,ngood
         tcog=tcog+f(6,np)
         gpa=f(7,np)/xmat
         bcog=sqrt(1.-1./(gpa*gpa))+bcog
       enddo
       tcog=tcog/float(ngood)
       bcog=bcog/float(ngood)
       gcog=1./sqrt(1.-bcog*bcog)
       encog=xmat*gcog-xmat
! adjustement of the phase of RF w.r.t. the T.O.F.
      xkpi=0.
      if(imamin) then
       ttvpi=harm*ttvols*fcpi
       xkpi=ttvpi/360.
       ixkpi=int(xkpi)
       xkpi=(xkpi-float(ixkpi))*360.
       write(16,*) ' *** TOF correction:',-xkpi,' deg'
       dp=dp-xkpi*pi/180.
       write(16,*)' ***phase of RF adjusted : ',dp*180./pi,' deg'
      endif
! 20/08/2009    delay of phase of the reference at input w.r.t. the synchronous phase
! 20/08/2009       ttvpi=harm*ttvols*fcpi
! 20/08/2009       xkpi=ttvpi/180.
! 20/08/2009       ixkpi=xkpi+0.5
! 20/08/2009       ixkpi=ixkpi*180
! 20/08/2009       xkpc=cos(ixkpi*pi/180.)
! 20/08/2009       xkpi=ttvpi-float(ixkpi)
! 20/08/2009       if(itvol.and.imamin)
! 20/08/2009     *  write(16,8975) dp*180./pi,xkpi
! 20/08/2009 8975   format('***previous phase offset: ',e12.5,' deg',/,
! 20/08/2009     * '***new phase offset: ',e12.5,' deg')
!  start of write to file '.short' for buncher
       idav=idav+1
       iitem(idav)=8
       dav1(idav,1)=v
       dav1(idav,2)=dp*180./pi
       dav1(idav,3)=prlim
       dav1(idav,4)=davtot*10.
       if(itvol) dav1(idav,5)=-xkpi
!  end
       WRITE(16,178)
178    FORMAT(/,' Dynamics at the input',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
       WRITE(16,1788) bcog,gcog,encog,tcog*fcpi,tcog
1788   FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       e0t=harm*v/(bcog*wavel)
       pveff=v
!    random or systematic error on  RF level
       if(ierpf.eq.1) then
!  systematic error on RF level
         e0t=e0t*(1.+vfield)
         pveff=v*(1.+vfield)
!  random error on RF level
       elseif(ierpf.ge.2) then
         len=1
         call rlux(vecx,len)
         r1=(2.*vecx(1)-1.)*vfield
         e0t=e0t*(1.+r1)
         pveff=v*(1.+r1)
       endif
       cay=harm*twopi/(bcog*gcog*wavel)
       caysq=cay**2
       con=twopi*e0t*qmoy/xmat
       rad=pi/180.
!  systematic error on  phase
       if(ierpf.eq.1) dp=dp+vphase*rad
!  random error on phase
       if(ierpf.ge.2) then
         len=1
         call rlux(vecx,len)
         r1=(2.*vecx(1)-1.)*vphase*rad
         dp=dp+r1
       endif
! shift=true => reference and COG seperated, otherwise reference=COG
! --- save the reference
       ovref=vref
       otref=tref
! --- shift = false: the reference particle is the cog
       if(shift) then
         ovref=vref
         beref=vref/vl
         gamref=1./sqrt(1.-beref*beref)
         older=xmat*gamref
       else
         tref=tcog
         vref=bcog*vl
         ovref=vref
         beref=bcog
         gamref=1./sqrt(1.-beref*beref)
         older=xmat*gamref
       endif
! ---  if imamin = false: phase setting has been forced equal to dp, otherwise phase setting has been adjusted
       dgr=v*cos(harm*ttvols*fh+dp)*qmoy
       ewer=older+dgr
       gor=ewer/xmat
       vref=vl*sqrt(1.-1./(gor*gor))
       ENRPRIN=older-xmat
       WRITE(16,165) beref,gamref,ENRPRIN,tref*fh*180./pi,tref
165    FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       wsync=0.
       bcour=0.
       tcog=0.
       do np=1,ngood
         rs=f(2,np)**2+f(4,np)**2
         a=harm*(f(6,np)-tref+ttvols)*fh+dp
         rs=rs*1.e-04
! 20/08/2009         s=sin(a)*xkpc
         s=sin(a)
         w=f(7,np)-xmat
         bg=sqrt(w/xmat*(2.+w/xmat))
!    conversion cm-->m and mrd--->rd
         f2=f(2,np)
         f4=f(4,np)
         f3=f(3,np)*1.e-03
         f5=f(5,np)*1.e-03
         bgx=f3*bg
         bgy=f5*bg
         cayrsq=caysq*rs
         arg=cayrsq/4.
         xi0=1.+arg*(1.+arg*(.25+arg/36.))
!           dw=v*cos(a)*xi0*qmoy
         dw=v*cos(a)*xi0*f(9,np)
! 20/08/2009         dw=dw*xkpc
         wb=w+.5*dw
         bgav=sqrt(wb/xmat*(2.+wb/xmat))
         gav=1.+wb/xmat
         bav=bgav/gav
         bcour=bcour+bav
         wf=w+dw
         bgf=sqrt(wf/xmat*(2.+wf/xmat))
         xi1okr=.5+.25*arg+arg**2/24.
         del=-con*s*(1.-bav*bcog)*xi1okr/bav
         tcog=tcog+f(6,np)
         f3=(bgx+del*f2)/bgf
         f(3,np)=f3*1.e03
         f5=(bgy+del*f4)/bgf
         f(5,np)=f5*1.e03
         f(7,np)=wf+xmat
         wsync=wsync+wf
       enddo
       wsync=wsync/float(ngood)
       bcour=bcour/float(ngood)
       tcog=tcog/float(ngood)
! Test window
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
! new output
! shift=true => reference and COG seperated, otherwise reference=COG
       engain=wsync-encog
       if(shift) then
         beref=vref/vl
         gamref=1./sqrt(1.-beref*beref)
         enref=ewer-xmat
       else
         tref=tcog
         vref=bcour*vl
         beref=bcour
         enref=wsync
         dgr=engain
       endif
       if(itvol) ttvols=tref
       WRITE(16,3777)
3777   FORMAT(/,' Dynamics at the output',/,
     1 5X,'   BETA     dW(MeV)    ENERGY(MeV) ',
     2 '   TOF(deg)     TOF(sec)')
       WRITE(16,3473) beref,dgr,enref,fh*TREF*180./PI,TREF
3473   FORMAT(' REF ',f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)
       WRITE(16,1789) bcour,engain,wsync,tcog*fh*180./pi,tcog
1789   FORMAT(' COG ',f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)
! save number of good particles for .short file
       dav1(idav,36)=ngood
! as beam passed through buncher, assume bunched beam
       ifcont=.false.
       WRITE(16,*) 'After buncher, bunched beam assumed'
       call emiprt(0)
       emns=(1.E12)*dav1(idav,12)/(4.*fh)
       trnsms=100.*float(ngood)/float(imax)
       if(nrbunc.eq.1) write(50,*) '# buncher.dmp'
       if(nrbunc.eq.1) write(50,*) '# cav     Z       trans   ',
     *   'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ',
     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
     *   'El,RMS        dWref        EffVolt'
       if(nrbunc.eq.1) write(50,*) '#  #     (m)       (%)    ',
     *  '(deg)     (deg)        beta     (MeV)          (deg)      ',
     *  '   beta        (MeV)      (mm.mrad)    (mm.mrad)    ',
     *  '(ns.keV)      (MeV)          (MV)'
       write(50,7023) nrbunc,0.001*dav1(idav-1,4),trnsms,
     *  dav1(idav-1,2),tcog*fh*180./pi,bcour,wsync,fh*TREF*180./PI,
     *  beref,enref,0.25*dav1(idav,16),0.25*dav1(idav,21),emns,
     *  dgr,pveff
7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
     *   2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x))
       return
       end
!> *******************************************************************
!! SUBROUTINE refer
!! change the longitudinal position of the reference
!!
!! ---- IREF =0 and IREFW = 0:  dewref is dW/W where W is the kinetic
!!                              energy of the old reference
!! ---- IREF =0 and IREFW = 1:  dewref is dW (MeV) relative to the
!!                              kinetic energy of the old reference
!! ---- IREF =0 and IREFW = 2:  dewref is dW (MeV) is new reference
!!                              energy and dbref new reference
!!                              phase (deg) in abs. units
!! ---- IREF =1 and IREFW = 0:  dewref is dW/W where W is the kinetic
!!                              energy of the c.o.g
!! ---- IREF =1 and IREFW = 1:  dewref is dW (MeV) relative to the
!!                              kinetic energy of the c.o.g.
!< *******************************************************************
       SUBROUTINE refer
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/newref/dephas,dewref,iref,irefw
       common/tapes/in,ifile,meta,ierr
       common/itvole/itvol,imamin
       common/tofev/ttvols
       logical itvol,imamin
! ---- save  reference
      avref=vref
      atref=tref
      attvols=ttvols
      if(irefw.eq.2) then
        wnref=dewref
        gnref=wnref/xmat+1.
        bref=sqrt(gnref*gnref-1.)/gnref
! ---- set tref in sec based on dephas (deg)
        delt=dephas*pi/(fh*180.)
! ------ the new reference is:
        tref=delt
        vref=bref*vl
        if(itvol)ttvols=tref
      endif
      if(iref.eq.0) then
       if(irefw.eq.0) then
        bref=vref/vl
        gref=1./sqrt(1-bref*bref)
        dbref=bref*dewref/(gref*(gref+1.))
! ---- change dephas (deg) in delt (sec)
        delt=dephas*pi/(fh*180.)
! ------ the new reference is:
         tref=tref+delt
         vref=vref+dbref*vl
         if(itvol)ttvols=tref
        endif
        if(irefw.eq.1) then
         bref=vref/vl
         gref=1./sqrt(1.-bref*bref)
         wref=(gref-1.)*xmat
         wnref=wref+dewref
         gnref=wnref/xmat+1.
         bref=sqrt(gnref*gnref-1.)/gnref
! ---- change dephas (deg) in delt (sec)
         delt=dephas*pi/(fh*180.)
! ------ the new reference is:
         tref=tref+delt
         vref=bref*vl
         if(itvol)ttvols=tref
        endif
       endif
      if(iref.eq.1) then
!  ----- c.o.g. of the bunch is the new reference
        tcog=0.
        bcog=0.
        do i=1,ngood
         tcog=tcog+f(6,i)
         gpai=f(7,i)/xmat
         bcog=bcog+sqrt(1.-1./(gpai*gpai))
        enddo
        tcog=tcog/float(ngood)
        bcog=bcog/float(ngood)
        gcog=1./sqrt(1-bcog*bcog)
        wcog=(gcog-1.)*xmat
! ---- change dephas (deg) in delt (sec)
        delt=dephas*pi/(fh*180.)
        if(irefw.eq.0) then
          wrefn=wcog+wcog*dewref/100.
! ------ the new reference is:
          tref=tcog+delt
!          vref=(bcog+dbcog)*vl
           grefn=wrefn/xmat+1.
           vref=vl*sqrt(grefn*grefn-1.)/grefn
          if(itvol)ttvols=tref
        endif
        if(irefw.eq.1) then
          wncog=wcog+dewref
          gncog=wncog/xmat+1.
          bcog=sqrt(gncog*gncog-1.)/gncog
! ------ the new reference is:
          tref=tcog+delt
          vref=bcog*vl
          if(itvol)ttvols=tref
        endif
      endif
      baref=avref/vl
      garef=1./sqrt(1.-baref*baref)
      waref=(garef-1.)*xmat
      bnref=vref/vl
      gnref=1./sqrt(1.-bnref*bnref)
      wnref=(gnref-1.)*xmat
      fcpi=fh*180/pi
      write(16,20)atref*fcpi,attvols*fcpi,waref
20    format(3x,'**before NREF',/,5x,'tof of the reference: ',e12.5,
     *' deg tof for adjustments: ',e12.5,' deg energy of reference: '
     * ,e12.5,' MeV')
      write(16,21)tref*fcpi,ttvols*fcpi,wnref
21    format(3x,'**after NREF',/,5x,'tof of the reference: ',e12.5,
     *' deg tof for adjustments: ',e12.5,' deg energy of reference: '
     * ,e12.5,' MeV')
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE steer(fld,nvf)
!! TRANSFORM BEAM THRU THIN STEERER
!!  ---- MAGNETIC STEERER
!!  ---- PARAMETERS: fld (Tm), nvf
!!     where fld is the integrated field
!!     if nvf=0,  horizontal magnetic steerer
!!     if nvf=1,  vertical magnetic steerer
!!
!!  ---- ELECTROSTATIC STEERER
!!     This is a zero length element: the length shown below is
!!     ONLY used for kick calculation.
!!  ---- PARAMETERS: fld (kV*m/m), nvf
!!     where fld is Plate Voltage * plate length/plate separation.
!!     if nvf=2, horziontal electrostatic steerer
!!     if nvf=3, vertical electrostatic steerer
!!
!!  -----ANGULAR DISPLACEMENTS DUE TO STEERING
!< *******************************************************************
       SUBROUTINE steer(fld,nvf)
       implicit real(8) (A-H,O-Z)
!     4/15/14 - Daniel Alt: Added electrostatic steerers.
!       parameter (iptsz=1000002,maxcell=3000,maxcell1=4004)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RIGID/BORO
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON/DCSPA/IESP
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       CHARACTER*(8) PRLAB
       logical iesp,ichaes
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
       if (nvf.eq.0) then
! horizontal magnetic steerer
         write(16,*) 'Horizontal magnetic steerer: ',fld,' Tm'
         do i=1,ngood
           const=xmat*1.e8/(f(9,i)*vl)
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           DISPX=fld/(const*gpai*bpai)*1000.
           f(3,i)=f(3,i)+dispx
         enddo
       else if (nvf.eq.1) then
! vertical magnetic steerer
         write(16,*) 'Vertical magnetic steerer: ',fld,' Tm'
         do i=1,ngood
           const=xmat*1.e8/(f(9,i)*vl)
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           DISPY=fld/(const*gpai*bpai)*1000.
           f(5,i)=f(5,i)+dispy
         enddo
       else if (nvf.eq.2) then
! horizontal electrostatic steerer
         write (16,*) 'Horizontal electrostatic steerer: ',fld,' kV*m/m'
         do i=1,ngood
           gpai=f(7,i)/xmat
           const=(gpai/(gpai*gpai-1.))*f(9,i)
           DISPX=const*fld/xmat
           f(3,i)=f(3,i)+dispx
         enddo
       else if (nvf.eq.3) then
! vertical electrostatic steerer
         write (16,*) 'Vertical electrostatic steerer: ',fld,' kV*m/m'
         do i=1,ngood
           gpai=f(7,i)/xmat
           const=(gpai*gpai/(gpai*gpai-1.))*f(9,i)
           DISPY=const*fld/xmat
           f(5,i)=f(5,i)+dispy
         enddo
       else
! error on input
         write(ierr,*)'Wrong value for NVF in STEERER'
         write(16,*) 'Wrong value for NVF in STEERER'
         STOP
       endif
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE emiprt(L)
!! following EMIT or EMITL card, store data in arrays to be printed
!! by subroutine "daves"
!! L=0 corresponds to EMIT (do not read and print a label)
!! L=1 corresponds to EMITL (do read and print a label in dynac.short)
!! look for the statistics with EXT2D and returns them in array dav1
!! 
!!      IDCH EQ 1: WITH  CHASE TEST
!!      IDCH NE 1: OTHERWISE
!!
!!       cog(1) : Energy(MeV)
!!       cog(3) : t.o.f. (sec)
!!       cog(4) : x-direction (cm)
!!       cog(5) : xp(mrd)
!!       cog(6) : y-direction (cm)
!!       cog(7) : yp(mrd)
!!
!!  exten(1) : Sum( dE*dE )  MeV*MeV
!!  exten(2) : Sum( dE*dPHase ) MeV*rad
!!  exten(3) : Sum( dPHase*dPHase ) rad*rad
!!  exten(4) : Sum( x*x )   cm*cm
!!  exten(5) : Sum( xp*xp )   mrad*mrad
!!  exten(6) : Sum( y*y )   cm*cm
!!  exten(7) : Sum( yp*yp )  mrad*mrad
!!  exten(8) : Sum( x*xp )   cm*mrad
!!  exten(9) : Sum( y*yp )   cm*mrad
!< *******************************************************************
       SUBROUTINE emiprt(L)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       common/etchas/fractx,fracty,fractl
       common/dyn/tref,vref
       common/faisc/f(10,iptsz),imax,ngood
       common/davcom/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/davprt/shortl
       common/qmoyen/qmoy
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/etcha3/ichxyz(iptsz)
       common/speda/dave,idave
       common/cptemit/xltot(maxcell1),nbemit
       common /consta/ vl, pi, xmat, rpel, qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/mcs/imcs,ncstat,cstat(20)
       common/strip/atm,qs,atms,ths,qop,sqst(6),anp,nqst
       common/shortl/davprt
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/frmacc/fracc
       common/dmp/dmpdat(14)
       logical dave,chasit,fracc,acpt
       dimension foo(20,9),NDP(20),chasdat(20),dav2(maxcell1,33)
       character davprt(maxcell1)*80,shortl*80
       nbemit=nbemit+1
!wdk       print*,'nbemit',nbemit     ! wdk
!  ichxyz(i)=1 for particles kept by chase      
!  ichxyz(i)=0 for particles rejected by chase      
       do i=1,ngood
         ichxyz(i)=1
       enddo
       xltot(nbemit)=davtot
       idav=idav+1
       iitem(idav)=3
       dav1(idav,40)=fh
       do i=1,ngood
         ichas(i)=1
       enddo
       iarg=1
       if (L.eq.1) davprt(idav)=shortl
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       CALL EXT2D(1)
! --- qdisp : average dispersion (MeV)
! --- sqmdv:  emittance (MeV*rad)
       qdisp=2.*sqrt(exten(1))
       qmdv=exten(1)*exten(3)-exten(2)*exten(2)
       sqmdv=4.*pi*sqrt(qmdv)
! --- qdp : average extension in phase (rad)
       qdp=2.*sqrt(exten(3))
       fprec=epsilon(exten(1))
! --- cor12: coefficient of correlation in (dE, dPHI)
!       if(exten(1).ne.0. .and. exten(3).ne.0.) then
       if(exten(1)*exten(3) .gt. fprec) then
         cor12=exten(2)/sqrt(exten(1)*exten(3))
       else
         cor12=0.
       endif
! sup       pent12=sqrt(exten(1)/exten(3))/cor12
! sup       pent21=sqrt(exten(1)/exten(3))*cor12
! sup       qdpde=qdp*180./pi
! ---  particle reference
!      dav1(idav,3): relativistic beta
!      dav1(idav,4): Kinetic energy (MeV)
!      dav1(idav,5): phase (in deg. w.r.t. k*pi)
        beref=vref/vl
        gref=1./sqrt(1.-beref*beref)
        dav1(idav,3)=beref
        dav1(idav,4)=xmat*(gref-1.)
!        dav1(idav,5)=-(int(tref*fh/pi+0.5)-tref*fh/pi)*180.
! print out absolute TOF
        dav1(idav,5)=180.*tref*fh/pi
! ---  c.o.g of the bunch
!      dav1(idav,6): Kinetic energy (MeV)
!      dav1(idav,7): phase (in deg. w.r.t. k*pi)
!       phnw=-(int(tcog*fh/pi+0.5)-tcog*fh/pi)*180.
! print out absolute TOF
       phnw=180.*tcog*fh/pi
       dav1(idav,6)=encog-xmat
       dav1(idav,7)=phnw
! ---- deviation between the fictious reference and the c.o.g. of the bunch
!     dav1(idav,8) : deviation in energy (MeV)
!     dav1(idav,9) : deviation of phase (deg)
       dav1(idav,8)=encog-xmat-dav1(idav,4)
       dav1(idav,9)=phnw-dav1(idav,5)
! ---- statistics in z-zp
! --- dav1(idav,10) :  extension dPHI (deg)
! --- dav1(idav,11) :  dispersion dE (MeV)
! --- dav1(idav,12) :  emittance (MeV*rad)
! --- dav1(idav,23) :  correlation in  between dE an dPHI
       dav1(idav,10)=qdp*180./pi
       dav1(idav,11)=qdisp
       dav1(idav,12)=sqmdv/pi
       dmpdat(12)=(1.E12)*dav1(idav,12)/(4.*fh)
       dav1(idav,23)=cor12
! sup       dav1(idav,39)=sqmdv*180./(pi*pi)
! sup       Ez(ns.keV)
! sup       dav1(idav,12)=sqmdv*(1.E09)/(pi*fh)
! ---- statistics in x-xp and y-yp
       trqtx=exten(4)*exten(5)-exten(8)*exten(8)
       trqpy=exten(6)*exten(7)-exten(9)*exten(9)
       surxth=4.*pi*sqrt(trqtx)
       suryph=4.*pi*sqrt(trqpy)
       qditax=2.*sqrt(exten(4))
       qdiant=2.*sqrt(exten(5))
       qditay=2.*sqrt(exten(6))
       qdianp=2.*sqrt(exten(7))
!  dav1(idav,13): extension in x (mm)
!  dav1(idav,14): extension in xp (mrad)
! --- dav1(idav,15): correlation between x and xp
       dav1(idav,13)=qditax*10.
       dav1(idav,14)=qdiant
       dav1(idav,15)=0.
!       if (exten(4).ne.0. .and. exten(5).ne.0.)
       if(exten(4)*exten(5) .gt. fprec)      
     *   dav1(idav,15)=exten(8)/sqrt(exten(4)*exten(5))
!    Emittance(norm)  x-xp (mm*mrad)
       dav1(idav,16)=bcog*surxth*10./(pi*sqrt(1.-bcog*bcog))
       dmpdat(10)=dav1(idav,16)/4.
!    Emittance(non norm) x-xp (mm*mrad)
       dav1(idav,17)=surxth*10./pi
! --- dav1(idav,18): y-extension  (mm)
! --- dav1(idav,19): yp-extension (mrad)
! --- dav1(idav,20): correlation between y and yp
       dav1(idav,20)=0.
!       if (exten(6).ne.0. .and. exten(7).ne.0.)
       if(exten(6)*exten(7) .gt. fprec)     
     *   dav1(idav,20)=exten(9)/sqrt(exten(6)*exten(7))
       dav1(idav,18)=qditay*10.
       dav1(idav,19)=qdianp
!    dav1(idav,21) : Emittance(norm) y-yp (pi*mm*mrad)
       dav1(idav,21)=bcog*suryph*10./(pi*sqrt(1.-bcog*bcog))
       dmpdat(11)=dav1(idav,21)/4.
!    dav1(idav,22) : Emittance(non norm) y-yp (mm*mrad)
       dav1(idav,22)=suryph*10./pi
       dav1(idav,30)=float(ngood)
       dav1(idav,31)=cog(4)*10.
       dav1(idav,32)=cog(5)
       dav1(idav,33)=cog(6)*10.
       dav1(idav,34)=cog(7)
! next card to indicate no chase
       dav1(idav,26)=0.
!****************************       
! --- statistics with chase *
!****************************  
       if (chasit .and. .not. fracc) then
         write(16,*)' EMIT: # of good particles             :',ngood
         if(fractl.lt.1.) then
! ---  chase in z-zp
           call chasel
! ngz is number of retained particles in Z         
           ngz=0
           do i=1,ngood
             ichxyz(i)=ichas(i)
             if(ichxyz(i).eq.1) ngz=ngz+1
           enddo
           write(16,*)' EMIT: # of retained particles (chasel):',ngz
           iarg=1
           call cdg(iarg)
           tcog=cog(3)
           encog=cog(1)
           gcog=encog/xmat
           bcog=sqrt(1.-1./(gcog*gcog))
           enprt=encog-xmat
           CALL EXT2D(1)
           qmdv=exten(1)*exten(3)-exten(2)*exten(2)
           trqty=exten(4)*exten(5)-exten(8)*exten(8)
           trqpz=exten(6)*exten(7)-exten(9)*exten(9)
!     qdisp : average dispersion dE (MeV)
           qdisp=2.*sqrt(exten(1))
!     qdp : average extension dPHI (rad)
           qdp=2.*sqrt(exten(3))
!     cor12: coefficient of correlation in (dE, dPHI)
           cor12=exten(2)/sqrt(exten(1)*exten(3))
! ---  fictitious reference
!      dav2(idav,3): relativistic beta
!      dav2(idav,4): Kinetic energy (MeV)
!      dav2(idav,5): phase (in deg. w.r.t. k*pi)
           beref=vref/vl
           gref=1./sqrt(1.-beref*beref)
           dav2(idav,3)=beref
           dav2(idav,4)=xmat*(gref-1.)
           dav2(idav,5)=180.*tref*fh/pi
! ---  c.o.g of the bunch
!      dav2(idav,6): Kinetic energy (MeV)
           dav2(idav,6)=encog-xmat
! ---- deviation between fictitious reference and c.o.g.
!     dav2(idav,8) : deviation in energy (MeV)
           dav2(idav,8)=encog-xmat-dav2(idav,4)
! ---- caracteristics of the bunch in longitudinal plane (dE, dPHI)
!       dav2(idav,10) :  dPHI extension (deg)
!       dav2(idav,11) :  dispersion dE (MeV)
!       dav2(idav,23) :  coefficient of correlation in  (dE, dPHI)
           dav2(idav,10)=qdp*180./pi
           dav2(idav,11)=qdisp
           dav2(idav,23)=cor12
! 2016-05-16
           chasdat(1)=davtot/100.
           chasdat(2)=100.*fractl
           chasdat(3)=encog-xmat
           chasdat(4)=180.*tcog*fh/pi
! long emittance in keV.ns         
           chasdat(7)=1.e12*sqrt(qmdv)/fhinit
! h emittance                  
           chasdat(5)=bcog*sqrt(trqty)*10./(sqrt(1.-bcog*bcog))
! v emittance                  
           chasdat(6)=bcog*sqrt(trqpz)*10./(sqrt(1.-bcog*bcog))
! write the chasel data
           write(46,
     *      '(1x,E13.6,1x,F6.3,5(1x,E13.6),1x,I6,1x,I6,8(1x,E13.6))')
     *     (chasdat(klm),klm=1,7),ngz,ngood,
     *     (10.*chexmin(mlk),10.*chexmax(mlk),mlk=1,2),        
     *     (chexmin(mlk),chexmax(mlk),mlk=3,4)        
           do i=1,ngood
             ichas(i)=1
           enddo
         endif        
         if(fractx.lt.1.) then
! ---  chase in x-xp
           call chasex
! ngx is number of retained particles in X         
           ngx=0
!  ichxyz(i)=1 for particles kept by chase      
!  ichxyz(i)=0 for particles rejected by chase      
           do i=1,ngood
             ichxyz(i)=1
           enddo
           do i=1,ngood
             ichxyz(i)=ichas(i)*ichxyz(i)
             if(ichxyz(i).eq.1) ngx=ngx+1
           enddo
           write(16,*)' EMIT: # of retained particles (chasex):',ngx
           iarg=1
           call cdg(iarg)
           tcog=cog(3)
           encog=cog(1)
           gcog=encog/xmat
           bcog=sqrt(1.-1/(gcog*gcog))
           dav2(idav,26)=cog(4)*10.
           dav2(idav,27)=cog(5)
           CALL EXT2D(1)
           qmdv=exten(1)*exten(3)-exten(2)*exten(2)
           trqty=exten(4)*exten(5)-exten(8)*exten(8)
           trqpz=exten(6)*exten(7)-exten(9)*exten(9)
           surxth=4.*pi*sqrt(trqty)
           qditax=2.*sqrt(exten(4))
           qdiant=2.*sqrt(exten(5))
!cc below for fourth line of EMIT output
! ---- caracteristics of the bunch in x-direction
!        dav2(idav,13): x-extension (mm)
!        dav2(idav,14): xp-extension (mrad)
!        dav2(idav,15): coefficient of correlation in plane (x, xp)
           dav2(idav,13)=qditax*10.
           dav2(idav,14)=qdiant
           dav2(idav,15)=0.
           fprec=epsilon(exten(4))              
!           if (exten(4).ne.0. .and. exten(5).ne.0.)
           if(exten(4)*exten(5).gt.fprec)
     *     dav1(idav,15)=exten(8)/sqrt(exten(4)*exten(5))
!    Emittance(non norm) in x-xp (mm*mrad)
!           dav2(idav,17)=surxth*10./pi
! 2016-05-16
           chasdat(1)=davtot/100.
           chasdat(2)=100.*fractx
           chasdat(3)=encog-xmat
           chasdat(4)=180.*tcog*fh/pi
! long emittance in keV.ns         
           chasdat(7)=1.e12*sqrt(qmdv)/fhinit
! h emittance                  
           chasdat(5)=bcog*sqrt(trqty)*10./(sqrt(1.-bcog*bcog))
! v emittance                  
           chasdat(6)=bcog*sqrt(trqpz)*10./(sqrt(1.-bcog*bcog))
! write the chasex data
           write(44,
     *      '(1x,E13.6,1x,F6.3,5(1x,E13.6),1x,I6,1x,I6,8(1x,E13.6))')
     *     (chasdat(klm),klm=1,7),ngx,ngood,
     *     (10.*chexmin(mlk),10.*chexmax(mlk),mlk=1,2),        
     *     (chexmin(mlk),chexmax(mlk),mlk=3,4)        
           do i=1,ngood
             ichas(i)=1
           enddo
         endif
         if(fracty.lt.1.) then
! ---  chase in y-yp
           call chasey
! ngy is number of retained particles in Y         
           ngy=0
!  ichxyz(i)=1 for particles kept by chase      
!  ichxyz(i)=0 for particles rejected by chase      
           do i=1,ngood
             ichxyz(i)=1
           enddo
           do i=1,ngood
             ichxyz(i)=ichas(i)*ichxyz(i)
             if(ichxyz(i).eq.1) ngy=ngy+1
           enddo
           write(16,*)' EMIT: # of retained particles (chasey):',ngy
           write(16,*)
           iarg=1
           call cdg(iarg)
           tcog=cog(3)
           encog=cog(1)
           gcog=encog/xmat
           bcog=sqrt(1.-1./(gcog*gcog))
           dav2(idav,28)=cog(6)*10.
           dav2(idav,29)=cog(7)
           CALL EXT2D(1)
           qmdv=exten(1)*exten(3)-exten(2)*exten(2)
           trqty=exten(4)*exten(5)-exten(8)*exten(8)
           trqpz=exten(6)*exten(7)-exten(9)*exten(9)
           suryph=4.*pi*sqrt(trqpz)
           qditay=2.*sqrt(exten(6))
           qdianp=2.*sqrt(exten(7))
!     dav2(idav,18): y-extension  (mm)
!     dav2(idav,19): yp-extension (mrad)
!     dav2(idav,20): coefficient of correlation in the plane (y, yp)
           dav2(idav,20)=0.
!           if (exten(6).ne.0. .and. exten(7).ne.0.)
           if(exten(6)*exten(7).gt.fprec)
     *       dav2(idav,20)=exten(9)/sqrt(exten(6)*exten(7))
           dav2(idav,18)=qditay*10.
           dav2(idav,19)=qdianp
!    dav1(idav,22) : Emittance(non norm) in y-yp (mm*mrad)
!           dav2(idav,22)=suryph*10./pi
! 2016-05-16
           chasdat(1)=davtot/100.
           chasdat(2)=100.*fracty
           chasdat(3)=encog-xmat
           chasdat(4)=180.*tcog*fh/pi
! long emittance in keV.ns         
           chasdat(7)=1.e12*sqrt(qmdv)/fhinit
! h emittance                  
           chasdat(5)=bcog*sqrt(trqty)*10./(sqrt(1.-bcog*bcog))
! v emittance                  
           chasdat(6)=bcog*sqrt(trqpz)*10./(sqrt(1.-bcog*bcog))
! write the chasey data
           write(45,
     *      '(1x,E13.6,1x,F6.3,5(1x,E13.6),1x,I6,1x,I6,8(1x,E13.6))')
     *     (chasdat(klm),klm=1,7),ngy,ngood,
     *     (10.*chexmin(mlk),10.*chexmax(mlk),mlk=1,2),        
     *     (chexmin(mlk),chexmax(mlk),mlk=3,4)        
           do i=1,ngood
             ichas(i)=1
           enddo
         endif
       endif
! print energy, boro etc for each charge state in long
       if(ncstat.gt.1) then
         write(16,'(1x,a4)') 'EMIT'
         DO k=1,ncstat
           NDP(k)=0
           do j=2,7
             foo(k,j)=0.
           enddo
         ENDDO
         DO i=1,imax
           if(int(f(8,i)).eq.1) then
             DO k=1,ncstat
!               if(f(9,i).eq.cstat(k)) then
               if(int(f(9,i)).eq.int(cstat(k))) then
                 NDP(k)=NDP(k)+1
                 do j=2,7
                   foo(k,j)=foo(k,j)+f(j,i)
                 enddo
               endif
             ENDDO
           endif
         ENDDO
         DO k=1,ncstat
           if(NDP(k).ne.0) then
             do j=2,7
               foo(k,j)=foo(k,j)/float(NDP(k))
             enddo
           endif
         ENDDO
         write(16,*) ' Q     Particles  beta       Wcog(MeV)',
     *     '    Wcog(MeV/u)  Pcog(kG.cm)     TOF(deg)   TOF(sec)   ',
     *     '     X_avg(cm)     Xp_avg(mrad)  ',
     *     'Y_avg(cm)     Yp_avg(mrad)'
         DO k=1,ncstat
           if(NDP(k).ne.0) then
             gref=foo(k,7)/xmat
             bref=sqrt(1.-1./(gref*gref))
             xe=(gref-1.)*xmat
!   magnetic rigidity
             bor=3.3356*xmat*bref*gref/cstat(k)
!             write(16,'(2x,f6.2,3x,I5,5x,F9.7,
!     *       5(1x,E12.5),1x,4(F12.5,2x))')
       write(16,'(2x,f6.2,3x,I5,5x,F9.7,5(1x,E14.7),1x,4(F12.5,2x))')
     *       cstat(k),NDP(k),bref,xe,xe/atm,bor,foo(k,6)*180.*fh/pi,
     *       foo(k,6),foo(k,2),foo(k,3),foo(k,4),foo(k,5)
           else
             write(16,'(2x,f5.2,3x,I5)') cstat(k),NDP(k)
           endif
         ENDDO
         write(16,*)
       endif
       return
       end
!> *******************************************************************
!! SUBROUTINE emit3d
!! get beam data following RDBEAM for TRACE3D file
!< *******************************************************************
       SUBROUTINE emit3d
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       common/dyn/tref,vref
       common/faisc/f(10,iptsz),imax,ngood
       common/qmoyen/qmoy
       common/etcom/cog(8),exten(17),fd(iptsz)
       common /consta/ vl, pi, xmat, rpel, qst
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/trace3e/tracebi(6),traceei(3)
       character trace3h*128,trace3t*128,tif*128
       iarg=1
       call cdg(iarg)
       CALL EXT2D(1)
! --- qdisp : average dispersion (MeV)
! --- sqmdv:  emittance (MeV*rad)
       qdisp=2.*sqrt(exten(1))
       qmdv=exten(1)*exten(3)-exten(2)*exten(2)
       sqmdv=4.*pi*sqrt(qmdv)
! --- qdp : average extension in phase (rad)
       qdp=2.*sqrt(exten(3))
! --- cor12: coefficient of correlation in (dE, dPHI)
       cor12=exten(2)/sqrt(exten(1)*exten(3))
! ---- statistics in x-xp and y-yp
       trqtx=exten(4)*exten(5)-exten(8)*exten(8)
       trqpy=exten(6)*exten(7)-exten(9)*exten(9)
       surxth=4.*pi*sqrt(trqtx)
       suryph=4.*pi*sqrt(trqpy)
       qditax=2.*sqrt(exten(4))
       qdiant=2.*sqrt(exten(5))
       qditay=2.*sqrt(exten(6))
       qdianp=2.*sqrt(exten(7))
! trace3d
! x-xp (mm*mrad)
       emitx=surxth*10./pi
       sgn=1.
       fprec=epsilon(exten(4))
!       if (exten(4).ne.0. .and. exten(5).ne.0.)
       if (exten(4)*exten(5).gt.fprec)
     *   sgn=exten(8)/sqrt(exten(4)*exten(5))
       betax=qditax*10.*qditax*10./emitx
       gamx=qdiant*qdiant/emitx
       alphax=sqrt(betax*gamx-1.)
       if(sgn.gt.0.) alphax=-alphax
! y-yp (mm*mrad)
       emity=suryph*10./pi
       sgn=1.
!       if (exten(6).ne.0. .and. exten(7).ne.0.)
       if (exten(6)*exten(7).gt.fprec)
     *   sgn=exten(9)/sqrt(exten(6)*exten(7))
       betay=qditay*10.*qditay*10./emity
       gamy=qdianp*qdianp/emity
       alphay=sqrt(betay*gamy-1.)
       if(sgn.gt.0.) alphay=-alphay
! z-zp (keV*deg)
       emitz=sqmdv/pi*1000.*(180./pi)
       betaz=qdp*180./pi*qdp*180./pi/emitz
       gamz=qdisp*1000.*qdisp*1000./emitz
       alphaz=sqrt(betaz*gamz-1.)
       if(cor12.gt.0.) alphaz=-alphaz
! store parameters for trace3d
       tracebi(1)=alphax
       tracebi(2)=betax
       tracebi(3)=alphay
       tracebi(4)=betay
       tracebi(5)=alphaz
       tracebi(6)=betaz
       traceei(1)=emitx
       traceei(2)=emity
       traceei(3)=emitz
       return
       end
!> *******************************************************************
!! SUBROUTINE statis
!! statitics of the 6-d ellipsoid (for print)
!! calls EXT2D:
!!  exten(1) : Sum( dE(i)*dE(i) )  MeV*MeV
!!  exten(2) : Sum( dE(i)*dPHase(i) ) MeV*rad
!!  exten(3) : Sum( dPHase(i)*dPHase(i) ) rad*rad
!!  exten(4) : Sum( x(i)*x(i) )   cm*cm
!!  exten(5) : Sum( xp(i)*xp(i) )   mrad*mrad
!!  exten(6) : Sum( y(i)*y(i) )   cm*cm
!!  exten(7) : Sum( yp(i)*yp(i) )  mrad*mrad
!!  exten(8) : Sum( x(i)*xp(i) )   cm*mrad
!!  exten(9) : Sum( y(i)*yp(i) )   cm*mrad
!< *******************************************************************
       SUBROUTINE statis
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/DYN/TREF,VREF
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/STIS/surxth,suryph,enedep,ecogde,TESTCA
       common/etcom/cog(8),exten(17),fd(iptsz)
! EXT2D looks for average extensions squared and returns them in EXTEN
       iarg=1
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       BREF=VREF/VL
       GREF=1./SQRT(1.-BREF*BREF)
       ENREF=XMAT*GREF
       CCGP=(tcog-tref)*fh*180./pi
       CCGD=ENCOG-ENREF
       DO I=1,ngood
         gpai=f(7,i)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         fd(i)=bpai/bcog * gpai/gcog
       enddo
       CALL EXT2D(1)
       TESTCA=exten(1)*exten(2)*exten(3)
       IF(abs(TESTCA).gt.1.e-40) THEN
         QDISP=2.*SQRT(exten(1))
         QMD=exten(1)*exten(3)-exten(2)*exten(2)
         SURM=4.*PI*SQRT(QMD)*180./PI
         QDP=2.*SQRT(exten(3))
         COR12=exten(2)/sqrt(exten(1)*exten(3))
!  sup         PENT12=SQRT(exten(1)/exten(3))/COR12
!  sup         PENT21=SQRT(exten(1)/exten(3))*COR12
         QDPDE=QDP*180./PI
       ELSE
         QDISP=0.
         QMD=0.
         SURM=0.
         QDP=0.
         COR12=0.
         PENT12=0.
         PENT21=0.
         QDPDE=0.
       ENDIF
       TRQTX=EXTEN(4)*EXTEN(5)-EXTEN(8)*EXTEN(8)
       TRQPY=EXTEN(6)*EXTEN(7)-EXTEN(9)*EXTEN(9)
       QDITAX=2.*SQRT(EXTEN(4))
       QDIANT=2.*SQRT(exten(5))
       QDITAY=2.*SQRT(EXTEN(6))
       QDIANP=2.*SQRT(exten(7))
       SURXTH=4.*PI*SQRT(TRQTX)
       SURYPH=4.*PI*SQRT(TRQPY)
       SQMDV=4.*PI*SQRT(QMD)
       WRITE(16,52)IMAX,ngood
52     FORMAT(4X,' TOTAL NUMBER OF PARTICLES :',
     X    I7,'   NUMBER OF PARTICLES CONSIDERED :',I7,/)
       WRITE(16,1557)
1557   FORMAT(5X,' *** TRANSVERSE AND LONGITUDINAL STATISTICS')
       WRITE(16,1553) cog(4),cog(5)
1553   FORMAT(4X,' COG COORD   X : ',E12.5,' CM  XP :',E12.5,' MRD')
       WRITE(16,1556) cog(6),cog(7)
1556   FORMAT(4X,' COG COORD   Y : ',E12.5,' CM  YP :',E12.5,' MRD')
       WRITE(16,14)CCGP,CCGD
14     FORMAT(4X,' COG COORD dPHI: ',E12.5,' deg dW :',E12.5,' MeV')
       WRITE(16,1552) QDITAX,QDIANT,SURXTH/pi
1552   FORMAT(4X,' X :',E12.5,' CM  XP :',E12.5,' MRD  EMITTANCE :',
     * E15.8,' CM.MRD')
       WRITE(16,1555) QDITAY,QDIANP,SURYPH/pi
1555   FORMAT(4X,' Y :',E12.5,' CM  YP :',E12.5,' MRD  EMITTANCE :',
     * E15.8,' CM.MRD')
       WRITE(16,154) QDPDE,qdisp,SQMDV*180./(pi*pi)
154    FORMAT(4X,' dPHI :  ',F7.3,' deg dW :',3x,f7.3,3x,
     * 'MeV  EMITTANCE :',E15.8,' MeV.deg',/)
! sup       write(16,*) ' *** ellipse (dE,dPHI) '
! sup       write(16,19) surm,qdp,qdisp,cor12
! sup19     format(' area: ',e12.5,' MeV*deg  half phase extent: ',e12.5,
! sup     *        ' deg half energy extend: ',e12.5,' MeV',/,
! sup     *        ' correlation coef: ',e12.5)
! sup     *
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE tiltbm(icg)
!! tilt and shift of the beam with respect to the cog
!!      TIPHA : Shift on the phase axis(DEG)
!!      TIX   : Shift in the x-direction (CM)
!!      TIY   : Shift in the y-direction   (CM)
!!      SHIFW : Change the energy position of the c.o.g.(MeV)
!!      SHIFP : Change the phase position of the c.o.g.(deg)
!!      DTIPH : Change the position of the phase (radian)
!!      ICG  : = 0 VREF and TREF are the ones of sync. particle
!!      ICG  :. NE. 0 VREF ET TREF are the ones of the c. of g.
!< *******************************************************************
       SUBROUTINE tiltbm(icg)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/TILT/TIPHA,TIX,TIY,SHIFW,SHIFP
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/objet/fo(9,iptsz),imaxo
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/DYN/TREF,VREF
       COMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
       COMMON/newtlt/twissa(3),itwiss
       COMMON/HISTO/CENTRE(6)
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       COMMON/SHIF/DTIPH,SHIFT
       common/tof/tofini
       LOGICAL SHIFT
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       WRITE(16,1)TIPHA,TIX,TIY,SHIFW,SHIFP
1      FORMAT('  Shift the position of the bunch',/,
     X '    in the z-direction :',E12.5,' DEG',/,
     X '    in the x-direction :',E12.5,' CM ',/,
     X '    in the y-direction :',E12.5,' CM ',/,
     X '    shift the energy of the cog with  :',E12.5,' MeV',/,
     X '    shift the phase  of the cog with  :',E12.5,' deg',/)
       TIPHA=TIPHA*PI/180.
       SHIFP=SHIFP*PI/180.
       deg=fh*180./pi
       iarg=1
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
       ELSE  
         PRLAB(IPRF)='TILT    '
       ENDIF  
       call cdg(iarg)
       encog=cog(1)
       tcog=cog(3)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
! --- this routine is called by the routine ENTRE with icg = 1
!       the reference particle is the cog of the bunch
        if(icg.ne.0) then
         tref=tcog
         vref=vl*bcog
         vcour=vref
         gcour=gcog
         bcour=bcog
         WRITE(16,*)'*** Before tilt and shift '
         WRITE(16,24)bcog,tref,tref*deg,encog-xmat
24       FORMAT(1X,'*** The reference particle is the cog:',/,
     X   ' REF AND COG: BETA :',E12.5,2X,'TOF :',E12.5,
     *   ' SEC OR: ',e12.5,' deg',
     x   2x,' ENERGY :',E12.5,' MeV',/)
       endif
       if(icg.eq.0) then
         vcour=vl*bcog
         bcour=bcog
         gcour=gcog
         bvref=vref/vl
         gamref=1./sqrt(1.-bvref*bvref)
         wvref=(gamref-1.)*xmat
         WRITE(16,*)'*** Before tilt and shift '
         WRITE(16,*)'*** The reference particle and cog are distinct'
         WRITE(16,16)bvref,tref,tref*deg,wvref,bcog,tcog,
     *      tcog*deg,encog-xmat
16     FORMAT(2X,'  REF: BETA ',E12.5,
     X ' T.O.F. ',E12.5,' SEC  OR ',E12.5,' DG',
     X ' ENERGY ',E12.5,' MeV',//,2x,
     X '  COG: BETA ',E12.5,' T.O.F. ',
     X  E12.5,' SEC  OR ',E12.5,' DG',
     X ' ENERGY ',E12.5,' MeV',/)
       endif
       DO I=1,ngood
         gapi=f(7,i)/xmat
         bepi=sqrt(1.-1./(gapi*gapi))
         fd(i)=bepi/bcour*gapi/gcour
       ENDDO
       CALL EXT2(1)
!        shift of the ellipse in the longitudinal plane with regard to the cog (TILT)
!        the slip of phase is : TIPHA
!     the ellipsoid generated by GEBEAM and INPUT is upright
!       qdispw=dispersion in energy
       QDISPW=2.*SQRT(exten(10))
       encrt=encog+qdispw
       gamcrt=encrt/xmat
       bcrt=sqrt(1.-1./(gamcrt*gamcrt))
       vcrt=bcrt*vl
       delv=vcrt-vcour
!    shift of the ellipse in the transverse planes with regard to the cog
!  DELTH ET DELPH: slips in xp and yp (mrd)
!     horizontal plane
       delxp=2.*sqrt(exten(5))
!    vertical plane
       delyp=2.*sqrt(exten(7))
       write(16,22) qdispw,delxp,delyp
22     format(' half size in energy ',e12.5,' MeV',/,
     *        ' half size in xp ',e12.5,' mrd',/,
     *        ' half size in yp ',e12.5,' mrd')
!    Shift of the ellipses in the phase spaces
       tcrt=0.
       fprec=epsilon(tcrt)
       do i=1,ngood
         gapi=f(7,i)/xmat
         bpai=sqrt(1.-1./(gapi*gapi))
         vpai=vl*bpai
         dv=(vpai-vcour)*tipha/(delv*fh)
         f(6,i)=f(6,i)-dv
         tcrt=tcrt+f(6,i)
         dlx=0.
         dly=0.
!         if(delxp.ne.0.) dlx=f(3,i)*tix/delxp
!         if(delyp.ne.0.) dly=f(5,i)*tiy/delyp
         if(abs(delxp).gt.fprec) dlx=f(3,i)*tix/delxp
         if(abs(delyp).gt.fprec) dly=f(5,i)*tiy/delyp
         f(2,i)=f(2,i)+dlx
         f(4,i)=f(4,i)+dly
       enddo
       tcrt=tcrt/float(ngood)
       DTIPH=0.
       shtref=0.
!       if(shifw.ne.0. .or. shifp.ne.0.) then
       if(abs(shifw).gt.fprec .or. abs(shifp).gt.fprec) then
         shtref=shifp/fh
         enshift=encog+shifw
         gshift=enshift/xmat
         bshift=sqrt(1.-1./(gshift*gshift))
         eshift=enshift-xmat
         vshift=vl*bshift
         tshift=tcrt+shtref
         deltav=vshift-vcour
         deltat=tshift-tcog
       endif
!       if(shifw.eq.0. .and. shifp.eq.0.) then
       if(abs(shifw).le.fprec .and. abs(shifp).le.fprec) then
         enshift=encog
         eshift=enshift-xmat
         gshift=gcour
         vshift=vcour
         bshift=vshift/vl
         tshift=tcrt
         deltav=0.
         deltat=0.
       endif
       do i=1,ngood
         f(7,i)=f(7,i)+shifw
         gpai=f(7,i)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         f(6,i)=f(6,i)+shtref
         vapi=vl*bpai
       enddo
       if(itwiss.eq.1) tref=tref+tofini
       WRITE(16,*)' ***After tilt and shift '
       bvref=vref/vl
       gamref=1./sqrt(1.-bvref*bvref)
       wvref=(gamref-1.)*xmat
       write(16,16) bvref,tref,tref*deg,wvref,bshift,tshift,
     *              tshift*deg,eshift
       do i=1,ngood
         fo(7,i)=f(7,i)
         fo(2,i)=f(2,i)
         fo(3,i)=f(3,i)
         fo(4,i)=f(4,i)
         fo(5,i)=f(5,i)
         fo(6,i)=f(6,i)
       enddo
       if(itwiss.ne.1) then
         dum=0.
         write(11,*) ngood,dum,fh/(2000000.*pi)
         do i=1,ngood
           f(2,i)=f(2,i)+centre(2)
           f(3,i)=f(3,i)+centre(3)
           f(4,i)=f(4,i)+centre(4)
           f(5,i)=f(5,i)+centre(5)
           f(6,i)=f(6,i)+centre(6)
           f(7,i)=f(7,i)+centre(1)
           etphas=FH*(f(6,i)-tcog)
!option          etener=f(7,i)-encog
           etener=f(7,i)-xmat
           write(11,777) f(2,i),f(3,i)/1000.,f(4,i),f(5,i)/1000.,
     *                   etphas,etener
         enddo
777      format(6(F13.8,1x))
       endif
!      ENVELOPE
       CALL STAPL(davtot*10.)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE tiltbm_bis(icg)
!! Change the positions of the beam in the phase planes
!!      TIPHA : Shift with regard to the phase axis(DEG)
!!      TIX   : Shift in the x-direction (CM)
!!      TIY   : Shift in the y-direction   (CM)
!!      SHIFW : Change the energy position of the c.o.g.(MeV)
!!      SHIFP : Change the phase position of the c.o.g.(deg)
!!      DTIPH : Change the position of the phase (radian)
!!      ICG  : = 0 VREF and TREF are the ones of sync. particle
!!      ICG  :. NE. 0 VREF ET TREF are the ones of the c. of g.
!< *******************************************************************
       SUBROUTINE tiltbm_bis(icg)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/TILT/TIPHA,TIX,TIY,SHIFW,SHIFP
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/objet/fo(9,iptsz),imaxo
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/DYN/TREF,VREF
       COMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
       COMMON/newtlt/twissa(3),itwiss
       COMMON/HISTO/CENTRE(6)
       COMMON/SHIF/DTIPH,SHIFT
!omment      common/tof/tofini
       LOGICAL SHIFT
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       WRITE(16,1)TIPHA,TIX,TIY,SHIFW,SHIFP
1      FORMAT(' shift the position around the c.o.g. of the bunch',/,
     X '    with regard to the phase axis :',E12.5,' DEG',/,
     X '    in the x-direction            :',E12.5,' CM ',/,
     X '    in the y-direction            :',E12.5,' CM ',/,
     X '   Change of energy position of the c.o.g.  :',E12.5,' MEV',/,
     X '   Change of phase  position of the c.o.g.  :',E12.5,' DEG',/)
       shtref=0.
       TIPHA=TIPHA*PI/180.
       SHIFP=SHIFP*PI/180.
       fprec=epsilon(SHIFP)
       deg=fh*180./pi
       iarg=1
       call cdg(iarg)
       encog=cog(1)
       tcog=cog(3)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
!       IF(ICG.NE.0 .AND. (SHIFW.EQ.0. .OR. SHIFP.EQ.0.)) THEN
       IF(ICG.NE.0 .AND. 
     X   (abs(SHIFW).LE.fprec .OR. abs(SHIFP).LE.fprec)) THEN
!      the reference and the cog coincide
         tref=tcog
         vref=vl*bcog
         vcour=vref
         gcour=gcog
         bcour=bcog
         WRITE(16,*)' Before shift '
         WRITE(16,24)VREF,TREF,encog-xmat
24       FORMAT(2X,' Note : reference will coincide with the cog',/,
     X   2X,' velocity :',E12.5,' CM/SEC',2X,'tof :',E12.5,' SEC',/,
     x   2x,' ENERGY :',E12.5,' MeV',/)
       ELSE
!         the reference is distinct from the cog
         vcour=vl*bcog
         bcour=bcog
         gcour=gcog
         bvref=vref/vl
         gamref=1./sqrt(1.-bvref*bvref)
         wvref=(gamref-1.)*xmat
         WRITE(16,*)' Before shift '
         WRITE(16,16)VREF,TREF,tref*deg,wvref,vcour,tcog,
     *      tcog*deg,encog-xmat
       ENDIF
       DO I=1,ngood
         gapi=f(7,i)/xmat
         bepi=sqrt(1.-1./(gapi*gapi))
         fd(i)=bepi/bcour*gapi/gcour
       ENDDO
       CALL EXT2(1)
!        shift of the ellipse in the longitudinal plane with regard to the cog (TILT)
!        the slip of phase is : TIPHA
!     the elipsoid generated from MONTE end ENTRE is upright
!       qdispw=dispersion in energy
       QDISPW=2.*SQRT(exten(10))
       encrt=encog+qdispw
       gamcrt=encrt/xmat
       bcrt=sqrt(1.-1./(gamcrt*gamcrt))
       vcrt=bcrt*vl
       delv=vcrt-vcour
!    shift of the ellipse in the transverse planes with regard to the cog
!  DELTH ET DELPH: slips in xp and yp (MRD)
!     horizontal plane
       delxp=2.*sqrt(exten(5))
!    vertical plane
       delyp=2.*sqrt(exten(7))
       write(16,22) qdispw,delxp,delyp
22     format(' half size in energy ',e12.5,' MeV',/,
     *        ' half size in xp ',e12.5,' mrd',/,
     *        ' half size in yp ',e12.5,' mrd')
!    Shift of the ellipses in the phase spaces
       tcrt=0.
       do i=1,ngood
         gapi=f(7,i)/xmat
         bpai=sqrt(1.-1./(gapi*gapi))
         vpai=vl*bpai
         dv=(vpai-vcour)*tipha/(delv*fh)
         f(6,i)=f(6,i)-dv
         tcrt=tcrt+f(6,i)
         dlx=0.
         dly=0.
!         if(delxp.ne.0.) dlx=f(3,i)*tix/delxp
!         if(delyp.ne.0.) dly=f(5,i)*tiy/delyp
         if(abs(delxp).gt.fprec) dlx=f(3,i)*tix/delxp
         if(abs(delyp).gt.fprec) dly=f(5,i)*tiy/delyp
         f(2,i)=f(2,i)+dlx
         f(4,i)=f(4,i)+dly
       enddo
       tcrt=tcrt/float(ngood)
       DTIPH=0.
!     shift=.true.: The reference and COG are independent
!     shift=.false. The reference and COG are the same
!       IF(SHIFW.NE.0. .OR. SHIFP.NE.0.) THEN
       IF(abs(SHIFW).GT.fprec .OR. abs(SHIFP).GT.fprec) THEN
         SHIFT=.TRUE.
         SHTREF=SHIFP/FH
         enshift=encog+shifw
         gshift=enshift/xmat
         bshift=sqrt(1.-1./(gshift*gshift))
         eshift=enshift-xmat
         vshift=vl*bshift
         tshift=tcrt+shtref
       ELSE
         SHIFT=.FALSE.
         enshift=encog
         eshift=enshift-xmat
         gshift=gcour
         vshift=vcour
         tshift=tcrt
       ENDIF
       if(icg.eq.0) then
         deltav=vshift-vcour
         deltat=tshift-tcog
       else
         deltav=0.
         deltat=0.
         shifw=0.
         shtref=0.
       endif
       write(16,*) 'tofini,tcrt=',tofini,tcrt,tcrt*deg
       if(shift) then
         write(16,*) 'Reference and COG are independent',ICG
       else
         write(16,*) 'Reference and COG coincide',ICG
       endif
       do i=1,ngood
         f(7,i)=f(7,i)+shifw
         gpai=f(7,i)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         f(6,i)=f(6,i)+shtref
         vapi=vl*bpai
       enddo
       if(itwiss.eq.1) tref=tref+tofini
       WRITE(16,*)' After shift '
       bvref=vref/vl
       gamref=1./sqrt(1.-bvref*bvref)
       wvref=(gamref-1.)*xmat
       write(16,16)vref,tref,tref*deg,wvref,vshift,tshift,
     *              tshift*deg,eshift
16     FORMAT(2X,'  REFERENCE: VELOCITY :',E12.5,
     X ' CM/SEC, T.O.F. :',E12.5,' SEC  OR ',E12.5,' DG',/,
     X 3x,' ENERGY : ',E12.5,' MeV',/,2x,
     X '  C.O.G.:    VELOCITY :',E12.5,' CM/SEC, T.O.F. :',
     X E12.5,' SEC OR ',E12.5,' DG',/,
     X 3x,' ENERGY : ',E12.5,' MeV',//)
       bpai=0.
       do i=1,ngood
         fo(7,i)=f(7,i)
         fo(2,i)=f(2,i)
         fo(3,i)=f(3,i)
         fo(4,i)=f(4,i)
         fo(5,i)=f(5,i)
         fo(6,i)=f(6,i)
       enddo
       if(itwiss.ne.1) then
         write(11,*) ngood
         do i=1,ngood
           f(2,i)=f(2,i)+centre(2)
           f(3,i)=f(3,i)+centre(3)
           f(4,i)=f(4,i)+centre(4)
           f(5,i)=f(5,i)+centre(5)
           f(6,i)=f(6,i)+centre(6)
           f(7,i)=f(7,i)+centre(1)
           etphas=FH*(f(6,i)-tcog)
!option          etener=f(7,i)-encog
           etener=f(7,i)-xmat
           write(11,777) f(2,i),f(3,i),f(4,i),f(5,i),etphas,etener
         enddo
777      format(6(F13.8,1x))
       endif
!      ENVELOPE
       CALL STAPL(davtot*10.)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE accept
!! computes a physical beam acceptance at the entrance of the machine
!< *******************************************************************
       SUBROUTINE accept
       implicit real(8) (a-h,o-z)
       parameter(iptsz=1000002)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/tapes/in,ifile,meta,ierr
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/DYN/TREF,VREF
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       COMMON/QMOYEN/QMOY
       common/objet/fo(9,iptsz),imaxo
       COMMON/CONSTA/VL,PI,XMAT,RPEL,QST
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/paths/dpath
       character*(256) dpath,myfile       
       DIMENSION BACK(9,iptsz)
       logical chasit,ACPT,fracc
       common/mcs/imcs,ncstat,cstat(20)
       common/frmacc/fracc
       common/davprt/shortl
       common/files/mcselect,mc
       character mc*2
       LOGICAL mcselect
       character shortl*80
       myfile=''
! make statistics on initial beam using IEX at the point where
! the ACCEPT card has been placed
       write(16,*)
       write(16,*) 'Physical acceptance has:'
       write(16,*) imaxo,' particles at origin'
       iprint=1
       savfh=fh
       satref=tref
       savref=vref
! recall initial frequency
       fh=fhinit
       tref=trefi
       vref=vrefi
! save current beam
       do i=1,9
         do j=1,ngood
           back(i,j)=f(i,j)
         enddo
       enddo
! original particle number is in f(1,j)
! F (I,8): =1 the particle is good,   =0 the particle is lost
! recuperate original particle numbers and their coordinates
! next loop for graphics and file of good particles
       myfile='input_kept.dst'
       if(mcselect) myfile='mc'//mc//'input_kept.dst'       
       lpath=LEN_TRIM(dpath)
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)      
       open(23,file=myfile,status='unknown')
       idum=0
       if(ncstat.gt.1) idum=2      
       write(23,*) ngood,idum, fh/(2000000.*pi)
       do j=1,ngood
         nold=int(f(1,j))
         do jj=1,9
           f(jj,j)=fo(jj,nold)
         enddo
         tprt=fh*f(6,j)
         eprt=f(7,j)-xmat
         f2=f(2,j)
         f3=f(3,j)
         f4=f(4,j)
         f5=f(5,j)
         if(ncstat.gt.1) then
           write(23,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,j)
         else
           write(23,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
         endif
       enddo
       close(23)
! now make graphics
       write(16,*) 'Starting good particles graphics for ACCEPT card'
       igrprm=0
       call ytzp
! print out beam statistics
       fracc=.true.
       shortl='ACCEPT input beam data for retained particles'
       call emiprt(1)
! next loop for graphics and file of lost particles
       myfile='input_lost.dst'
       if(mcselect) myfile='mc'//mc//'input_lost.dst' 
       lpath=LEN_TRIM(dpath)
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)      
       open(23,file=myfile,status='unknown')
       idum=0
       if(ncstat.gt.1) idum=2      
       write(23,*) imax-ngood,idum,fh/(2000000.*pi)
       j=1
       ngd=ngood
       do k=ngood+1,imax
         nold=int(f(1,k))
         do jj=1,9
           f(jj,j)=fo(jj,nold)
         enddo
         tprt=fh*f(6,j)
         eprt=f(7,j)-xmat
         f2=f(2,j)
         f3=f(3,j)
         f4=f(4,j)
         f5=f(5,j)
         if(ncstat.gt.1) then
           write(23,101)f2,f3/1000.,f4,f5/1000.,tprt,eprt,f(9,j)
         else
           write(23,100)f2,f3/1000.,f4,f5/1000.,tprt,eprt
         endif
         j=j+1
       enddo
       ngood=imax-ngood
100    format(6(F15.8,1x))
101    format(7(F15.8,1x))
       close(23)
! now make graphics
       write(16,*) 'Starting lost particles graphics for ACCEPT card'
       igrprm=0
       call ytzp
! print out beam statistics
       shortl='ACCEPT input beam data for rejected particles'
       call emiprt(1)
       fracc=.false.
! recall original coordinates
       ngood=ngd
       do i=1,9
         do j=1,ngood
           f(i,j)=back(i,j)
         enddo
       enddo
       tref=satref
       vref=savref
       fh=savfh
       return
       end
!> *******************************************************************
!! SUBROUTINE ytzp
!! STORAGE OF PARTICLE COORDINATES FOR PLOTS
!< *******************************************************************
       SUBROUTINE ytzp
       implicit real(8) (a-h,o-z)
       parameter(iptsz=1000002)
       CHARACTER TEXT*80,PATITL*80
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DYN/TREF,VREF
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/GRPARM/GLIM(4,2),GLIM1(4,2),GLIM2(4,2),PATITL,
     *        ngraphs(100),idwdp,igrprm,ngrafs
       common/mcs/imcs,ncstat,cstat(20)
       common/zones/frms(6),nzone
       common/objet/fo(9,iptsz),imaxo       
       LOGICAL chasit
       DIMENSION oldcog(7),slim(4,2)
       dimension xx(iptsz),yy(iptsz),cs(iptsz)
       satref=tref
       savref=vref
       init=0
!wdk   print*,'ytzp'
       call area(init)
       if (igrprm.eq.0) then
!        READ GRAPH TITLE
         READ(IN,20) TEXT
20       FORMAT(A)
! idwdp=0 cog=ref in ZZ' plot (for instance for Alvarez structure)
! idwdp=1 cog<>ref in ZZ' plot (for instance for IH structrure)
         READ(IN,*) idwdp,rmsmtp
!       READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!       K=1 HOR. LIMIT , K=2 VERT. LIMIT
         READ(IN,*) ((GLIM(J,K), K=1,2), J=1,4)
       endif
!wdk      if (igrprm.eq.1) then
!wdk        text=patitl
!wdk      endif
!wdk      if (igrprm.eq.2) then
!wdk        text=patitl
!wdk  save limits in GLIM(j,k)
!wdk        do j=1,4
!wdk          do k=1,2
!wdk            slim(j,k)=glim(j,k)
!wdk            glim(j,k)=glim1(j,k)
!wdk          enddo
!wdk        enddo
!wdk      endif
!wdk      if (igrprm.eq.3) then
!wdk        text=patitl
!wdk  save limits in GLIM(j,k)
!wdk        do j=1,4
!wdk          do k=1,2
!wdk            slim(j,k)=glim(j,k)
!wdk            glim(j,k)=glim2(j,k)
!wdk          enddo
!wdk        enddo
!wdk      endif
       do i=1,ngood
         ichas(i)=1
       enddo
       iarg=1
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat  ! wdk gamma-rel
       if(gcog.le.1) then
         write(6,*)
         write(ierr,*) 'Relativistic gamma of COG < 1 in graphics'
         STOP
       endif         
       bcog=sqrt(1.-1./(gcog*gcog))    ! wdk beta-rel
       tcog=cog(3)
       oldcog(1)=cog(4)
       oldcog(2)=cog(5)
       oldcog(3)=cog(6)
       oldcog(4)=cog(7)
       oldcog(5)=cog(3)
       oldcog(6)=cog(8)
       oldcog(7)=cog(1)
       enprt=encog-xmat     ! wdk tkin
       teps=1.e-08
       rmssz=sqrt(rmsmtp)   ! wdk emittance of ellipses
       iarg=1
       call ext2(iarg)      ! wdk calc moments
       QDISP=rmssz*SQRT(exten(1))
       QMD=exten(1)*exten(3)-exten(2)*exten(2)
       QMDW=exten(10)*exten(3)-exten(11)*exten(11)
       SURM=rmsmtp*180.*SQRT(QMD)
       QDP=rmssz*SQRT(exten(3))
       fprec=epsilon(exten(1))
!       if(exten(1).ne.0. .and. exten(3).ne.0.) then
       if(exten(1)*exten(3).gt.fprec) then
         COR12=exten(2)/sqrt(exten(1)*exten(3))
         PENT12=SQRT(exten(1)/exten(3))/COR12
         PENT21=SQRT(exten(1)/exten(3))*COR12
       else
         COR12=0.
         PENT12=0.
         PENT21=0.
       ENDIF
       QDPDE=QDP*180./pi
       TRQTY=exten(4)*exten(5)-exten(8)*exten(8)
       TRQPZ=exten(6)*exten(7)-exten(9)*exten(9)
       SURYTH=rmsmtp*PI*SQRT(TRQTY)
       SURZPH=rmsmtp*PI*SQRT(TRQPZ)
       QDITAY=rmssz*SQRT(exten(4))
       QDIANT=rmssz*SQRT(exten(5))
       QDITA=rmssz*SQRT(exten(6))
       QDIANP=rmssz*SQRT(exten(7))
       write(16,*) '*** PLOT Ellipse for ',rmsmtp,' RMS'
       write(16,'(1x,a)') text
       WRITE(16,1557) IMAX,ngood
1557   FORMAT(1x,'*** GRAPH, TOTAL NUMBER OF PARTICLES : ',I7,
     1 ' PARTICLES KEPT : ',I7,//,' ***  HORIZONTAL phase plane ',/)
       WRITE(16,1553) cog(4),cog(5)
1553   FORMAT(4X,' C.O.G. :',
     1 5X,' X : ',E12.5,' CM  XP :',E12.5,' MRD',/)
       if(rmsmtp.gt.teps) then
         WRITE(16,1552) QDITAY,QDIANT,SURYTH
1552     FORMAT(4X,' 1/2 EXTENSION X : ',E12.5,' CM',/,4X,
     1   ' 1/2 EXTENSION XP : ',E12.5,' MRD',4X,
     2   ' SURFACE : ',E15.8,' CM.MRD',/)
       endif
       WRITE(16,1554)
1554   FORMAT(' ***  VERTICAL phase plane ',/)
       WRITE(16,1556) cog(6),cog(7)
1556   FORMAT(4X,' C.O.G :',
     1   5X,' Y : ',E12.5,' CM  YP :',E12.5,' MRD',/)
       if(rmsmtp.gt.teps) then
         WRITE(16,1555) QDITA,QDIANP,SURZPH
1555     FORMAT(4X,' 1/2 EXTENSION Y : ',E12.5,' CM',/,4X,
     1   ' 1/2 EXTENSION YP : ',E12.5,' MRD',4X,
     2   ' SURFACE : ',E15.8,' CM.MRD',/)
       endif
! Store header and particle coordinates in binary file for
! graphics post-processor
!
! igrtyp is type of graph
!        igrtyp=1  for ytzp emittance plots
!        igrtyp=6  for ytzp emittance plots for multi-charge state beam
!        igrtyp=11 for ytzp emittance plots with ZONES card
!
       igrtyp=1
       if(nzone.ne.0)igrtyp=11
       if(imcs.eq.1) igrtyp=6
       WRITE(66,*) igrtyp
       if (igrtyp.eq.6)then
         write(66,*) ncstat
         write(66,*) (cstat(j),j=1,ncstat)
       endif
       if (igrtyp.eq.11)then
         write(66,*) nzone
         write(66,*) (frms(j),j=2,nzone),' 0.'
       endif
       WRITE(66,*) text
       xx(1)=GLIM(1,1)
       yy(1)=GLIM(1,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
! first store ellipse coordinates XX'
       step=qdiant/50.
       TTA=exten(5)
       do i=1,101
         xii=-qdiant+step*float(i-1)
         yy(i)=xii+cog(5)
         yy(202-i)=yy(i)
         TTB=exten(8)*XII
         TTC=exten(4)*XII**2-TRQTY*rmsmtp
         TTCB=TTB**2-TTC*TTA
         IF(TTCB.LE.0.) TTCB=0.
!         IF(TTA.eq.0.) then
         IF(abs(TTA).le.fprec) then
           YI=0.
           YII=0.
         ELSE
           QUOT=TTCB/TTA**2
           YI=TTB/TTA-SQRT(quot)
           YII=TTB/TTA+SQRT(quot)
         ENDIF
         xx(i)=yi+cog(4)
         xx(202-i)=yii+cog(4)
       enddo
       do i=1,201
         WRITE(66,*) xx(i),yy(i)
       enddo
! X,X' now (wdk)
       do i=1,ngood
         xx(i)=F(2,I)
         yy(i)=F(3,I)
       enddo
       if (imcs.eq.1) then
         do i=1,ngood
           cs(i)=f(9,i)
         enddo
       endif
! write particle coordinates to graphics file
       WRITE(66,*) ngood
       if (imcs.eq.0) then
         if(nzone.eq.0) then
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i)
           enddo
         else
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i),f(10,i)
           enddo
         endif
       else
         do i=1,ngood
          WRITE(66,*) xx(i),yy(i),cs(i)
         enddo
       endif
! YY' next
       xx(1)=GLIM(2,1)
       yy(1)=GLIM(2,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
! first write ellipse coordinates
       step=qdianp/50.
       TTA=exten(7)
       do i=1,101
         xii=-qdianp+step*float(i-1)
         yy(i)=xii+cog(7)
         yy(202-i)=yy(i)
         TTB=exten(9)*XII
         TTC=exten(6)*XII**2-TRQPZ*rmsmtp
         TTCB=TTB**2-TTC*TTA
         IF(TTCB.LE.0.) TTCB=0.
!         IF(TTA.eq.0.) then
         IF(abs(TTA).le.fprec) then
           YI=0.
           YII=0.
         ELSE
           QUOT=TTCB/TTA**2
           YI=TTB/TTA-SQRT(quot)
           YII=TTB/TTA+SQRT(quot)
         ENDIF
         xx(i)=yi+cog(6)
         xx(202-i)=yii+cog(6)
       enddo
       do i=1,201
        WRITE(66,*) xx(i),yy(i)
       enddo
! Y,Y' now    (wdk)
       do i=1,ngood
         xx(i)=F(4,I)
         yy(i)=F(5,I)
       enddo
! write particle coordinates to graphics file
       WRITE(66,*) ngood
       if (imcs.eq.0) then
         if(nzone.eq.0) then
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i)
           enddo
         else
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i),f(10,i)
           enddo
         endif
       else
         do i=1,ngood
          WRITE(66,*) xx(i),yy(i),cs(i)
         enddo
       endif
!
!     TRACE GRAPHE ZZ'
       xx(1)=GLIM(3,1)
       yy(1)=GLIM(3,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
!
       xx(1)=GLIM(4,1)
       yy(1)=GLIM(4,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
!       TRACE DE L ELLIPSE  DE CONCENTRATION
       bref=vref/vl
       gref=1./sqrt(1.-bref*bref)
       WREF=XMAT*(gref-1.)
       gcog=1./sqrt(1.-bcog*bcog)
       WCOG=XMAT*(gcog-1.)
       WRITE(16,22) WREF,TREF,WCOG,tcog
22     FORMAT(' *** LONGITUDINAL phase plane ',/,
     1 6X,' REFERENCE : ',
     2 ' ENERGY: ',E15.8,' (MeV), TOF: ',E15.8,' (SEC)',
     3 /,   6X,' COG       : ',
     4 ' ENERGY: ',E15.8,' (MeV), TOF: ',E15.8,' (SEC)',/)
       WRITE(16,167) QMD,SURM,QDP,QDPDE,QDISP,COR12,PENT12,PENT21
167    FORMAT(3X,' ***',
     2 ' 2nd ORDER MOMENTS :',E12.5,' (RD DP/P)**2',
     3 '    SURFACE : ',E12.5,' (DEG DP/P)',/,
     4 6X,' 1/2 EXTENSION PHASE : ',E12.5,' RD ',
     5 ' OR ',E12.5,' DEG',/,6X,
     6 ' 1/2 EXTENSION DISPERSION : ',E15.8,' IN DP/P ',/,6X,
     7 ' CORRELATION COEF : ',E15.8,/,6X,
     8 ' DISPERSION SLOPE: ',E15.8,' (DP/P)/RD ',/,6X,
     9 ' PHASE SLOPE : ',E15.8,' (DP/P)/RD ')
!      GRAPHE DE L ELLIPSE
       step=qdpde/50.
       TTA=exten(3)*180.*180./(pi*pi)
       do i=1,101
         xii=-qdpde+step*float(i-1)
         xx(i)=xii
         xx(202-i)=xx(i)
         TTB=exten(11)*XII*180./pi
         TTC=exten(10)*XII**2-QMDW*rmsmtp*180.*180./(pi*pi)
         TTCB=TTB**2-TTC*TTA
         IF(TTCB.LE.0.) TTCB=0.
!         IF(TTA.eq.0.) then
         IF(abs(TTA).le.fprec) then
           YI=0.
           YII=0.
         ELSE
           QUOT=TTCB/TTA**2
           YI=TTB/TTA-SQRT(quot)
           YII=TTB/TTA+SQRT(quot)
         ENDIF
         yy(i)=yi
         yy(202-i)=yii
       enddo
       enihrf=0.
       if(idwdp.eq.0) then
! Alvarez
         do i=1,201
           WRITE(66,*) xx(i),yy(i) ! wdk ellipse contour
         enddo
       else
! IH
         bref=vref/vl
         gref=1./sqrt(1.-bref*bref)
         ENIHRF=XMAT*(gref-1.)
         PHIHRF=FH*(tcog-tref)*180./pi
         do i=1,201
           axx=phihrf
           ayy=encog-enihrf-xmat
           WRITE(66,*) xx(i)+axx,yy(i)+ayy    ! wdk ellipse contour
         enddo
       endif
!  write particle coordinates to graphics file
        do i=1,ngood
          if (idwdp.eq.0) then
! Alvarez like
            xx(i)=fh*(f(6,i)-tcog)*180./pi    ! z in deg wdk
            yy(i)=f(7,i)-encog                ! DelW in MeV wdk
            if (imcs.eq.1) cs(i)=f(9,i)
          endif
          IF(idwdp.eq.1) THEN
! IH like
            xx(i)=FH*(f(6,i)-tref)*180./pi
            yy(i)=f(7,i)-enihrf-xmat
            if (imcs.eq.1) cs(i)=f(9,i)
          endif
        enddo
!wdk      if (idwdp.eq.0) then
!wdk Alvarez like
!wdk        do i=1,ngood
!wdk          xx(i)=fh*(f(6,i)-tcog)*180./pi
!wdk          yy(i)=f(7,i)-encog
!wdk          if (imcs.eq.1) cs(i)=f(9,i)
!wdk        enddo
!wdk      endif
!wdk      IF(idwdp.eq.1) THEN
!wdk IH like
!wdk        do i=1,ngood
!wdk          xx(i)=FH*(f(6,i)-tref)*180./pi
!wdk          yy(i)=f(7,i)-enihrf-xmat
!wdk          if (imcs.eq.1) cs(i)=f(9,i)
!wdk        enddo
!wdk      endif
! write particle coordinates to graphics file
       WRITE(66,*) ngood
       if (imcs.eq.0) then
         if(nzone.eq.0) then
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i)
           enddo
         else
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i),f(10,i)
           enddo
         endif
       else
         do i=1,ngood
          WRITE(66,*) xx(i),yy(i),cs(i)
         enddo
       endif
! plot emittance  with chase (if applicable)
!       if (chasit) call ytzprc(glim,oldcog,idwdp)
       if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             glim(j,k)=slim(j,k)
           enddo
         enddo
       endif
       tref=satref
       vref=savref
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE ytzp2d
!! STORAGE OF HISTOGRAMMED BEAM DATA FOR PLOTS
!< *******************************************************************
       SUBROUTINE ytzp2d
       implicit real(8) (a-h,o-z)
       parameter(iptsz=1000002)
       CHARACTER TEXT*80,PATITL*80
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DYN/TREF,VREF
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
!       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/GRPARM/GLIM(4,2),GLIM1(4,2),GLIM2(4,2),PATITL,
     *        ngraphs(100),idwdp,igrprm,ngrafs
!       common/mcs/imcs,ncstat,cstat(20)
!       common/zones/frms(6),nzone
!       common/objet/fo(9,iptsz),imaxo       
!       LOGICAL chasit
       DIMENSION oldcog(7),slim(4,2)
!       dimension xx(iptsz),yy(iptsz),cs(iptsz)
       dimension xx(iptsz),yy(iptsz)
       dimension array(100,100)
       satref=tref
       savref=vref
       init=0
!      READ GRAPH TITLE
       READ(IN,20) TEXT
20     FORMAT(A)
! idwdp=0 cog=ref in ZZ' plot (for instance for Alvarez structure)
! idwdp=1 cog<>ref in ZZ' plot (for instance for IH structrure)
       READ(IN,*) idwdp,rmsmtp
!      READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!      K=1 HOR. LIMIT , K=2 VERT. LIMIT
       READ(IN,*) ((GLIM(J,K), K=1,2), J=1,4)
       iarg=1
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat
       if(gcog.le.1) then
         write(6,*)
         write(ierr,*) 'Relativistic gamma of COG < 1 in graphics'
         STOP
       endif         
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       oldcog(1)=cog(4)
       oldcog(2)=cog(5)
       oldcog(3)=cog(6)
       oldcog(4)=cog(7)
       oldcog(5)=cog(3)
       oldcog(6)=cog(8)
       oldcog(7)=cog(1)
       enprt=encog-xmat
       teps=1.e-08
       rmssz=sqrt(rmsmtp)
       iarg=1
       call ext2(iarg)
       QDISP=rmssz*SQRT(exten(1))
       QMD=exten(1)*exten(3)-exten(2)*exten(2)
       QMDW=exten(10)*exten(3)-exten(11)*exten(11)
       SURM=rmsmtp*180.*SQRT(QMD)
       QDP=rmssz*SQRT(exten(3))
       fprec=epsilon(exten(1))
!       if(exten(1).ne.0. .and. exten(3).ne.0.) then
       if(exten(1)*exten(3).gt.fprec) then
         COR12=exten(2)/sqrt(exten(1)*exten(3))
         PENT12=SQRT(exten(1)/exten(3))/COR12
         PENT21=SQRT(exten(1)/exten(3))*COR12
       else
         COR12=0.
         PENT12=0.
         PENT21=0.
       ENDIF
       QDPDE=QDP*180./pi
       TRQTY=exten(4)*exten(5)-exten(8)*exten(8)
       TRQPZ=exten(6)*exten(7)-exten(9)*exten(9)
       SURYTH=rmsmtp*PI*SQRT(TRQTY)
       SURZPH=rmsmtp*PI*SQRT(TRQPZ)
       QDITAY=rmssz*SQRT(exten(4))
       QDIANT=rmssz*SQRT(exten(5))
       QDITA=rmssz*SQRT(exten(6))
       QDIANP=rmssz*SQRT(exten(7))
       write(16,'(1x,a)') text
       WRITE(16,1557) IMAX,ngood
1557   FORMAT(1x,'*** GRAPH, TOTAL NUMBER OF PARTICLES : ',I7,
     1 ' PARTICLES KEPT : ',I7,//,' ***  HORIZONTAL phase plane ',/)
       WRITE(16,1553) cog(4),cog(5)
1553   FORMAT(4X,' C.O.G. :',
     1 5X,' X : ',E12.5,' CM  XP :',E12.5,' MRD',/)
       if(rmsmtp.gt.teps) then
         WRITE(16,1552) QDITAY,QDIANT,SURYTH
1552     FORMAT(4X,' 1/2 EXTENSION X : ',E12.5,' CM',/,4X,
     1   ' 1/2 EXTENSION XP : ',E12.5,' MRD',4X,
     2   ' SURFACE : ',E15.8,' CM.MRD',/)
       endif
       WRITE(16,1554)
1554   FORMAT(' ***  VERTICAL phase plane ',/)
       WRITE(16,1556) cog(6),cog(7)
1556   FORMAT(4X,' C.O.G :',
     1   5X,' Y : ',E12.5,' CM  YP :',E12.5,' MRD',/)
       if(rmsmtp.gt.teps) then
         WRITE(16,1555) QDITA,QDIANP,SURZPH
1555     FORMAT(4X,' 1/2 EXTENSION Y : ',E12.5,' CM',/,4X,
     1   ' 1/2 EXTENSION YP : ',E12.5,' MRD',4X,
     2   ' SURFACE : ',E15.8,' CM.MRD',/)
       endif
! Store header and particle coordinates in binary file for
! graphics post-processor
!
! igrtyp is type of graph
!        igrtyp=16  for ytzp 2D emittance plots
!
       igrtyp=16
       WRITE(66,*) igrtyp
       WRITE(66,*) text
! GRAPH XX' 
       xx(1)=GLIM(1,1)
       yy(1)=GLIM(1,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       xmin=F(2,1)
       xmax=F(2,1)
       xpmin=F(3,1)
       xpmax=F(3,1)
       do i=1,ngood
         xx(i)=F(2,I)
         if(xx(i).gt.xmax) xmax=xx(i)
         if(xx(i).lt.xmin) xmin=xx(i)
         yy(i)=F(3,I)
         if(yy(i).gt.xpmax) xpmax=yy(i)
         if(yy(i).lt.xpmin) xpmin=yy(i)
       enddo
       WRITE(66,*) xmin,xmax,xpmin,xpmax
       nx=20
       ny=20
! write histogrammed data to graphics file
       WRITE(66,*) ngood,nx,ny    
!!!!********write histo data
       call hist2d(ngood,xx,yy,xmin,xmax,xpmin,xpmax,nx,ny,array)
       fmax=array(1,1)
       do i=1,nx
         do j=1,ny
           write(66,*) array(i,j)
           if(array(i,j).gt.fmax) fmax=array(i,j)
         enddo
       enddo
       write(66,*) fmax         
!
! GRAPH YY' next
       xx(1)=GLIM(2,1)
       yy(1)=GLIM(2,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       ymin=F(4,1)
       ymax=F(4,1)
       ypmin=F(5,1)
       ypmax=F(5,1)
       do i=1,ngood
         xx(i)=F(4,I)
         if(xx(i).gt.ymax) ymax=xx(i)
         if(xx(i).lt.ymin) ymin=xx(i)
         yy(i)=F(5,I)
         if(yy(i).gt.ypmax) ypmax=yy(i)
         if(yy(i).lt.ypmin) ypmin=yy(i)
       enddo
       WRITE(66,*) ymin,ymax,ypmin,ypmax
! write histogrammed data to graphics file
!!!!********write histo data
       call hist2d(ngood,xx,yy,ymin,ymax,ypmin,ypmax,nx,ny,array)
       fmax=array(1,1)
       do i=1,nx
         do j=1,ny
           write(66,*) array(i,j)
           if(array(i,j).gt.fmax) fmax=array(i,j)
         enddo
       enddo
       write(66,*) fmax         
!
! GRAPH XY
       xx(1)=GLIM(3,1)
       yy(1)=GLIM(3,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       do i=1,ngood
         xx(i)=F(2,I)
         yy(i)=F(4,I)
       enddo
       WRITE(66,*) xmin,xmax,ymin,ymax
! write histogrammed data to graphics file
!!!!********write histo data
       call hist2d(ngood,xx,yy,xmin,xmax,ymin,ymax,nx,ny,array)
       fmax=array(1,1)
       do i=1,nx
         do j=1,ny
           write(66,*) array(i,j)
           if(array(i,j).gt.fmax) fmax=array(i,j)
         enddo
       enddo
       write(66,*) fmax         
!
! GRAPH ZZ'
       xx(1)=GLIM(4,1)
       yy(1)=GLIM(4,2)
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       bref=vref/vl
       gref=1./sqrt(1.-bref*bref)
       WREF=XMAT*(gref-1.)
       gcog=1./sqrt(1.-bcog*bcog)
       WCOG=XMAT*(gcog-1.)
       WRITE(16,22) WREF,TREF,WCOG,tcog
22     FORMAT(' *** LONGITUDINAL phase plane ',/,
     1 6X,' REFERENCE : ',
     2 ' ENERGY: ',E15.8,' (MeV), TOF: ',E15.8,' (SEC)',
     3 /,   6X,' COG       : ',
     4 ' ENERGY: ',E15.8,' (MeV), TOF: ',E15.8,' (SEC)',/)
       WRITE(16,167) QMD,SURM,QDP,QDPDE,QDISP,COR12,PENT12,PENT21
167    FORMAT(3X,' ***',
     2 ' 2nd ORDER MOMENTS :',E12.5,' (RD DP/P)**2',
     3 '    SURFACE : ',E12.5,' (DEG DP/P)',/,
     4 6X,' 1/2 EXTENSION PHASE : ',E12.5,' RD ',
     5 ' OR ',E12.5,' DEG',/,6X,
     6 ' 1/2 EXTENSION DISPERSION : ',E15.8,' IN DP/P ',/,6X,
     7 ' CORRELATION COEF : ',E15.8,/,6X,
     8 ' DISPERSION SLOPE: ',E15.8,' (DP/P)/RD ',/,6X,
     9 ' PHASE SLOPE : ',E15.8,' (DP/P)/RD ')
       enihrf=0.
!       if(idwdp.eq.0) then
! Alvarez
!         do i=1,201
!           WRITE(66,*) xx(i),yy(i)
!         enddo
!       else
! IH
!         bref=vref/vl
!         gref=1./sqrt(1.-bref*bref)
!         ENIHRF=XMAT*(gref-1.)
!         PHIHRF=FH*(tcog-tref)*180./pi
!         do i=1,201
!           axx=phihrf
!           ayy=encog-enihrf-xmat
!           WRITE(66,*) xx(i)+axx,yy(i)+ayy
!         enddo
!       endif
! write histogrammed data to graphics file
       if (idwdp.eq.0) then
! Alvarez like
         zmin=fh*(f(6,1)-tcog)*180./pi
         zmax=fh*(f(6,1)-tcog)*180./pi
         zpmin=f(7,1)-encog
         zpmax=f(7,1)-encog
         do i=1,ngood
           xx(i)=fh*(f(6,i)-tcog)*180./pi
           yy(i)=f(7,i)-encog
           if(xx(i).gt.zmax) zmax=xx(i)
           if(xx(i).lt.zmin) zmin=xx(i)
           if(yy(i).gt.zpmax) zpmax=yy(i)
           if(yy(i).lt.zpmin) zpmin=yy(i)
         enddo
       elseif(idwdp.eq.1) THEN
! IH like
         zmin=fh*(f(6,1)-tref)*180./pi
         zmax=fh*(f(6,1)-tref)*180./pi
         zpmin=f(7,1)-enihrf-xmat
         zpmax=f(7,1)-enihrf-xmat
         do i=1,ngood
           xx(i)=FH*(f(6,i)-tref)*180./pi
           yy(i)=f(7,i)-enihrf-xmat
           if(xx(i).gt.zmax) zmax=xx(i)
           if(xx(i).lt.zmin) zmin=xx(i)
           if(yy(i).gt.zpmax) zpmax=yy(i)
           if(yy(i).lt.zpmin) zpmin=yy(i)
         enddo
       endif
       WRITE(66,*) zmin,zmax,zpmin,zpmax
! write particle coordinates to graphics file
!!!!********write histo data
       call hist2d(ngood,xx,yy,zmin,zmax,zpmin,zpmax,nx,ny,array)
       fmax=array(1,1)
       do i=1,nx
         do j=1,ny
!           write(66,*) i,j,array(i,j)
           write(66,*) array(i,j)
           if(array(i,j).gt.fmax) fmax=array(i,j)
         enddo
       enddo
       write(66,*) fmax         
       if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             glim(j,k)=slim(j,k)
           enddo
         enddo
       endif
       tref=satref
       vref=savref
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE grcomp(text,iskale)
!! routine for plots
!< *******************************************************************
       SUBROUTINE grcomp(text,iskale)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
!2018       parameter (iptsz=1000002,maxcell1=4004)
       CHARACTER TEXT*80,PATITL*80
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/GRPARM/GLIM(4,2),GLIM1(4,2),GLIM2(4,2),PATITL,
     *       ngraphs(100),idwdp,igrprm,ngrafs
       common/mcs/imcs,ncstat,cstat(20)
       common/zones/frms(6),nzone
       common/hist/xpos(200),xn(200),ypos(200),yn(200),
     *             zpos(200),zn(200),ixt,iyt,izt
       common/hist1/xps(200),xpn(200),yps(200),ypn(200),
     *             zps(200),zpn(200),ixpt,iypt,izpt
       LOGICAL chasit
       dimension xx(iptsz),yy(iptsz),cs(iptsz)
       DIMENSION SLIM(4,2)
       tcog=0.
       do i=1,ngood
         tcog=f(6,i)+tcog
       enddo
       tcog=tcog/float(ngood)
       if (igrprm.eq.1) then
         text=patitl
       endif
       if (igrprm.eq.2) then
         text=patitl
!  save limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             slim(j,k)=glim(j,k)
             glim(j,k)=glim1(j,k)
           enddo
         enddo
       endif
       if (igrprm.eq.3) then
         text=patitl
!  save limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             slim(j,k)=glim(j,k)
             glim(j,k)=glim2(j,k)
           enddo
         enddo
       endif
       write(16,*)
       write(16,*) 'LIMITS',((GLIM(J,K), K=1,2), J=1,4)
! X-Z start
       XYLIZ=GLIM(4,1)*VREF*PI/(180.*FH)
       ZLIX=XYLIZ
       XLIX=GLIM(3,1)
       DSTRLY=GLIM(4,2)
!
! Store header and particle coordinates in binary file for
! graphics post-processor
!
! igrtyp is type of graph
!        igrtyp=2  for grcomp extra plots
!        igrtyp=7  for grcomp extra plots with multi charge state beam
!        igrtyp=12 for grcomp extra plots with ZONES card
       igrtyp=2
       if(nzone.ne.0) igrtyp=12
       if (imcs.eq.1)igrtyp=7
! igrtyp=2,7,12   --> normal scale in envelopes
! igrtyp=17,22,27 --> log    scale in envelopes
       if(iskale.eq.1) then
         WRITE(66,*) igrtyp+15
         write(66,*) dstrly
       else
         WRITE(66,*) igrtyp
       endif
       if (igrtyp.eq.7)then
         write(66,*) ncstat
         write(66,*) (cstat(j),j=1,ncstat)
       endif
       if (igrtyp.eq.12)then
         write(66,*) nzone
         write(66,*) (frms(j),j=2,nzone),' 0.'
       endif
       WRITE(66,*) text
       xx(1)=zlix
       yy(1)=xlix
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       if (imcs.eq.1) then
         do i=1,ngood
           cs(i)=f(9,i)
         enddo
       endif
       if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
         DO I=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tcog-f(6,i))*vl*bpai
           yy(i)=F(2,I)
         ENDDO
       else
! IH type (plot w.r.t. centre of gravity)
         DO I=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tref-f(6,i))*vl*bpai
           yy(i)=F(2,I)
         ENDDO
       endif
! write particle coordinates to graphics file
       WRITE(66,*) ngood
       if (imcs.eq.0) then
         if(nzone.eq.0) then
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i)
           enddo
         else
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i),f(10,i)
           enddo
         endif
       else
         do i=1,ngood
          WRITE(66,*) xx(i),yy(i),cs(i)
         enddo
       endif
! Y-Z start
       ZLIY=XYLIZ
       ZLIY=GLIM(3,2)
       xx(1)=zlix
       yy(1)=zliy
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
         do i=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tcog-f(6,i))*vl*bpai
           yy(i)=F(4,I)
         enddo
       else
! IH type (plot w.r.t. centre of gravity)
         do i=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tref-f(6,i))*vl*bpai
           yy(i)=F(4,I)
         enddo
       endif
! write particle coordinates to graphics file
       WRITE(66,*) ngood
       if (imcs.eq.0) then
         if(nzone.eq.0) then
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i)
           enddo
         else
           do i=1,ngood
             WRITE(66,*) xx(i),yy(i),f(10,i)
           enddo
         endif
       else
         do i=1,ngood
          WRITE(66,*) xx(i),yy(i),cs(i)
         enddo
       endif
! beam profile plots for X,Y & Z
       call histgrm
       write(66,*) ixt
       do i=1,ixt
         write(66,*) xpos(i),xn(i)
       enddo
       write(66,*) iyt
       do i=1,iyt
         write(66,*) ypos(i),yn(i)
       enddo
       write(66,*) izt
       do i=1,izt
         write(66,*) zpos(i),zn(i)
       enddo
! beam profile plots for Xp,Yp & Zp
       write(66,*) ixpt
       do i=1,ixpt
         write(66,*) xps(i),xpn(i)
       enddo
       write(66,*) iypt
       do i=1,iypt
         write(66,*) yps(i),ypn(i)
       enddo
       write(66,*) izpt
       do i=1,izpt
         write(66,*) zps(i),zpn(i)
       enddo
       if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             glim(j,k)=slim(j,k)
           enddo
         enddo
       endif
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE grcomp2d(text,iskale)
!! routine for plots
!< *******************************************************************
       SUBROUTINE grcomp2d(text,iskale)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       CHARACTER TEXT*80,PATITL*80
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
!       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/GRPARM/GLIM(4,2),GLIM1(4,2),GLIM2(4,2),PATITL,
     *       ngraphs(100),idwdp,igrprm,ngrafs
!       common/mcs/imcs,ncstat,cstat(20)
!       common/zones/frms(6),nzone
       common/hist/xpos(200),xn(200),ypos(200),yn(200),
     *             zpos(200),zn(200),ixt,iyt,izt
       common/hist1/xps(200),xpn(200),yps(200),ypn(200),
     *             zps(200),zpn(200),ixpt,iypt,izpt
!       LOGICAL chasit
       dimension xx(iptsz),yy(iptsz)
       DIMENSION SLIM(4,2)
       dimension array(100,100)
       tcog=0.
       do i=1,ngood
         tcog=f(6,i)+tcog
       enddo
       tcog=tcog/float(ngood)
       if (igrprm.eq.1) then
         text=patitl
       endif
       if (igrprm.eq.2) then
         text=patitl
!  save limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             slim(j,k)=glim(j,k)
             glim(j,k)=glim1(j,k)
           enddo
         enddo
       endif
       if (igrprm.eq.3) then
         text=patitl
!  save limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             slim(j,k)=glim(j,k)
             glim(j,k)=glim2(j,k)
           enddo
         enddo
       endif
       write(16,*)
       write(16,*) 'LIMITS',((GLIM(J,K), K=1,2), J=1,4)
! X-Z start
       XYLIZ=GLIM(4,1)*VREF*PI/(180.*FH)
       ZLIX=XYLIZ
       XLIX=GLIM(3,1)
       DSTRLY=GLIM(4,2)
! igrtyp is type of graph
!        igrtyp=18  for grcompd extra plots
       igrtyp=18
! igrtyp=18   --> normal scale in envelopes
! igrtyp=19   --> log    scale in envelopes
       if(iskale.eq.1) then
         WRITE(66,*) igrtyp+1
         write(66,*) dstrly
       else
         WRITE(66,*) igrtyp
       endif
       WRITE(66,*) text
       xx(1)=zlix
       yy(1)=xlix
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       xmin=F(2,1)
       xmax=F(2,1)
       if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
         gpai=f(7,1)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         zmin=(tcog-f(6,1))*vl*bpai
         zmax=(tcog-f(6,1))*vl*bpai
         DO I=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tcog-f(6,i))*vl*bpai
           if(xx(i).gt.zmax) zmax=xx(i)
           if(xx(i).lt.zmin) zmin=xx(i)
           yy(i)=F(2,I)
           if(yy(i).gt.xmax) xmax=yy(i)
           if(yy(i).lt.xmin) xmin=yy(i)           
         ENDDO
       else
! IH type (plot w.r.t. centre of gravity)
         gpai=f(7,1)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         zmin=(tref-f(6,1))*vl*bpai
         zmax=(tref-f(6,1))*vl*bpai
         DO I=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tref-f(6,i))*vl*bpai
           if(xx(i).gt.zmax) zmax=xx(i)
           if(xx(i).lt.zmin) zmin=xx(i)
           yy(i)=F(2,I)
           if(yy(i).gt.xmax) xmax=yy(i)
           if(yy(i).lt.xmin) xmin=yy(i)           
         ENDDO
       endif
       WRITE(66,*) zmin,zmax,xmin,xmax
       nx=20
       ny=20
! write histogrammed data to graphics file
       WRITE(66,*) ngood,nx,ny    
!!!!********write histo data
       call hist2d(ngood,xx,yy,zmin,zmax,xmin,xmax,nx,ny,array)
       fmax=array(1,1)
       do i=1,nx
         do j=1,ny
           write(66,*) array(i,j)
           if(array(i,j).gt.fmax) fmax=array(i,j)
         enddo
       enddo
       write(66,*) fmax         
! Y-Z start
       ZLIY=XYLIZ
       ZLIY=GLIM(3,2)
       xx(1)=zlix
       yy(1)=zliy
       WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
       ymin=F(4,1)
       ymax=F(4,1)
       if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
         do i=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tcog-f(6,i))*vl*bpai
           yy(i)=F(4,I)
           if(yy(i).gt.ymax) ymax=yy(i)
           if(yy(i).lt.ymin) ymin=yy(i)           
         enddo
       else
! IH type (plot w.r.t. centre of gravity)
         do i=1,ngood
           gpai=f(7,i)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           xx(i)=(tref-f(6,i))*vl*bpai
           yy(i)=F(4,I)
           if(yy(i).gt.ymax) ymax=yy(i)
           if(yy(i).lt.ymin) ymin=yy(i)           
         enddo
       endif
       WRITE(66,*) zmin,zmax,ymin,ymax
!!!!********write histo data
       call hist2d(ngood,xx,yy,zmin,zmax,ymin,ymax,nx,ny,array)
       fmax=array(1,1)
       do i=1,nx
         do j=1,ny
!           write(66,*) i,j,array(i,j)
           write(66,*) array(i,j)
           if(array(i,j).gt.fmax) fmax=array(i,j)
         enddo
       enddo
       write(66,*) fmax         
! beam profile plots for X,Y & Z
       call histgrm
       write(66,*) ixt
       do i=1,ixt
         write(66,*) xpos(i),xn(i)
       enddo
       write(66,*) iyt
       do i=1,iyt
         write(66,*) ypos(i),yn(i)
       enddo
       write(66,*) izt
       do i=1,izt
         write(66,*) zpos(i),zn(i)
       enddo
! beam profile plots for Xp,Yp & Zp
       write(66,*) ixpt
       do i=1,ixpt
         write(66,*) xps(i),xpn(i)
       enddo
       write(66,*) iypt
       do i=1,iypt
         write(66,*) yps(i),ypn(i)
       enddo
       write(66,*) izpt
       do i=1,izpt
         write(66,*) zps(i),zpn(i)
       enddo
       if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
         do j=1,4
           do k=1,2
             glim(j,k)=slim(j,k)
           enddo
         enddo
       endif
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE restay
!! motion of particles in a cavity
!! the field can be read from disk in the form (z,E(z)) or it can be
!! listed in the form of a Fourier series expansion
!< *******************************************************************
       SUBROUTINE restay
       implicit real(8) (a-h,o-z)
!      ****************************************************
       parameter (iptsz=1000002,maxcell=3000,maxcell1=4004)
       COMMON/TTFS/DYNT(MAXCELL),DYNTP(MAXCELL),DYNTPP(MAXCELL),
     *   DYNE0(MAXCELL),DYNPH(MAXCELL),DYNLG(MAXCELL),FHPAR,NC
       COMMON/POSI/IST
       COMMON/MIDGAP/ENMIL,VAPMI
       COMMON/AZMTCH/DLG,XMCPH,XMCE
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
!      TRANSIT TIME COEFFICIENTS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/TTFCB/T3K,T4K,S3K,S4K
       COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2,
     *                AA,BB,CC,DD,EE,PCREST,SQCTTF
       COMMON/JACOB/GAKS,GAPS
       common/iter1/DXDKI,DPHII,PHI,DKMSKE,DKMSPHI,RETPH,XKMI,XKM,
     *              DXK00,TKE,T1KE,SKE,S1KE,PHIWC,XK1I,XK1II,XK2II
       common/faisc/f(10,iptsz),imax,ngood
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/rfield/ifield
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/CDEK/DWP(iptsz)
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/compt1/ndtl,ncavmc,ncavnm
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/tapes/in,ifile,meta,ierr
       COMMON/RANEC1/DUMMY(6)
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/speda/dave,idave
       COMMON/SHIF/DTIPH,SHIFT
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/DCSPA/IESP
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       common/appel/irstay,ilost,iavp,ispcel
       common/posc/xpsc
       common/pstpla/tstp
       common/femt/iemgrw,iemqesg
!       common/mode/eflvl,rflvl
       common/aerp/vphase,vfield,ierpf
       common/tofev/ttvols
! ****    reference
! ****     DWRFS(MeV): energy gain
! ****     SPHRFS(rad):phase jump
! ****     PHRFS(rad):phase
! ****       common/parmrf/DWRFS,SPHRFS,PHRFS,ngdrf
       logical iesp,ichaes,irstay,iavp,ispcel,ifield,iemgrw
       LOGICAL SHIFT,CHASIT,ITVOL,IMAMIN,DAVE
!************************************************************
!    XESLN : NEGATIVE LENGHT OF THE DRIFT FOLLOWING THE GAP
!    IF XESLN N.E.0 THEN THE CHARGE SPACE EFFECT IMPLIES THE
!    LENGTH (YLG-XESLN)
       NRRES=NRRES+1
       ncavmc=ncavmc+1
! allow for print out on terminal of gap# on one and the same line
       call PROGRESS(NRTRE,NRRES)
       WRITE(16,*)' CAVITY N :',NRRES
       ilost=0
       aqst=abs(qst)
       qmoy=aqst
! --- the frequency fh may be changed with delfh
       oldfh=fh
!        IDUM : dummy variable (indicate in input file the number of the cavity)
       READ (IN,*) IDUM
!
! --- XESLN (cm): difference between the length of the field YLG and the physical length of the cavity
!      (The space charge is acting on the length (YLG-XESLN) )
!      dphase (deg): phase offset from the phase crest (giving the maximum of energy gain)
!      FFIELD : in percent;
!                    (electric field)=(initial electric field)*(1.+FFIELD/100)
!         isec: flag
!           isec = 0 : The crest phase (or the valley) is adjusted at the entrance of the accelerating element
!           isec = 1 : The crest phase (or the valley)is adjusted at the middle of the accelerating element
!
!           idum is for compatability with CAVNUM
       read (in,*) xesln,dphase,ffield,isec,idum
       ffield=1.+ffield/100.
       fprec=epsilon(ffield)
!       if(ffield.eq.0.) ffield=1.E-12         
       if(abs(ffield).le.fprec) ffield=1.E-12         
       if(ifield) then
! --- The field is read from the disk in file 'field.txt' in the form:
!          z   (cm)   E(z) MV/cm
!     fhc: frequency of the cavity (Hertz) (read in the file 'field.txt' )
         fh=fhc*2.*pi
         ncel=ncell
         atte=att
         ye0=atte
!    flength : length of the field (cm)
         ylg=flength
         SCDIST=YLG-ABS(XESLN)
       else
! --- The field is read in the input list in the form of a Fourier series
         oldfh=fh
!     atte: factor acting on the amplitude of the field (read in the input list)
         ye0=atte
         SCDIST=YLG-ABS(XESLN)
       endif
       dphete=dphase
       if(itvol.and.imamin) then
! ---  adjustment of the phase offset w.r.t. the t.o.f.  (deg)
         ottvol=fh*ttvols*180./pi
         attvol=ottvol
         xkpi=ottvol/360.
         ixkpi=int(xkpi)
         xkpi=(xkpi-float(ixkpi))*360.
         dphase=dphase-xkpi
       endif
! --- iesp, irstay and ispcel: logical flags for space charge computations
       iesp=.false.
       irstay=.true.
       ispcel=.true.
! ---  dwp(*): array reserved to space charge computations
       do i=1,iptsz
         dwp(i)=0.
       enddo
       WRITE(16,150)FH/(2.*pi),YLG,ATTE,ffield,NCEL
150    FORMAT(4X,'FREQUENCY :',E12.5,' Hertz',/,4x,
     x        'FIELD LENGTH :',e12.5,' cm',/,4x,
     x        'FIELD FACTOR (UNITS CONVERSION) :',e12.5,/,4x,
     x        'FIELD FACTOR (ATTENUATION)      :',f12.6,/,4x,
     X        'FIELD DIVIDED IN: ',I4,' SECTIONS ')
       if(.not.imamin) write(16,*) '    PHASE OFFSET: ',dphete,' DEG'
       if(imamin) write(16,1501)dphete,DPHASE,xkpi
1501   format(4x,
     x        'PHASE OFFSET (before adjustment): ',e12.5,' deg',/,4x,
     x        'PHASE OFFSET (after adjustment): ',e12.5,' deg',/,4x,
     *        'ADJUSTMENT ON THE PHASE OFFSET: ',e12.5,' deg')
       BEREF=VREF/VL
       fh0=fh/vl
! --- prediction of transit time factors TK and SK  based on the velocity at the entrance
       TK=TTA0(BEREF)/2. * FFIELD
       SK=TSB0(BEREF)/2. * FFIELD
! --- prediction of PCREST (phase of RF giving the maximum of energy gain in the cavity)
       PCREST=ATAN(-SK/TK)
       DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
       IF(DDWC.LT.0.) PCREST=PCREST+PI
! --- ttvol: time of flight at entrance (sec)
       ttvol=0.
       if(itvol)ttvol=ttvols*fh
!  start file 'short.data'
! --- dav1(idav,3)=0: the particle reference and the cog coincide at the input
! --- dav1(idav,3)=1: the particle reference and the cog are independent
       dav1(idav,3)=0.
       idav=idav+1
       iitem(idav)=1
       dav1(idav,1)=ylg*10.
       dav1(idav,2)=ye0*100.
       tstp=(davtot+ylg*xpsc)*10.
       davtot=davtot+ylg
       dav1(idav,24)=davtot*10.
       dav1(idav,40)=fh
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(dav1(idav,24))
       endif
       iarg=1
       call cdg(iarg)
       enold=cog(1)
       encog=enold
       gcog=enold/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       IF(SHIFT) THEN
! --- the reference particle and the cog are independent
         BEREF=VREF/VL
         GAMREF=1./SQRT(1.-(BEREF*BEREF))
         ENREF=XMAT*GAMREF
         TREFDG=TREF*FH*180./PI
         dav1(idav,3)=1.
       ELSE
! --- the reference particle and the cog are coinciding
         beref=bcog
         vref=bcog*vl
         tref=tcog
         gamref=gcog
         enref=cog(1)
         dav1(idav,3)=0.
       ENDIF
! ---   the reference particle is put in the array f(10,iptsz) at the position ngdrf = ngood + 1
! ****         ngdrf=ngood+1
! ****         BEREF=VREF/VL
! ****         GAMREF=1./SQRT(1.-(BEREF*BEREF))
! ****         ENREF=XMAT*GAMREF
! ****         f(1,ngdrf)=ngdrf
! ****         f(2,ngdrf)=0.
! ****         f(3,ngdrf)=0.
! ****         f(4,ngdrf)=0.
! ****         f(5,ngdrf)=0.
! ****         f(6,ngdrf)=tref
! ****         f(7,ngdrf)=enref
! ****         f(8,ngdrf)=1.
! ****         f(9,ngdrf)=qst
! ****         f(10,ngdrf)=0.
       if(int(dav1(idav,3)).eq.1) write(16,*)
     *   ' ****reference and cog evolve independently'
       if(int(dav1(idav,3)).eq.0) write(16,*)
     *   ' **** the reference is the cog '
       WRITE(16,178)
178    FORMAT(/,' Dynamics at the input',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
       WRITE(16,1788) bcog,gcog,encog-xmat,tcog*fh*180./pi,tcog
1788   FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       ENRPRIN=ENREF-XMAT
       WRITE(16,165) beref,gamref,ENRPRIN,tref*fh*180./pi,tref
165    FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       tofprt=tref
       iprint=0
       call statis
       XK1=FH/VREF
! --- prediction of transit time factors based on an average value of velocity
       DDW=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
       ENREFS=ENREF+DDW
       GAMS= ENREFS/XMAT
       BETS=SQRT(1.-1./(GAMS*GAMS))
       BEMY=(GAMS+GAMREF)/(GAMS*BETS+GAMREF*BEREF)
       BEMY=1./BEMY
       TK0=TTA0(BEMY)/2.  * FFIELD
       TPK0=TTA1(BEMY)/2. * FFIELD
       TPPK0=TTA2(BEMY)/2.* FFIELD
       TP3K0=TTA3(BEMY)/2.* FFIELD
       TP4K0=TTA4(BEMY)/2.* FFIELD
       SK0=TSB0(BEMY)/2.  * FFIELD
       SPK0=TSB1(BEMY)/2. * FFIELD
       SPPK0=TSB2(BEMY)/2.* FFIELD
       SP3K0=TSB3(BEMY)/2.* FFIELD
       SP4K0=TSB4(BEMY)/2.* FFIELD
       TK=TK0
       T1K=TPK0
       T2K=TPPK0
       T3K=TP3K0
       T4K=TP4K0
       SK=SK0
       S1K=SPK0
       S2K=SPPK0
       S3K=SP3K0
       S4K=SP4K0
! ----  prediction of PCREST (crest phase) based on the actual coefficients factors T and S
       PCREST=ATAN(-SK0/TK0)
       DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
       IF(DDWC.LT.0.) PCREST=PCREST+PI
! --- the routine crest is computing the equivalent field lenght: EQVL
       call crest(bemy,eqvl,xpos,sqcttf,ffield)
! ---  follow computations of the parameters:
!            equivalent field length   (cm)
!            asociated drift length    (cm)
!            slip of phase             (rad)
!            energy gain               (MeV)
!            phase jump                (rad)
!            average k (=frequency/velocity) (cm-1)
!            transit time coefficients (MeV,cm)
!            crest phase               (rd)
!            phase of RF at entrance   (rd)
       SAPHI=PCREST
! --- start iterations: improve the average velocity and the transit time factors
       DO IT=1,3
         DTS=(TK*T1K+SK*S1K)/(TK*TK+SK*SK)
         FK1=2.*DTS
         EQVLP=EQVL
! --- computation of the phase slip: PHSLIP
         PHSLIP=-4.*ATAN(3.2*DTS/EQVL)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           TIL2=PHSLIP/2.
           do iiii=1,4
             GX=1./TAN(TIL2)-1./TIL2-FK1/EQVLP
             GPX=-1./(SIN(TIL2)*SIN(TIL2)) + 1./(TIL2*TIL2)
             TIL2=TIL2-GX/GPX
             HX=1./TAN(TIL2)-1./TIL2
             EQVLP=FK1/HX
           enddo
           PHSLIP=TIL2*2.
         ENDIF
         PEQVL=XPOS
         ASDL=PEQVL-EQVL/2.
         F0=XITL0(GAMREF,GAMS,BEMY,SAPHI,AQST)
         DELWRM=(F0-GAMREF)*XMAT
         enrs=enref+delwrm
         gams=enrs/xmat
         bets=sqrt(1.-1./(gams*gams))
! ---  computation of the jump of phase:DELPHR
         COEPH =FH*AQST/(VL*XMAT)
         F3=XITL3(GAMREF,GAMS,BEMY,IT,SAPHI,AQST)
         DELPHR= COEPH * F3
         XK2=FH0/BETS
         XKM=DELPHR/EQVL + XK2*(1.+ASDL/EQVL) - XK1*ASDL/EQVL
         BEMY=FH0/XKM
! --- computations of transit time factors
         TK=TTA0(BEMY)/2.  * FFIELD
         T1K=TTA1(BEMY)/2. * FFIELD
         SK=TSB0(BEMY)/2.  * FFIELD
         S1K=TSB1(BEMY)/2. * FFIELD
       ENDDO
! --- crest phase PCREST (after iterations)
       PCREST=ATAN(-SK/TK)
       DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
       IF(DDWC.LT.0.) PCREST=PCREST+PI
       DCEMD=0.
! --- isec = 0: the phase offset is given relative to the entrance of the cavity
! --- isec = 1: the phase offset is given relative to the middle of the cavity
! --- (vapmi has been computed in the function XITL3 (in deg) )
       if(isec.ne.0) then
         IMEDI=INT(VAPMI/360.+.4)
         DCEMD=VAPMI-360.*IMEDI
         WRITE(16,773) NRRES,ENMIL,VAPMI,DCEMD
773      FORMAT(2X,' AT THE MIDDLE OF THE CAVITY:',i4,/,2x,
     * ' *ENERGY :',E12.5,' MEV  *PHASE :',E12.5,' DEG',2X,
     * ' *SLIP OF PHASE  :',e12.5,' deg',/)
         DCEMD=DCEMD*PI/180.
       endif
!      SAPHI: phase of RF w.r.t. the phase offset
       DPHASE=DPHASE*PI/180.
       SAPHI=PCREST+DPHASE+TTVOL-DCEMD
       DDW=AQST*(TK0*COS(SAPHI)-SK0*SIN(SAPHI))
       enrs=enref+ddw
       gams=enrs/xmat
! --- start new iterations to improve:
!         transit time factors
!         phase slip
!         jump of phase
!         crest phase
!         phase of RF
!
       SAPHO=SAPHI
       DO IT=1,3
         DTS=(TK*T1K+SK*S1K)/(TK*TK+SK*SK)
         FK1=2.*DTS
         EQVLP=EQVL
         PHSLIP=-4.*ATAN(3.2*DTS/EQVL)
!         IF(PHSLIP.NE.0.) THEN
         IF(abs(PHSLIP).GT.fprec) THEN
           TIL2=PHSLIP/2.
           do iiii=1,3
             GX=1./TAN(TIL2)-1./TIL2-FK1/EQVLP
             GPX=-1./(SIN(TIL2)*SIN(TIL2)) + 1./(TIL2*TIL2)
             TIL2=TIL2-GX/GPX
             HX=1./TAN(TIL2)-1./TIL2
             EQVLP=FK1/HX
           enddo
           PHSLIP=TIL2*2.
         ENDIF
         PEQVL=XPOS
         ASDL=PEQVL-EQVL/2.
! --- ENERGY GAIN AND PHASE JUMP
         F0=XITL0(GAMREF,GAMS,BEMY,SAPHI,AQST)
         DELWRM=(F0-GAMREF)*XMAT
         ENRS=ENREF+DELWRM
         gams=enrs/xmat
         bets=sqrt(1.-1./(gams*gams))
         xk2=fh0/bets
! ---    DELPHR: jump of phase
         COEPH =FH*AQST/(VL*XMAT)
         F2=XITL3(GAMREF,GAMS,BEMY,IT,SAPHI,AQST)
         DELPHR= COEPH * F2
! ---   XKM:  average k =  frequency/velocity)
         XKM=DELPHR/EQVL + XK2*(1.+ASDL/EQVL) - XK1*ASDL/EQVL
         BEMY=FH0/XKM
! ---  TRANSIT TIME FACTORS (based on the velocity BEMY)
         TK=TTA0(BEMY)/2.  * FFIELD
         T1K=TTA1(BEMY)/2. * FFIELD
         T2K=TTA2(BEMY)/2. * FFIELD
         T3K=TTA3(BEMY)/2. * FFIELD
         T4K=TTA4(BEMY)/2. * FFIELD
         SK=TSB0(BEMY)/2.  * FFIELD
         S1K=TSB1(BEMY)/2. * FFIELD
         S2K=TSB2(BEMY)/2. * FFIELD
         S3K=TSB3(BEMY)/2. * FFIELD
         S4K=TSB4(BEMY)/2. * FFIELD
         PCREST=ATAN(-SK/TK)
         DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
         IF(DDWC.LT.0.) PCREST=PCREST+PI
         DPHII=(XK1-XK2)*EQVL/10.+(XKP1+XKP2)/120.*EQVL*EQVL
     X         + (XK1-XKM)*ASDL
! --- phase of RF
         SAPHI=PCREST+DPHASE+TTVOL-DCEMD+DPHII
       ENDDO
       savph=saphi*180./pi
!      REFERENCE PARTICLE BASED ON CHARGE STATE: QMOY = ABS(QST)
       CFH=FH/(VL*2.*XMAT)
       CKH=QMOY*QMOY/(4.*XMAT*XMAT)
       DPHII=(XK1-XK2)*EQVL/10.+(XKP1+XKP2)/120.*EQVL*EQVL
     X         + (XK1-XKM)*ASDL
       PHARES=SAPHI+XK2*YLG+DELPHR
       TREFS=TREF+(XK2*YLG+DELPHR)/FH
! ****************************
       PHARED=(PHARES-SAPHI)*180./PI
       TREDG=fh*TREFS *180./PI
! *****  REFERENCE BASED ON THE AVERAGE CHARGE STATE QMOY (if several charges state)
! *****       CFH=FH/(VL*2.*XMAT)
! *****       CKH=QMOY*QMOY/(4.*XMAT*XMAT)
! *****  save the energy and the T.O.F of the particle reference at the input of the cavity
! *****       enri=f(7,ngdrf)
! *****       trefi=f(6,ngdrf)
! *****       call gap(gamref,saphi,gams,delphr)
! *****  trefs and enrs: time of flight and energy of the reference and the output of the cavity
! *****       trefs=f(6,ngdrf)
! *****       enrs=f(7,ngdrf)
! *****       grefs=f(7,ngdrf)/xmat
! *****       bets=sqrt(grefs*grefs-1.)/grefs
! *****       dwrfs=enrs-enri
! *****       PHARES=SAPHI+XK2*YLG+DELPHR
! *****       TREFS=TREF+(XK2*YLG+DELPHR)/FH
! *****       TREDG=fh*TREFS *180./PI
       write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
       write(16,*) '***********************************************'
       write(16,*) ' ENERGY GAIN(MeV) ',DELWRM,' TOF ',tredg,' DEG'
       write(16,*) ' PHASE JUMP(DG) ',DELPHR*180./PI
       write(16,*) ' SLIP OF PHASE AT THE INPUT(DG) ',SAPHO*180./PI
       write(16,*) ' PHASE OF RF AT ENTRANCE(DG) ',savph
       write(16,*) ' AVERAGE k (cm-1) (freq./velocity): ',XKM
       write(16,*) ' Associated drift length ',asdl,' (cm)'
       write(16,*) ' Equivalent field length ',eqvl,' cm center at ',
     *               xpos,' cm'
       write(16,*) ' TRANSIT TIME FACTORS AND DERIVATIVES (MeV,cm):'
       write(16,*) ' T ',TK,T1K,T2K,T3K,T4K
       WRITE(16,*) ' S ',SK,S1K,S2K,S3K,S4K
       write(16,*) ' PHASE SLIP(DEG) ',PHSLIP*180./PI
       write(16,*) ' CREST PHASE OF RF (DEG) ',PCREST*180./PI
       WRITE(16,*) ' MAGNITUDE ',SQCTTF,' MV/cm'
       t0s=sqrt(tk*tk+sk*sk)
       WRITE(16,*) ' T0 ',T0S
! *************************************************************************
       call gap(gamref,saphi,gams,delphr)
       iarg=1
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       CALL EXT2D(1)
       if(itvol) then
        dav1(idav,38)=dphete
        dav1(idav,39)=dphase*180./pi
       else
        dav1(idav,38)=dphete
       endif
       WRITE(16,3777)
3777   FORMAT(/,' Dynamics at the output',/,
     1 5X,'   BETA     dW(MeV)     ENERGY(MeV) ',
     2 '   TOF(deg)     TOF(sec)')
       engain=encog-enold
       WRITE(16,3473) bets,DELWRM,enrs-xmat,fh*TREFS *180./PI,TREFS
3473   FORMAT(' REF ',f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)
       WRITE(16,1789) bcog,engain,encog-xmat,tcog*fh*180./pi,tcog
1789   FORMAT(' COG ',f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)
       TESTCA=exten(1)*exten(2)*exten(3)
!       epsil=1.E-20
       epsil=1.E-40
       IF(abs(TESTCA).gt.epsil) THEN
         QDISP=2.*SQRT(exten(1))
         QMD=exten(1)*exten(3)-exten(2)**2
         SQMDV=4.*PI*SQRT(QMD)
         SURM=4.*PI*SQRT(QMD)*180./PI
         QDP=2.*SQRT(exten(3))
         COR12=exten(2)/sqrt(exten(1)*exten(3))
         QDPDE=QDP*180./PI
       ELSE
         QDISP=0.
         QMD=0.
         SQMDV=0.
         SURM=0.
         QDP=0.
         COR12=0.
         PENT12=0.
         PENT21=0.
         QDPDE=0.
       ENDIF
       TRQTX=exten(4)*exten(5)-exten(8)**2
       TRQPY=exten(6)*exten(7)-exten(9)**2
       QDITAX=2.*SQRT(exten(4))
       QDIANT=2.*SQRT(exten(5))
       QDITAY=2.*SQRT(exten(6))
       QDIANP=2.*SQRT(exten(7))
       SURXTH=4.*PI*SQRT(TRQTX)
       SURYPH=4.*PI*SQRT(TRQPY)
       IF(SHIFT) THEN
         vref=bets*vl
         tref=trefs
       ELSE
         vref=bcog*vl
         tref=tcog
       ENDIF
       if(itvol) then
         ttvols=tref
       endif
       call statis
!      ENVEL
       PRLAB(IPRF)='CAVMC   '
       CALL STAPL(dav1(idav,24))
!omment       WRITE(16,9998) SQMDV
!omment9998   FORMAT(2X,'   EMITTANCE (norm): ',
!omment     *        E12.5,' PI*MEV*RAD')
       dav1(idav,16)=bcog*surxth*10./(pi*sqrt(1.-bcog*bcog))
       dav1(idav,21)=bcog*suryph*10./(pi*sqrt(1.-bcog*bcog))
       dav1(idav,25)=nrres
       dav1(idav,30)=ngood
!
!   print to the file: 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!
! --- dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
! --- dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
       emns=1.e12*sqmdv/(pi*fh)
       tcgprt=fh*tcog*180./pi
       trfprt=fh*tref*180./pi
! cavity number, z (m), transmission (%), synchronous phase (deg), time of flight (deg) (reference),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
       trnsms=100.*float(ngood)/float(imax)
       if(ncavmc.eq.1) write(50,*) '# cavmc.dmp'
       if(ncavmc.eq.1) write(50,*) '# cav     Z       trans   ',
     *   'PHIs     TOF(COG)      COG      Wcog          TOF(REF) ',
     *   '      REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
     *   'El,RMS        dWref        EffVolt'     
       if(ncavmc.eq.1) write(50,*) '#  #     (m)       (%)    ',
     *  '(deg)     (deg)        beta     (MeV)          (deg)    ',
     *  '     beta        (MeV)      (mm.mrad)    (mm.mrad)    ',
     *  '(ns.keV)      (MeV)          (MV)'
       write(50,7023) nrres,0.001*dav1(idav,24),trnsms,dphete,
     *  tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat,
     *  0.25*dav1(idav,16),0.25*dav1(idav,21),0.25*emns,delwrm,
     *  abs(ddwc)/AQST
7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
     *   2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x))
       fh=oldfh
!       new magnetic rigidity of the reference
       gref=1./sqrt(1.-bets*bets)
       xmor=xmat*bets*gref
       BORO=33.356*XMOR*1.E-01/AQST
       WRITE(16,*) ilost,' particles lost in cavity ',nrres
       call emiprt(0)
       return
       end
!> *******************************************************************
!! SUBROUTINE fieldcav(atte)
!! read from disk the electromagnetic field in the form (z,E(z))
!! SUPERFISH units: z(m) E(z) (Volt/m)
!! converted to: z(cm)  E(z) (MVolt/cm)
!< *******************************************************************
       SUBROUTINE fieldcav(atte)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/rfield/ifield
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
!       common/mode/eflvl,rflvl
       common/cavnum1/xnh,xpas,ffield,npt
       common/tapes/in,ifile,meta,ierr
       common/kcell/avrg(15)
       logical ifield
       part=1.
       ifield=.true.
       read(20,*)fhc
!nov02       att=att*(1.+eflvl)
       att=atte
       read(20,*) xspl(1),yspl(1)
       yspl(1)=yspl(1)*att
       xspl(1)=xspl(1)*100.
       fprec=epsilon(xspl(1))
!wdk       print*,'fprec',fprec     !wdk 2.2E-16
       npt=2
       do 
         read(20,*) xspl(npt),yspl(npt)
!         if (xspl(npt).eq.0.) exit
         if (abs(xspl(npt)).le.fprec) exit
         if (npt.gt.4000) then
           write(6,*) 
           write(ierr,*) 'Error reading FIELD file:'
           write(ierr,*) 'FIELD file contains more than 4000 points'
           write(16,*) 'Error reading FIELD file:'
           write(16,*) 'FIELD file contains more than 4000 points'
           STOP
         endif  
         xspl(npt)=xspl(npt)*100.
         yspl(npt)=yspl(npt)*att
         npt=npt+1
       enddo
       npt=npt-1
! **************************************
!wdk        tdep=xspl(1)
!wdk        do it=1,npt
!wdk         xspl(it)=xspl(it)-tdep
!wdk        enddo
! **************************************
!wdk        do it=1,npt                                     !wdk
!wdk           print *,xspl(it),'[cm]',yspl(it),'[MV/cm]'   !wdk
!wdk        enddo                                           !wdk
       call deriv2(npt)
       xpas=(xspl(3)-xspl(2))/part
       xcour=xspl(1)
       nfpt=1
       do i=1,10000
         if(xcour.gt.xspl(npt) ) exit
         yf(i)=spline(npt,xcour)
         xf(i)=xcour
         xcour=xcour+xpas
         nfpt=nfpt+1
       enddo
!   *  valero  mars 2006
       xlimf=xspl(npt)
       xf(nfpt)=0.
!omment       yf(nfpt)=0.
! look for the number of cells,the limits of the cells, the number of coordinates in each cell
       do i=1,15
         npoint(i)=0
       enddo
       ncell=1
       xlim(ncell)=xf(1)
       do i=2,nfpt
!         if (xf(i).eq.0.) then
         if (abs(xf(i)).le.fprec) then
           ncell=ncell+1
           xlim(ncell)=xlimf
           exit
         endif
         if(yf(i)*yf(i-1).lt.0.) then
           ncell=ncell+1
           xlim(ncell)=xf(i)
         else
           npoint(ncell)=npoint(ncell)+1
         endif
       enddo
       flength=xlim(ncell)
       ncell=ncell-1
!       write(16,*) ' ******Read the field of the cavity************'
       write(16,100) ncell,flength,att,fhc
100    format(' Number of cells: ',i3,' field length: ',e12.5,'cm',
     *        ' field factor: ',e12.5,' frequency: ',e12.5,' Hz')
! ******************************************
!  sv 28/10/2015
       call celint
! *****************************************
       do i=1,ncell
         write(16,200) i,xlim(i),xlim(i+1),avrg(i)
       enddo
200    format(' Cell number ',i3,' lower limit ',e12.5,' cm ',
     *        ' upper limit ',e12.5,' cm ','average ',e12.5,' cm')
       return
       end
!> *******************************************************************
!! SUBROUTINE celint
!! average position in the cell
!< *******************************************************************
       SUBROUTINE celint
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/consta/vl,pi,xmat,rpel,qst
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/kcell/avrg(15)
       xlpos=0.
       isce=20
       xlcum=0.
       do inc=1,ncell
         xint1=0.
         xint2=0.
         xnh=0.
         xlcel=xlim(inc+1)-xlim(inc)
         xlpos=xlpos+xlcel
         xpas=xlcel/float(isce)
         xnhc=0
         estop=xpas/10.
         istop=0
         DO
           xpat=xnhc*xpas
           if(xpat.ge.(xlcel-estop)) EXIT
           z0=xnh*xpas
           z1=(xnh+0.20)*xpas
           z2=(xnh+0.40)*xpas
           z3=(xnh+0.60)*xpas
           z4=(xnh+0.80)*xpas
           z5=(xnh+1.00)*xpas
           fpos0=xnh*xpas+xlcum
           fpos1=(xnh+0.20)*xpas+xlcum
           fpos2=(xnh+0.40)*xpas+xlcum
           fpos3=(xnh+0.60)*xpas+xlcum
           fpos4=(xnh+0.80)*xpas+xlcum
           fpos5=(xnh+1.0)*xpas+xlcum
           tspl0=spline(npt,fpos0)
           tspl1=spline(npt,fpos1)
           tspl2=spline(npt,fpos2)
           tspl3=spline(npt,fpos3)
           tspl4=spline(npt,fpos4)
           tspl5=spline(npt,fpos5)
           xspl0=z0*tspl0
           xspl1=z1*tspl1
           xspl2=z2*tspl2
           xspl3=z3*tspl3
           xspl4=z4*tspl4
           xspl5=z5*tspl5
!     integral E(z)*z over the cell
           tspl11=19.*xspl0+75.*xspl1+50.*xspl2+50.*xspl3+75.*xspl4
     *     +19.*xspl5
           xi1=xpas/288. * tspl11
           xint1=xint1+xi1
           xspl0=tspl0
           xspl1=tspl1
           xspl2=tspl2
           xspl3=tspl3
           xspl4=tspl4
           xspl5=tspl5
!     integral E(z) over the cell
           tspl2=19.*xspl0+75.*xspl1+50.*xspl2+50.*xspl3+75.*xspl4
     *     +19.*xspl5
           xi2=xpas/288. * tspl2
           xint2=xint2+xi2
           xnh=xnh+1.
           xnhc=xnhc+1
         ENDDO
         avrg(inc)=xint1/xint2+xlcum
         xlcum=xlcum+xlcel
       enddo
       return
       end
!> *******************************************************************
!! FUNCTION fcav(xc,nrc)
!! electromagnetic field  at the position xc
!< *******************************************************************
       FUNCTION fcav(xc,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/fcv/jsav
       fcav=0.
       if(nrc.eq.1) then
         j=1
       else
         j=jsav
       endif
       fprec=epsilon(xc)
       do k=1,npoint(nrc)
         tk=xc-xf(j)
!         if(tk.eq.0.)then
         if(abs(tk).le.fprec)then
           fcav=yf(j)
           exit
         endif
         if(tk.lt.0.) then
           a=(xc-xf(j-1))/(xf(j)-xf(j-1))
           b=(xf(j)-xc)/(xf(j)-xf(j-1))
           fcav=b*yf(j-1)+a*yf(j)
           exit
         endif
         j=j+1
       enddo
       jsav=j
       return
       end
!> *******************************************************************
!! FUNCTION ta0(betr,nrc)
!! Transit time factor t(k) (single cell)
!< *******************************************************************
       FUNCTION ta0(betr,nrc)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       common/fcv/jsav
       xk=fhc*2.*pi/(betr*vl)
       ar=0.
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         AR=AR+T1(I)*RFONC*COS(XK*XC)
       enddo
       ta0=ar*(xc2-xc1)
       return
       END
!> *******************************************************************
!! FUNCTION tta0(betr)
!! Transit time factor t(k) (multi-cells)
!< *******************************************************************
       FUNCTION tta0(betr)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         tta0=0.
         do i=1,ncell
           tta0=tta0+ta0(betr,i)
         enddo
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tta0=0.
         ar=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             AR=AR+H(I)*RFONC*COS(XK*XC)
           enddo
           AR=AR*(XC2-XC1)
           TTA0=TTA0+AR
           AR=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       return
       end
!> *******************************************************************
!! FUNCTION ta1(betr,nrc)
!! Transit time factor dT(k)/dk (single cell)
!< *******************************************************************
       FUNCTION ta1(betr,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       ar=0.
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       do i=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         AR=AR-T1(I)*XC*RFONC*SIN(XK*XC)
       enddo
       ta1=ar*(xc2-xc1)
       return
       end
!> *******************************************************************
!! FUNCTION tta1(BETR)
!! Transit time factor dT(k)/dk (multi-cells)
!< *******************************************************************
       FUNCTION tta1(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))       
       if(ifield) then
         tta1=0.
         do i=1,ncell
           tta1=tta1+ta1(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tta1=0.
         ar=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             AR=AR-H(I)*XC*RFONC*SIN(XK*XC)
           enddo
           AR=AR*(XC2-XC1)
           TTA1=TTA1+AR
           AR=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION ta2(betr,nrc)
!! Transit time factor d2T(k)/dk2 (single cell)
!< *******************************************************************
       FUNCTION ta2(betr,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       ar=0.
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       do i=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         AR=AR-T1(I)*XC*XC*RFONC*COS(XK*XC)
       enddo
       TA2=AR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tta2(BETR)
!! Transit time factor d2T(k)/dk2 (multi-cells)
!< *******************************************************************
       FUNCTION tta2(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))       
       if(ifield) then
         tta2=0.
         do i=1,ncell
           tta2=tta2+ta2(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tta2=0.
         ar=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             AR=AR-H(I)*XC*XC*RFONC*COS(XK*XC)
           enddo
           AR=AR*(XC2-XC1)
           TTA2=TTA2+AR
           AR=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION ta3(betr,nrc)
!! Transit time factor d3T(k)/dk3 (single cell)
!< *******************************************************************
       FUNCTION ta3(betr,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       ar=0.
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       do i=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         AR=AR+T1(I)*XC*XC*XC*RFONC*SIN(XK*XC)
       enddo
       TA3=AR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tta3(BETR)
!! Transit time factor d3T(k)/dk2 (multi-cells)
!< *******************************************************************
       FUNCTION tta3(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))       
       if(ifield) then
         tta3=0.
         do i=1,ncell
           tta3=tta3+ta3(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tta3=0.
         ar=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             AR=AR+H(I)*XC*XC*XC*RFONC*SIN(XK*XC)
           enddo
           AR=AR*(XC2-XC1)
           TTA3=TTA3+AR
           AR=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION ta4(betr,nrc)
!! Transit time factor d4T(k)/dk4 (single cell)
!< *******************************************************************
       FUNCTION ta4(betr,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       ar=0.
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       do i=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         AR=AR+T1(I)*XC**4*RFONC*COS(XK*XC)
       enddo
       TA4=AR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tta4(BETR)
!! Transit time factor d4T(k)/dk4 (multi-cells)
!< *******************************************************************
       FUNCTION tta4(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))       
       if(ifield) then
         tta4=0.
         do i=1,ncell
           tta4=tta4+ta4(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tta4=0.
         ar=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             AR=AR+H(I)*XC**4*RFONC*COS(XK*XC)
           enddo
           AR=AR*(XC2-XC1)
           TTA4=TTA4+AR
           AR=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION ta5(betr,nrc)
!! Transit time factor d5T(k)/dk5 (single cell)
!< *******************************************************************
       FUNCTION ta5(betr,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       ar=0.
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       do i=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         AR=AR-T1(I)*XC**5*RFONC*SIN(XK*XC)
       enddo
       TA5=AR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tta5(BETR)
!! Transit time factor d5T(k)/dk5 (multi-cells)
!< *******************************************************************
       FUNCTION tta5(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))       
       if(ifield) then
         tta5=0.
         do i=1,ncell
           tta5=tta5+ta5(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tta5=0.
         ar=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             AR=AR-H(I)*XC**5*RFONC*SIN(XK*XC)
           enddo
           AR=AR*(XC2-XC1)
           TTA5=TTA5+AR
           AR=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION sb0(BETR,nrc)
!! Transit time factor s(k) (single cell)
!< *******************************************************************
       FUNCTION sb0(BETR,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       br=0.
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         BR=BR+T1(I)*RFONC*SIN(XK*XC)
       enddo
       SB0=BR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tsb0(BETR)
!! Transit time factor s(k) (multi-cells)
!< *******************************************************************
       FUNCTION tsb0(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         tsb0=0.
         do i=1,ncell
           tsb0=tsb0+sb0(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tsb0=0.
         br=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
               RFONC= FONE(XC)
             BR=BR+H(I)*RFONC*SIN(XK*XC)
           enddo
           BR=BR*(XC2-XC1)
           tsb0=tsb0+br
           br=0.
           IPAS=IPAS+1
         ENDDO   
       endif
       end
!> *******************************************************************
!! FUNCTION sb1(BETR,nrc)
!! Transit time factor dS(k)/dk (single cell)
!< *******************************************************************
       FUNCTION sb1(BETR,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       br=0.
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         BR=BR+T1(I)*XC*RFONC*COS(XK*XC)
       enddo
       SB1=BR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tsb1(BETR)
!! Transit time factor ds(k)/dk (multi-cells)
!< *******************************************************************
       FUNCTION tsb1(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         tsb1=0.
         do i=1,ncell
           tsb1=tsb1+sb1(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tsb1=0.
         br=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             BR=BR+H(I)*XC*RFONC*COS(XK*XC)
           enddo
           BR=BR*(XC2-XC1)
           tsb1=tsb1+br
           br=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION sb2(BETR,nrc)
!! Transit time factor d2S(k)/dk2 (single cell)
!< *******************************************************************
       FUNCTION sb2(BETR,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       br=0.
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         BR=BR-T1(I)*XC*XC*RFONC*SIN(XK*XC)
       enddo
       SB2=BR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tsb2(BETR)
!! Transit time factor d2S(k)/dk2 (multi-cells)
!< *******************************************************************
       FUNCTION tsb2(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         tsb2=0.
         do i=1,ncell
           tsb2=tsb2+sb2(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tsb2=0.
         br=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             BR=BR-H(I)*XC*XC*RFONC*SIN(XK*XC)
           enddo
           BR=BR*(XC2-XC1)
           tsb2=tsb2+br
           br=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION sb3(BETR,nrc)
!! Transit time factor d3S(k)/dk3 (single cell)
!< *******************************************************************
       FUNCTION sb3(BETR,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       br=0.
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         BR=BR-T1(I)*XC*XC*XC*RFONC*COS(XK*XC)
       enddo
       SB3=BR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tsb3(BETR)
!! Transit time factor d3S(k)/dk3 (multi-cells)
!< *******************************************************************
       FUNCTION tsb3(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         tsb3=0.
         do i=1,ncell
           tsb3=tsb3+sb3(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tsb3=0.
         br=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             BR=BR-H(I)*XC*XC*XC*RFONC*COS(XK*XC)
           enddo
           BR=BR*(XC2-XC1)
           tsb3=tsb3+br
           br=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION sb4(BETR,nrc)
!! Transit time factor d4S(k)/dk5 (single cell)
!< *******************************************************************
       FUNCTION sb4(BETR,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       br=0.
       do i=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         BR=BR+T1(I)*XC**4*RFONC*SIN(XK*XC)
       enddo
       SB4=BR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tsb4(BETR)
!! Transit time factor d4S(k)/dk5 (multi cells)
!< *******************************************************************
       FUNCTION tsb4(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         tsb4=0.
         do i=1,ncell
           tsb4=tsb4+sb4(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tsb4=0.
         br=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             BR=BR+H(I)*XC**4*RFONC*SIN(XK*XC)
           enddo
           BR=BR*(XC2-XC1)
           tsb4=tsb4+br
           br=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION sb5(BETR,nrc)
!! Transit time factor d5S(k)/dk5 (single cell)
!< *******************************************************************
       FUNCTION sb5(BETR,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       xk=fhc*2.*pi/(betr*vl)
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       br=0.
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         BR=BR+T1(I)*XC**5*RFONC*COS(XK*XC)
       enddo
       SB5=BR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION tsb5(BETR)
!! Transit time factor d5S(k)/dk5
!< *******************************************************************
       FUNCTION tsb5(BETR)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         tsb5=0.
         do i=1,ncell
           tsb5=tsb5+sb5(betr,i)
         enddo
         return
       else
         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         tsb5=0.
         br=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             BR=BR+H(I)*XC**5*RFONC*COS(XK*XC)
           enddo
           BR=BR*(XC2-XC1)
           tsb5=tsb5+br
           br=0.
           IPAS=IPAS+1
         ENDDO  
       endif
       end
!> *******************************************************************
!! FUNCTION fone(Z)
!! Electromagnetic field at the longitudinal point (z,0)
!! The field harmonics are  stored in  A(200)
!< *******************************************************************
       FUNCTION fone(Z)
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       FONE=0.
       DO J=1,NHARM
         XL=PI*float(J-1)/YLG
         FONE=FONE+A(J)*cos(XL*Z)
       enddo
       RETURN
       end
!> *******************************************************************
!! SUBROUTINE nrharm
!! the field is in the form of a Fourier series expansion
!< *******************************************************************
       SUBROUTINE nrharm
       implicit real(8) (a-h,o-z)
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/tapes/in,ifile,meta,ierr
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/rfield/ifield
!       common/mode/eflvl,rflvl
       common/paths/dpath
       character*(256) dpath,myfile  
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/cavnum1/xnh,xpas,ffield,npt
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell       
       common/kcell/avrg(15)
       common/files/mcselect,mc
       character mc*2
       LOGICAL mcselect
       logical ifield
       myfile=''
       ifield=.false.
!    ylg: length of the field (cm)
!    fh: frequency (hertz)
!    atte: field factor
!    ncel: number of cells in the cavity
       read(in,*) ylg,fh,atte,ncel
       read(in,*) nharm
       read(in,*) (a(i),i=1,nharm)
       write(16,100) ncel,ylg,fh,atte
100    format(' number of cells in the cavity: ',i3,/,
     *  ' field length: ',e12.5, 'cm',/,
     *  ' freq. ',e12.5,' Hertz',' field factor ',e12.5)
       write(16,*) ' number of harmonics: ',nharm
       write(16,200) (a(i),i=1,nharm)
200    format(3(2x,e12.5))
       do i=1,nharm
         a(i)=a(i)*atte
       enddo
       fh=fh*2.*pi
! **********************************************
!  sv 24/10/2015
       xp=ylg/100.
       myfile='chemtr.txt'
       lpath=LEN_TRIM(dpath)
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(18,file=myfile,status='unknown')
       zx=0.
       yh=0.
       DO
         do inh=1,nharm
          ff=fone(zx)
         enddo
         write(18,99) zx/100.,ff
99       format(3(2x,e12.5))
         zx=zx+xp
         if(zx.ge.ylg) EXIT
       ENDDO
       close(18)
! **********************************************
       return
       end       
!> *******************************************************************
!! SUBROUTINE rharm
!! the field is in the form of a Fourier series expansion
!< *******************************************************************
       SUBROUTINE rharm
       implicit real(8) (a-h,o-z)
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/tapes/in,ifile,meta,ierr
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/rfield/ifield
!       common/mode/eflvl,rflvl
       common/paths/dpath
       character*(256) dpath,myfile  
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/cavnum1/xnh,xpas,ffield,npt
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell       
       common/kcell/avrg(15)
       common/files/mcselect,mc
       character mc*2
       LOGICAL mcselect
       logical ifield,remove
       myfile=''
!       ifield=.false.
       ifield=.true.
!    ylg: length of the field (cm)
!    fh: frequency (hertz)
!    atte: field factor
!    ncel: number of cells in the cavity
       read(in,*) ylg,fhc,atte,ncel
       read(in,*) nharm
       read(in,*) (a(i),i=1,nharm)
       write(16,100) ncel,ylg,fhc,atte
100    format(' number of cells in the cavity: ',i3,/,
     *  ' field length: ',e12.5, 'cm',/,
     *  ' freq. ',e12.5,' Hertz',' field factor ',e12.5)
       write(16,*) ' number of harmonics: ',nharm
       write(16,200) (a(i),i=1,nharm)
200    format(3(2x,e12.5))
       do i=1,nharm
         a(i)=a(i)*atte
       enddo
!       fhc=fhc*2.*pi
       xp=ylg/400.
       part=1.
       myfile='chemtr.txt'
       if(mcselect) myfile='mc'//mc//'chemtr.txt' 
       lpath=LEN_TRIM(dpath)
       lfile=LEN_TRIM(myfile)
       myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
       myfile(1:lpath)=dpath(1:lpath)
       myfile=TRIM(myfile)
       open(18,file=myfile,status='unknown')
       zx=0.
       i=0
! reconstitute the field from the Fourier coefficients       
       DO
         do inh=1,nharm
          ff=fone(zx)
         enddo
         i=i+1
         write(18,99) zx/100.,ff
99       format(3(2x,e12.5))
         xspl(i)=zx
         yspl(i)=ff
         zx=zx+xp
         if(zx.ge.ylg) EXIT
       ENDDO
       close(18)
       npt=i
       call deriv2(npt)
       xpas=(xspl(3)-xspl(2))/part
       xcour=xspl(1)
       nfpt=1
       do i=1,10000
         if(xcour.gt.xspl(npt) ) exit
         yf(i)=spline(npt,xcour)
         xf(i)=xcour
         xcour=xcour+xpas
         nfpt=nfpt+1
       enddo
       nfpt=nfpt-1
       fmax=yf(1)
       fmin=yf(1)     
       do i=2,nfpt
         if(yf(i).gt.fmax) fmax=yf(i)
         if(yf(i).lt.fmin) fmin=yf(i)
       enddo
       xlimf=xspl(npt)
       xf(nfpt)=0.
!omment       yf(nfpt)=0.
! look for the number of cells,the limits of the cells, the number of coordinates in each cell
       do i=1,15
         npoint(i)=0
       enddo
       npoint(1)=1
       ncell=1
       xlim(ncell)=xf(1)
       cmin=yf(1)
       cmax=yf(1)
! frac is relative noise floor in the field distribution       
       frac=0.02
       ilast=1
       fprec=epsilon(xf(1))
       do i=2,nfpt
         if(yf(i).gt.cmax) cmax=yf(i)
         if(yf(i).lt.cmin) cmin=yf(i)
!         if (xf(i).eq.0.) then
         if (abs(xf(i)).le.fprec) then
           ncell=ncell+1
           xlim(ncell)=xlimf
           exit
         endif
         if(yf(i)*yf(i-1).lt.0.) then
           if(abs(cmax/fmax).gt.frac .or. abs(cmin/fmin).gt.frac)then
!            write(16,*)xf(i),cmax,fmax,cmin,fmin,cmax/fmax,cmin/fmin 
             ncell=ncell+1
             npoint(ncell)=npoint(ncell)+1
             xlim(ncell)=xf(i)
             ilast=i
             cmin=yf(1)
             cmax=yf(1)            
           else
             npoint(ncell)=npoint(ncell)+1
           endif
         else
           npoint(ncell)=npoint(ncell)+1
         endif
       enddo
       cmin=yf(1)
       cmax=yf(1)
       remove=.true.
       do i=ilast,nfpt
         if(abs(yf(i)/fmax).gt.frac .or. abs(yf(i)/fmin).gt.frac)then
           remove=.false.
         endif
       enddo       
       if(remove) then
         xlim(ncell-1)=xlim(ncell)
         npoint(ncell-2)=npoint(ncell-2)+npoint(ncell-1)+1       
         ncell=ncell-1
       endif
       flength=xlim(ncell)
       ncell=ncell-1
       att=atte
!       write(16,*) ' ******Read the field of the cavity************'
       write(16,300) ncell,flength,att,fhc
300    format(' Number of cells: ',i3,' field length: ',e12.5,'cm',
     *        ' field factor: ',e12.5,' frequency: ',e12.5,' Hz')
! ******************************************
!  sv 28/10/2015
       call celint
! *****************************************
       do i=1,ncell
         write(16,400) i,xlim(i),xlim(i+1),avrg(i)
       enddo
400    format(' Cell number ',i3,' lower limit ',e12.5,' cm ',
     *        ' upper limit ',e12.5,' cm ','average ',e12.5,' cm')
              
       return
       end
!> *******************************************************************
!! SUBROUTINE profil
!! Store header and envelopes in a binary file for
!! graphics post-processor
!< *******************************************************************
       SUBROUTINE profil
       implicit real(8) (a-h,o-z)
       COMMON/DPLT/ZDEB,ZFIN,YWMAX,YPMAX,RMSN
       common/tapes/in,ifile,meta,ierr
       CALL PLPRF1
       CALL PLPRF2
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE plprf1
!!     IPRF  : POINTEUR
!!     RMSN  :envelope size in multiples of RMS size
!!     SPRFX :half horizontal extent (cm)
!!     SPRFY :half vertical extent (cm)
!!     SPRFW :half energy extent (MeV)
!!     SPRFP :half phase extent    (deg)
!!     SPRFL :position along Z(m)
!< *******************************************************************
       SUBROUTINE plprf1
       implicit real(8) (a-h,o-z)
       dimension xx(6001),yy(6001)
!     RMSN  :envelope size in multiples of RMS size
!     ZDEB : Starting position of the plot
!     ZFIN : End of the plot
       CHARACTER CAR*80,text*80
       COMMON/DPLT/ZDEB,ZFIN,YWMAX,YPMAX,RMSN
       COMMON/PLTPRF/SPRFY(6001),SPRFZ(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       common/tapes/in,ifile,meta,ierr
       common/prof/car
       READ(IN,69)CAR(1:80)
69     FORMAT(A80)
       READ(IN,*) RMSN
       READ(IN,*) ZDEB,ZFIN
       READ(IN,*) XXMAX,XYMAX,YWMAX,YPMAX
       IPRF=IPRF-1
       IDEB=1
       IFIN=IPRF
       IF(ZFIN.GT.SPRFL(IPRF))ZFIN=SPRFL(IPRF)
       write(16,*) ' Envelope related parameters:'
       write(16,*) ' IPRF ZFIN ',iprf,zfin
       DO I=2,IPRF
         IF((ZDEB.GT.SPRFL(I-1)).AND.(ZDEB.LE.SPRFL(I)))IDEB=I
         IF((ZFIN.GE.SPRFL(I-1)).AND.(ZFIN.LT.SPRFL(I)))IFIN=I-1
       ENDDO
       if (xxmax.le.0.) then
         XXMAX=0.
         DO I=IDEB,IFIN
           IF(0.5*SPRFY(I)*RMSN .GT. XXMAX) XXMAX=0.5*SPRFY(I)*RMSN
         ENDDO
       endif
       if (xymax.le.0.) then
         XYMAX=0.
         DO I=IDEB,IFIN
           IF(0.5*SPRFZ(I)*RMSN.GT.XYMAX) XYMAX=0.5*SPRFZ(I)*RMSN
         ENDDO
       endif
! Store header and envelopes in binary file for
! graphics post-processor
!
! igrtyp is type of graph (igrtyp=3 for x,y envelope plots)
       igrtyp=3
       text='X and Y envelopes   '
       text(21:80)=car(1:60)
       WRITE(66,*) igrtyp
       WRITE(66,*) text
       xx(1)=zdeb
       xx(2)=zfin
       yy(1)=-xymax
       yy(2)=xxmax
       write(16,*) ' XMAX YMAX ',xxmax,xymax
       WRITE(66,*) xx(1),xx(2),yy(1),yy(2)
!       GRADX=XXMAX/3.
!       YFAXE=XXMAX
       icnt=0
       DO I=IDEB,IFIN
         icnt=icnt+1
         xx(icnt)=sprfl(i)
         yy(icnt)=0.5*sprfy(i)*RMSN
       ENDDO
! write envelope coordinates to graphics file
       WRITE(66,*) icnt
       DO I=1,icnt
         WRITE(66,*) xx(i),yy(i)
       ENDDO
       icnt=0
       DO I=IDEB,IFIN
         icnt=icnt+1
         xx(icnt)=sprfl(i)
         yy(icnt)=-0.5*sprfz(i)*RMSN
       ENDDO
! write envelope coordinates to graphics file
       WRITE(66,*) icnt
       DO I=1,icnt
         WRITE(66,*) xx(i),yy(i)
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE plprf2
!! Store header and envelopes in binary file for
!! graphics post-processor
!< *******************************************************************
       SUBROUTINE plprf2
       implicit real(8) (a-h,o-z)
       dimension xx(6001),yy(6001)
       CHARACTER CAR*80,text*80
       common/prof/car
       COMMON/DPLT/ZDEB,ZFIN,YWMAX,YPMAX,RMSN
       COMMON/PLTPRF/SPRFY(6001),SPRFZ(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       IDEB=1
       IFIN=IPRF
       DO I=2,IPRF
         IF((ZDEB.GT.SPRFL(I-1)).AND.(ZDEB.LE.SPRFL(I)))IDEB=I
         IF((ZFIN.GE.SPRFL(I-1)).AND.(ZFIN.LT.SPRFL(I)))IFIN=I-1
       ENDDO
       xxmax=ywmax/1000.
       xymax=ypmax
       if (xxmax.le.0.) then
         XXMAX=0.
         DO I=IDEB,IFIN
           IF(0.5*SPRFW(I)*RMSN.GT.XXMAX) XXMAX=0.5*SPRFW(I)*RMSN
         ENDDO
       endif
       if (xymax.le.0.) then
         XYMAX=0.
         DO I=IDEB,IFIN
           IF(0.5*SPRFP(I)*RMSN.GT.XYMAX) XYMAX=0.5*SPRFP(I)*RMSN
         ENDDO
       endif
! Store header and envelopes in binary file for
! graphics post-processor
!
! igrtyp is type of graph (igrtyp=4 for dW/W envelope plots)
       igrtyp=4
       text='dW/W envelope       '
       text(21:80)=car(1:60)
       WRITE(66,*) igrtyp
       WRITE(66,*) text
       xx(1)=zdeb
       xx(2)=zfin
       yy(1)=0.
       yy(2)=xxmax*1000.
       WRITE(66,*) xx(1),xx(2),yy(1),yy(2)
       icnt=0
       DO I=IDEB,IFIN
         icnt=icnt+1
         xx(icnt)=sprfl(i)
         yy(icnt)=0.5*sprfw(i)*1000.*RMSN
       ENDDO
! write envelope coordinates to graphics file
       WRITE(66,*) icnt
       DO I=1,icnt
         WRITE(66,*) xx(i),yy(i)
       ENDDO
! Store header and envelopes in binary file for
! graphics post-processor
!
! igrtyp is type of graph (igrtyp=5 for dPHI envelope plots)
       igrtyp=5
       text='dPHI envelope       '
       text(21:80)=car(1:60)
       WRITE(66,*) igrtyp
       WRITE(66,*) text
       xx(1)=zdeb
       xx(2)=zfin
       yy(1)=0.
       yy(2)=xymax
       write(16,*) ' dW/WMAX dPhiMAX ',xxmax,xymax
       WRITE(66,*) xx(1),xx(2),yy(1),yy(2)
       icnt=0
       DO I=IDEB,IFIN
         icnt=icnt+1
         xx(icnt)=sprfl(i)
         yy(icnt)=0.5*sprfp(i)*RMSN
       ENDDO
! write envelope coordinates to graphics file
       WRITE(66,*) icnt
       DO I=1,icnt
         WRITE(66,*) xx(i),yy(i)
       ENDDO
       IPRF=IPRF+1
       RETURN
       END
!> *******************************************************************
!! FUNCTION slope(N,XV)
!! first derivative of the spline function
!< *******************************************************************
       FUNCTION slope(N,XV)
       implicit real(8) (a-h,o-z)
       common/spl/x(4000),y(4000),s(3000),p(3000),q(3000)
       do i=2,n
         xtvi=xv-x(i)
         if(xtvi.le.0.) EXIT
       enddo
       if(xtvi.ge.0.) then
         I=I-1
         AVX=X(I+1)-X(I)
         SLOPE=S(I+1)*AVX/3.+S(I)*AVX/6.+(Y(I+1)-Y(I))/AVX
       else  
         I=I-1
         DGX=XV-X(I)
         DDX=X(I+1)-XV
         AVX=X(I+1)-X(I)
         SLOPE=-(S(I)*DDX*DDX)/(2.*AVX)+(S(I+1)*DGX*DGX)/(2.*AVX)
     *          +((Y(I+1)-Y(I))/AVX)-(AVX*(S(I+1)-S(I))/6.)
       endif
       return
       end
!> *******************************************************************
!! FUNCTION spline (N,XV)
!! SPLINE FUNCTION
!< *******************************************************************
       FUNCTION spline (N,XV)
       implicit real(8) (a-h,o-z)
       COMMON /SPL/X(4000),Y(4000),S(3000),P(3000),Q(3000)
       spline=y(1)
       xtv1=xv-x(1)
       fprec=epsilon(xtv1)
       if(xtv1.lt.0.) then
         SPLINE=Y(1)+((Y(2)-Y(1))/(X(2)-X(1))-S(2)*(X(2)-X(1))/6.)
     *          *(XV-X(1))
         return
       endif
!       if(xtv1.eq.0.0) then
       if(abs(xtv1).le.fprec) then
         SPLINE=Y(1)
         return
       endif
       if(xtv1.gt.0.) then
         xtvn=xv-x(n)
!         if(xtvn.eq.0.00) then
         if(abs(xtvn).le.fprec) then
           SPLINE=Y(N)
           return
         endif
         if(xtvn.gt.0.) then
           SPLINE=Y(N)+((Y(N)-Y(N-1))/
     *           (X(N)-X(N-1))+S(N-1)*(X(N)-X(N-1))/6.)*(XV-X(N))
           return
         endif
         if(xtvn.lt.0.) then
           do i=2,n
             xtvi=xv-x(i)
             if(xtvi.le.0.) EXIT
           enddo
           if(xtvi.ge.0.) then
             spline=y(i)
           else
             I=I-1
             DGX=XV-X(I)
             DDX=X(I+1)-XV
             AVX=X(I+1)-X(I)
             SPLINE=S(I)*DDX**3/(6.*AVX)+S(I+1)*DGX**3/(6.*AVX)
     *    +(Y(I+1)/AVX-S(I+1)*AVX/6.)*DGX+(Y(I)/AVX-S(I)*AVX/6.)*DDX
           endif
         endif
       endif
       return
       end
!> *******************************************************************
!! SUBROUTINE DERIV2(N)
!! second derivative of spline functions at position (x,y)
!< *******************************************************************
       SUBROUTINE DERIV2(N)
       implicit real(8) (a-h,o-z)
       common/spl/x(4000),y(4000),s(3000),p(3000),q(3000)
       AVXN=X(N)-X(N-1)
       AVVXN=X(N-1)-X(N-2)
       AVYN=Y(N)-Y(N-1)
       AVVYN=Y(N-1)-Y(N-2)
       F=AVXN-(AVVXN**2)/AVXN
       P(N-1)=1.
       Q(N-1)=0.
       fprec=epsilon(f)
!       if(f.ne.0.) then
       if(abs(f).gt.fprec) then
         P(N-1)=(-2.*AVXN-3.*AVVXN-AVVXN**2/AVXN)/F
         Q(N-1)=6.*(AVYN/AVXN-AVVYN/AVVXN)/F
       endif
       NM1=N-1
       DO J=2,NM1
         I=N-J
         AVX=X(I+1)-X(I)
         AVVX=X(I+2)-X(I+1)
         AVY=Y(I+1)-Y(I)
         AVVY=Y(I+2)-Y(I+1)
         D=2.*(AVX+AVVX)+AVVX*P(I+1)
         P(I)=-AVX/D
         Q(I)=(6.*(AVVY/AVVX-AVY/AVX)-AVVX*Q(I+1))/D
       ENDDO
       AVX1=X(2)-X(1)
       AVVX1=X(3)-X(2)
       G1=(AVVX1/AVX1)+1.-P(2)-(Q(2)/Q(1))
       G2=(AVVX1/(AVX1*P(1)))-(AVVX1/AVX1)-1.+P(2)
       S(1)=(Q(1)*G1)/(P(1)*G2)
       DO I=1,NM1
         S(I+1)=P(I)*S(I)+Q(I)
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE DERIF2(N)
!! second derivative of spline functions at position (x,y)
!< *******************************************************************
       SUBROUTINE DERIF2(N)
       implicit real(8) (a-h,o-z)
       common/spff/x(400),y(400),s(500),p(500),q(500)
       AVXN=X(N)-X(N-1)
       AVVXN=X(N-1)-X(N-2)
       AVYN=Y(N)-Y(N-1)
       AVVYN=Y(N-1)-Y(N-2)
       F=AVXN-(AVVXN**2)/AVXN
       P(N-1)=1.
       Q(N-1)=0.
       fprec=epsilon(f)
!       if(f.ne.0.) then
       if(abs(f).gt.fprec) then
         P(N-1)=(-2.*AVXN-3.*AVVXN-AVVXN**2/AVXN)/F
         Q(N-1)=6.*(AVYN/AVXN-AVVYN/AVVXN)/F
       endif
       NM1=N-1
       DO J=2,NM1
         I=N-J
         AVX=X(I+1)-X(I)
         AVVX=X(I+2)-X(I+1)
         AVY=Y(I+1)-Y(I)
         AVVY=Y(I+2)-Y(I+1)
         D=2.*(AVX+AVVX)+AVVX*P(I+1)
         P(I)=-AVX/D
         Q(I)=(6.*(AVVY/AVVX-AVY/AVX)-AVVX*Q(I+1))/D
       ENDDO
       AVX1=X(2)-X(1)
       AVVX1=X(3)-X(2)
       G1=(AVVX1/AVX1)+1.-P(2)-(Q(2)/Q(1))
       G2=(AVVX1/(AVX1*P(1)))-(AVVX1/AVX1)-1.+P(2)
       S(1)=(Q(1)*G1)/(P(1)*G2)
       DO I=1,NM1
         S(I+1)=P(I)*S(I)+Q(I)
       ENDDO
       RETURN
       END
!> *******************************************************************
!! FUNCTION splinf (N,XV)
!! SPLINE FUNCTION
!< *******************************************************************
       FUNCTION splinf (N,XV)
       implicit real(8) (a-h,o-z)
       COMMON /SPFF/X(400),Y(400),S(500),P(500),Q(500)
       splinf=y(1)
       xtv1=xv-x(1)
       fprec=epsilon(xtv1)
       if(xtv1.lt.0.) then
         SPLINF=Y(1)+((Y(2)-Y(1))/(X(2)-X(1))-S(2)*(X(2)-X(1))/6.)
     *          *(XV-X(1))
         return
       endif
!       if(xtv1.eq.0.00) then
       if(abs(xtv1).le.fprec) then
         SPLINF=Y(1)
         return
       endif
       if(xtv1.gt.0.) then
         xtvn=xv-x(n)
!         if(xtvn.eq.0.00) then
         if(abs(xtvn).le.fprec) then
           SPLINF=Y(N)
           return
         endif
         if(xtvn.gt.0.) then
           SPLINF=Y(N)+((Y(N)-Y(N-1))/
     *           (X(N)-X(N-1))+S(N-1)*(X(N)-X(N-1))/6.)*(XV-X(N))
           return
         endif
         if(xtvn.lt.0.) then
           do i=2,n
             xtvi=xv-x(i)
             if(xtvi.le.0.) EXIT
           enddo
           if(xtvi.ge.0.) then
             splinf=y(i)
           else 
             I=I-1
             DGX=XV-X(I)
             DDX=X(I+1)-XV
             AVX=X(I+1)-X(I)
             SPLINF=S(I)*DDX**3/(6.*AVX)+S(I+1)*DGX**3/(6.*AVX)
     *   +(Y(I+1)/AVX-S(I+1)*AVX/6.)*DGX+(Y(I)/AVX-S(I)*AVX/6.)*DDX
           endif
         endif
       endif
       return
       end
!> *******************************************************************
!! FUNCTION slopf(N,XV)
!! first derivative of the spline function
!< *******************************************************************
       FUNCTION slopf(N,XV)
       implicit real(8) (a-h,o-z)
       COMMON /SPFF/X(400),Y(400),S(500),P(500),Q(500)
       do i=2,n
         xtvi=xv-x(i)
         if(xtvi.le.0.) EXIT
       enddo
       if(xtvi.ge.0.) then
         I=I-1
         AVX=X(I+1)-X(I)
         SLOPF=S(I+1)*AVX/3.+S(I)*AVX/6.+(Y(I+1)-Y(I))/AVX
       else  
         I=I-1
         DGX=XV-X(I)
         DDX=X(I+1)-XV
         AVX=X(I+1)-X(I)
         SLOPF=-(S(I)*DDX*DDX)/(2.*AVX)+(S(I+1)*DGX*DGX)/(2.*AVX)
     *          +((Y(I+1)-Y(I))/AVX)-(AVX*(S(I+1)-S(I))/6.)
       endif
       return
       end
!> *******************************************************************
!! SUBROUTINE area(init)
!! selection of the regions in the space x/a, y/b and z/c. The values
!! a,b and c are the RMS of the bunch in the space x, y, and z
!! The particles lying in any one region are affected with the same
!! color.
!< *******************************************************************
       SUBROUTINE area(init)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/part/xc(iptsz),yc(iptsz),zc(iptsz)
       common/tapes/in,ifile,meta,ierr
       common/zones/frms(6),nzone
       dimension inzonn(6)
       if(init.eq.1) then
!  set to -1. the last column of the table f(10,iptsz)
         do i=1,ngood
           f(10,i)=-1.
         enddo
! read: ityp and nzone; the number of regions
!       ityp=0, the zones are defined in the 3-d space (x/a,y/b,z/c)
!       ityp=1, the zones are defined in the plane (x/a,y/b)
         read(in,*) ityp,nzone
         write(16,*)'Number of zones selected:',nzone
         if(nzone.gt.5) then
           write(16,*) 'Number of zones is greater than 5 ',nzone
           stop
         endif
! The regions are selected in the space x/xrms,y/yrms and z/zrms
! limits of the zones ; read the upper limits of the regions
         frms(1)=0.
         if(nzone.ne.0) then
           read(in,*) (frms(i), i=2,nzone)
           frms(nzone+1)=100.
           do i=1,nzone
             write(16,*) 'Zone: ',i,' lower limit: ',frms(i),
     *                 ' upper limit:',frms(i+1)
           enddo
         else
           read(in,*) frms(2)
         endif
       endif
       if(nzone.ge.2) then
         trmoy=0.
         do i=1,ngood
           trmoy=trmoy+f(6,i)
         enddo
         trmoy=trmoy/float(ngood)
         xbar=0.
         ybar=0.
         zbar=0.
         imaxx=0
!   Divide by 100. to convert from centimeters to meters
         do np=1,ngood
           gnp=f(7,np)/xmat
           vnp=vl*sqrt(1.-1./(gnp*gnp))
           zc(np)=(trmoy-f(6,np))*vnp
!   convert from mrad to rad
           f3=f(3,np)*1.e-03
           f5=f(5,np)*1.e-03
!   convert from cm   to m
           xc(np)=(f(2,np)+zc(np)*f3)/100.
           yc(np)=(f(4,np)+zc(np)*f5)/100.
           zc(np)=zc(np)/100.
! evaluate xbar , ybar , zbar
           xbar=xbar+xc(np)
           ybar=ybar+yc(np)
           zbar=zbar+zc(np)
         enddo
         eng=float(ngood)
         xbar=xbar/eng
         ybar=ybar/eng
         zbar=zbar/eng
         do np=1,ngood
           xc(np)=xc(np)-xbar
           yc(np)=yc(np)-ybar
           zc(np)=zc(np)-zbar
         enddo
!    evaluate the rms sizes
         xsqsum=0.
         ysqsum=0.
         zsqsum=0.
         do j=1,ngood
           xcj=xc(j)
           ycj=yc(j)
           zcj=zc(j)
           xsqsum=xsqsum+xcj*xcj
           ysqsum=ysqsum+ycj*ycj
           zsqsum=zsqsum+zcj*zcj
         enddo
         xrmsz=xsqsum/float(ngood)
         yrmsz=ysqsum/float(ngood)
         zrmsz=zsqsum/float(ngood)
         xrmsz=sqrt(xrmsz)
         yrmsz=sqrt(yrmsz)
         zrmsz=sqrt(zrmsz)
         fprec=epsilon(f(10,1))
!  select the particles in the regions and count them
         if(ityp.eq.0) then
!       ityp=0, the zones are defined in the 3-d space (x/a,y/b,z/c)
           do i=1,nzone
             inzonn(i)=0
             do j=1,ngood
               xcp=xc(j)/xrmsz
               ycp=yc(j)/yrmsz
               zcp=zc(j)/zrmsz
               rxyz=sqrt((xcp*xcp+ycp*ycp+zcp*zcp)/3.)
               if(rxyz.lt.frms(i+1).and.rxyz.ge.frms(i)) then
                 inzonn(i)=inzonn(i)+1
                 if(init.eq.1) f(10,j)=frms(i+1)
               endif
!               if(f(10,j).eq.100. .and. init.eq.1) f(10,j)=0.
               if(abs(f(10,j)-100.).le.fprec .and. init.eq.1) f(10,j)=0.
             enddo
             if(init.eq.1) then
               write(16,*) inzonn(i),' particles initially in zone ',i
             else
               write(16,*) inzonn(i),' particles in zone ',i
             endif
           enddo
         else
!       ityp=1, the zones are defined in the plane (x/a,y/b)
           do i=1,nzone
             inzonn(i)=0
             do j=1,ngood
               xcp=xc(j)/xrmsz
               ycp=yc(j)/yrmsz
               zcp=zc(j)/zrmsz
               rxyz=sqrt((xcp*xcp+ycp*ycp)/2.)
               if(rxyz.lt.frms(i+1).and.rxyz.ge.frms(i)) then
                 inzonn(i)=inzonn(i)+1
                 if(init.eq.1) f(10,j)=frms(i+1)
               endif
!               if(f(10,j).eq.100. .and. init.eq.1) f(10,j)=0.
               if(abs(f(10,j)-100.).le.fprec .and. init.eq.1) f(10,j)=0.
             enddo
             if(init.eq.1) then
               write(16,*) inzonn(i),' particles initially in zone ',i
             else
               write(16,*) inzonn(i),' particles in zone ',i
             endif
           enddo
         endif
       endif
       return
       end
!> *******************************************************************
!! subroutine histgrm
!! called by plotting routine grcomp(text,iskale)
!< *******************************************************************
       subroutine histgrm
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/vl,pi,xmat,rpel,qst
       common/tapes/in,ifile,meta,ierr
       common/dyn/tref,vref
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/part/xc(iptsz),yc(iptsz),zc(iptsz)
       common/hist/xpos(200),xn(200),ypos(200),yn(200),
     *             zpos(200),zn(200),ixt,iyt,izt
       common/hist1/xps(200),xpn(200),yps(200),ypn(200),
     *             zps(200),zpn(200),ixpt,iypt,izpt
       trmoy=0.
       wcg=0.
       xcg=0.
       xcg=0.
       ycg=0.
       fnstp=100.
       do i=1,ngood
         trmoy=trmoy+f(6,i)
         wcg=wcg+f(7,i)
         xcg=xcg+f(2,i)
         ycg=ycg+f(4,i)
       enddo
       trmoy=trmoy/float(ngood)
       wcg=wcg/float(ngood)
       xcg=xcg/float(ngood)
       ycg=ycg/float(ngood)
       zcg=trmoy*fh
!  Isochronism correction (in case the bunch is not erect)
       xb2x=0.
       xb2z=0.
       xbxz=0.
       imaxx=0
       do np=1,ngood
         gnp=f(7,np)/xmat
         vnp=vl*sqrt(1.-1./(gnp*gnp))
         zc(np)=(trmoy-f(6,np))*vnp/100.
         xc(np)=(f(2,np)-xcg)/100.
         xb2z=xb2z+zc(np)*zc(np)
         xb2x=xb2x+xc(np)*xc(np)
         xbxz=xbxz+zc(np)*xc(np)
         imaxx=imaxx+1
       enddo
       xb2z=xb2z/float(imaxx)
       xb2x=xb2x/float(imaxx)
       xbxz=xbxz/float(imaxx)
       apl=atan(-2.*xbxz/(xb2x-xb2z))/2.
! coordinates of the particles at the point of time position
       xbar=0.
       ybar=0.
       zbar=0.
       imaxx=0
!  Divide by 100. to convert from centimeters to meters
       do np=1,ngood
         gnp=f(7,np)/xmat
         vnp=vl*sqrt(1.-1./(gnp*gnp))
         znp=(trmoy-f(6,np))*vnp
         xnp=f(2,np)
         zc(np)=znp*cos(apl)+xnp*sin(apl)
         xnp=xnp*cos(apl)-znp*sin(apl)
!  convert from mrad to rad
         f3=f(3,np)*1.e-03
         f5=f(5,np)*1.e-03
!  convert from cm   to m
         xc(np)=(xnp+zc(np)*f3)/100.
         yc(np)=(f(4,np)+zc(np)*f5)/100.
         zc(np)=zc(np)/100.
! evaluate xbar , ybar , zbar
         xbar=xbar+xc(np)
         ybar=ybar+yc(np)
         zbar=zbar+zc(np)
       enddo
       eng=float(ngood)
       xbar=xbar/eng
       ybar=ybar/eng
       zbar=zbar/eng
       do np=1,ngood
         xc(np)=xc(np)-xbar
         yc(np)=yc(np)-ybar
         zc(np)=zc(np)-zbar
       enddo
!  evaluate the rms sizes
       xsqsum=0.
       ysqsum=0.
       zsqsum=0.
       do j=1,ngood
         xsqsum=xsqsum+xc(j)*xc(j)
         ysqsum=ysqsum+yc(j)*yc(j)
         zsqsum=zsqsum+zc(j)*zc(j)
       enddo
       xrmsz=xsqsum/float(ngood)
       yrmsz=ysqsum/float(ngood)
       zrmsz=zsqsum/float(ngood)
       xrmsz=sqrt(xrmsz)
       yrmsz=sqrt(yrmsz)
       zrmsz=sqrt(zrmsz)
! normalize the coordinates x, y and z
       do j=1,ngood
         xc(j)=xc(j)/xrmsz
         yc(j)=yc(j)/yrmsz
         zc(j)=zc(j)/zrmsz
       enddo
!   look for the limits of the cloud of particles in the plane (x/a, y/b, z/c)
!   these limits are assumed included within at most +/- 5 RMS
       fract=5.
       xinf=0.
       yinf=0.
       zinf=0.
!    lower limits
       do i=1,ngood
         if((abs(xc(i)).le.fract).and.(abs(yc(i)).le.fract).and.
     *       (abs(zc(i)).le.fract)) then
           if(xinf.gt.xc(i)) xinf=xc(i)
           if(yinf.gt.yc(i)) yinf=yc(i)
           if(zinf.gt.zc(i)) zinf=zc(i)
         endif
       enddo
!     upper limits
       xsup=xinf
       ysup=yinf
       zsup=zinf
       do i=1,ngood
         if((abs(xc(i)).le.fract).and.(abs(yc(i)).le.fract).and.
     *       (abs(zc(i)).le.fract)) then
           if(xsup.lt.xc(i)) xsup=xc(i)
           if(ysup.lt.yc(i)) ysup=yc(i)
           if(zsup.lt.zc(i)) zsup=zc(i)
         endif
       enddo
! maximal sizes in x, y, and z-directions
       pax=(xsup-xinf)
       pay=(ysup-yinf)
       paz=(zsup-zinf)
!  histogram in x-direction,the step (stepx) is: pax/50
       stepx=pax/fnstp
       do i=1,200
         xn(i)=0.
       enddo
       xtot=0.
       x0=xinf-stepx
       x1=x0+stepx
       j=1
!   xpos(j): position of the elementary cylinder j
!   xn(j)  : number of particles in the elementary cylinder j
!   xtot   : total number of particles in x-direction
       do
         if(x1.le.xsup+stepx) then
           do i=1,ngood
             if(xc(i).gt.x0.and.xc(i).le.x1) xn(j)=xn(j)+1.
           enddo
           xtot=xtot+xn(j)
           xpos(j)=x0+stepx/2.
           j=j+1
           sta=x1
           x1=x1+stepx
           x0=sta
         else
           exit
         endif
       enddo
!  normalize the number of particles in each step with regard to max.(xn(j))
       j=j-1
       ixt=j
       xnor=0.
       do i=1,j
         if(xnor.lt.xn(i)) xnor=xn(i)
       enddo
       do i=1,j
         xn(i)=xn(i)/xnor
       enddo
!   histogram in y-direction,the step (stepy) is: pay/50
       stepy=pay/fnstp
       do i=1,200
         yn(i)=0.
       enddo
       ytot=0.
       y0=yinf-stepy
       y1=y0+stepy
       j=1
!   ypos(j): position of the step j
!   yn(j)  : number of particles lying in the  j
!   ytot   : total number of particles in y-direction
       do
         if(y1.le.ysup+stepy) then
           do i=1,ngood
             if(yc(i).gt.y0.and.yc(i).le.y1) yn(j)=yn(j)+1.
           enddo
           ytot=ytot+yn(j)
           ypos(j)=y0+stepy/2.
           j=j+1
           sta=y1
           y1=y1+stepy
           y0=sta
         else
           exit
         endif
       enddo
       j=j-1
       iyt=j
       y0=yinf
!  normalize the number of particles in step with regard to max(yn(j))
       ynor=0.
       do i=1,j
         if(ynor.lt.yn(i)) ynor=yn(i)
       enddo
       do i=1,j
         yn(i)=yn(i)/ynor
       enddo
!  histogram in z-direction,the step (stepz) is: paz/50
       do i=1,200
         zn(i)=0.
       enddo
       stepz=paz/fnstp
       ztot=0.
       z0=zinf-stepz
       z1=z0+stepz
       j=1
!  of length :stepz and radius:ray
!   zpos(j): position of the step j
!   zn(j)  : number of particles in the step j
!   ztot   : total number of particles in z-direction
       do
         if(z1.le.zsup+2.*stepz) then
           do i=1,ngood
             if(zc(i).gt.z0.and.zc(i).le.z1)zn(j)=zn(j)+1.
           enddo
           ztot=ztot+zn(j)
           zpos(j)=z0+stepz/2.
           j=j+1
           sta=z1
           z1=z1+stepz
           z0=sta
         else
           exit
         endif
       enddo
       j=j-1
       izt=j
!*et*2011 added next line
       z0=zinf
!  normalize the number of particles in each step with regard to max(zn(j))
       znor=0.
       do i=1,j
         if(znor.lt.zn(i)) znor=zn(i)
       enddo
       do i=1,j
         zn(i)=zn(i)/znor
       enddo
!   look for the limits of xp, yp, zp
       xpinf=f(3,1)
       ypinf=f(5,1)
       zpinf=f(6,1)-trmoy
!    lower limits
       do i=1,ngood
         f3=f(3,i)
         f5=f(5,i)
         f6=f(6,i)-trmoy
         if(xpinf.gt.f3) xpinf=f3
         if(ypinf.gt.f5) ypinf=f5
         if(zpinf.gt.f6) zpinf=f6
       enddo
!     upper limits
       xpsup=xpinf
       ypsup=ypinf
       zpsup=zpinf
       do i=1,ngood
         f3=f(3,i)
         f5=f(5,i)
         f6=f(6,i)-trmoy
         if(xpsup.lt.f3) xpsup=f3
         if(ypsup.lt.f5) ypsup=f5
         if(zpsup.lt.f6) zpsup=f6
       enddo
! maximal sizes in xp, yp, and zp-directions
       paxp=(xpsup-xpinf)
       payp=(ypsup-ypinf)
       pazp=(zpsup-zpinf)
!  evaluate the rms sizes in xp, yp, zp
       xpsum=0.
       ypsum=0.
       zpsum=0.
       do i=1,ngood
         f3=f(3,i)
         f5=f(5,i)
         f6=f(6,i)-trmoy
         xpsum=xpsum+f3*f3
         ypsum=ypsum+f5*f5
         zpsum=zpsum+f6*f6
       enddo
       xpsum=xpsum/float(ngood)
       ypsum=ypsum/float(ngood)
       zpsum=zpsum/float(ngood)
       xpsum=sqrt(xpsum)
       ypsum=sqrt(ypsum)
       zpsum=sqrt(zpsum)
!  histogram in xp-direction,the step (stxp) is: paxp/50
       stpx=paxp/fnstp
       do i=1,200
         xpn(i)=0.
       enddo
       xp0=xpinf-stpx
       xp1=xp0+stpx
       j=1
!   xps(j): position of the step j
!   xpn(j): number of particles lying in the step j
       do
         if(xp1.le.xpsup+stpx) then
           do i=1,ngood
             if(f(3,i).gt.xp0.and.f(3,i).le.xp1) xpn(j)=xpn(j)+1.
           enddo
           xps(j)=xp0+stpx/2.
           j=j+1
           sta=xp1
           xp1=xp1+stpx
           xp0=sta
         else
           exit
         endif
       enddo
!   normalize the number of particles in each step with regard to max.(xpn(j))
       j=j-1
       ixpt=j
       xnor=0.
       do i=1,j
         if(xnor.lt.xpn(i)) xnor=xpn(i)
       enddo
       do i=1,j
         xpn(i)=xpn(i)/xnor
         xps(i)=xps(i)/xpsum
       enddo
!  histogram in yp-direction,the step (stpy) is: payp/50
       stpy=payp/fnstp
       do i=1,200
         ypn(i)=0.
       enddo
       yp0=ypinf-stpy
       yp1=yp0+stpy
       j=1
!   yps(j): position of the step j in mrd
!   ypn(j)  : number of particles lying in the  j
       do
         if(yp1.le.ypsup+stpy) then
           do i=1,ngood
             if(f(5,i).gt.yp0.and.f(5,i).le.yp1) ypn(j)=ypn(j)+1.
           enddo
           yps(j)=yp0+stpy/2.
           j=j+1
           sta=yp1
           yp1=yp1+stpy
           yp0=sta
         else
           exit
         endif
       enddo
       j=j-1
       iypt=j
       yp0=ypinf
!  normalize the number of particles in step with regard to max(ypn(j))
       ynor=0.
       do i=1,j
         if(ynor.lt.ypn(i)) ynor=ypn(i)
       enddo
       do i=1,j
         ypn(i)=ypn(i)/ynor
         yps(i)=yps(i)/ypsum
       enddo
!  histogram in zp-direction,the step (stpz) is: pazp/50
       do i=1,200
         zpn(i)=0.
       enddo
       stpz=pazp/fnstp
       zp0=zpinf-stpz
       zp1=zp0+stpz
       j=1
!  of length :stepz and radius:ray
!   zps(j): position of the step j (deg)
!   zpn(j)  : number of particles in the step j
       do
         if(zp1.le.zpsup+2.*stpz) then
           do i=1,ngood
             f6=f(6,i)-trmoy
             if(f6.gt.zp0.and.f6.le.zp1) zpn(j)=zpn(j)+1.
           enddo
           zps(j)=zp0+stpz/2.
           j=j+1
           sta=zp1
           zp1=zp1+stpz
           zp0=sta
         else
           exit
         endif
       enddo
!  normalize the number of particles in each step with regard to max(zn(j))
       j=j-1
       izpt=j
       zpnor=0.
       do i=1,j
         if(zpnor.lt.zpn(i)) zpnor=zpn(i)
       enddo
       do i=1,j
         zpn(i)=zpn(i)/zpnor
         zps(i)=zps(i)/zpsum
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE daves(beame)
!! Write the characteristics of the beam to the disk
!!
!!  ---- statistics (dE-dPHI)
!!    dav1(i,10) :  extension of phase  dPHI (deg)
!!    dav1(i,11) :  dispersion of energy dE (MeV)
!!    dav1(i,12) :  emittance (MeV*rad)
!!    dav1(i,23) :  correlation  between dE an dPHI
!!
!!  ---- statistics (x-xp)
!!
!!    dav1(i,13): x-extension (mm)
!!    dav1(i,14): xp-extension (mrad)
!!    dav1(i,15): correlation between x and xp
!!    dav1(i,16): Emittance(norm)  x-xp (mm*mrad)
!!    dav1(i,17): Emittance(non norm) x-xp (mm*mrad)
!!
!!  ---- statistics (y-yp)
!!     dav1(i,18): y-extension  (mm)
!!     dav1(i,19): yp-extension (mrad)
!!     dav1(i,20): correlation between y and yp
!!     dav1(i,21) : Emittance(norm) y-yp (mm*mrad)
!!     dav1(i,22) : Emittance(non norm) y-yp (mm*mrad)
!!
!< *******************************************************************
       SUBROUTINE daves(beame)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/SPEDA/DAVE,idave
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/cptemit/xltot(maxcell1),nbemit
       COMMON/PORO/IROT1,IROT2
       LOGICAL IROT1,IROT2
       COMMON/SECDR/ISEOR
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/qfkd/ityq
       common/shortl/davprt
       LOGICAL ISEOR,acpt
       LOGICAL DAVE,CHASIT,ICHAES,ITVOL,IMAMIN,ityq
       character davprt(maxcell1)*80
! dave end
!wdk   print*,'daves'    ! wdk
       WRITE(12,3334)
3334   FORMAT('*****************************************************')
! ********************************************************************
       write(12,*) ' Energies are in [MeV], phases in [deg]',
     * ' lengths in [mm] ,tof in [deg]'
       write(12,*) ' ** For lenses followed by :',
     * ' Cummulative length, element type, length '
!
       write(12,*) ' ** For emit followed by'
       write(12,*) ' * Line 1:',
     * ' Particle reference:  beta, energy, tof ',
     * '  COG: energy, tof, energy offset, tof offset'
       write(12,*) ' * Line 2:',
     * ' COG coordinates for x  xp  y  yp (mm and mrad)'
       write(12,*) ' * Line 3:',
     * ' alpha-x beta-x(mm/mrad) alpha-y beta-y(mm/mrad)',
     * ' alpha-z beta-z(ns/keV)'
       write(12,*) ' * Line 4:',
     * ' alpha-z beta-z(deg/keV) emit-z(non norm.,keV.deg) f(MHz)'
       write(12,*) ' * Line 5:',
     * ' dPHI(deg)  dW(keV)   r12   long. emittance',
     * '  (keV.ns) particles left'
       write(12,*) ' * Line 6:',
     * '   x(mm)    xp(mrad)  r12   hor.  emittance',
     * '  (norm & non norm, mm.mrad)'
       write(12,*) ' * Line 7:',
     * '   y(mm)    yp(mrad)  r12   vert. emittance',
     * '  (norm & non norm, mm.mrad)'
! ********************************************************************
       WRITE(12,3334)
       write(12,*) '            Simulation with ',imax,' particles'
       IF(ISEOR) THEN
        write(12,*) '            Second order transport matrix    '
       ELSE
        write(12,*) '            First order transport matrix    '
       ENDIF
       IF(ICHAES) THEN
         write(12,*) '            Beam intensity  ',beame,' mA'
         if(iscsp.eq.1) write(12,*)
     *   '            Space charge calculations with HERSC   '
         if(iscsp.eq.2) write(12,*)
     *   '            Space charge calculations with SCHERM  '
         if(iscsp.eq.3.or.iscsp.eq.4) write(12,*)
     *   '            Space charge calculations with SCHEFF  '
         if(int(sce10).eq.1) write(12,*)
     *   'Space charge calculated for all relevant elements,
     *    but not at drifts'
         if(int(sce10).eq.2) write(12,*)
     *   'Space charge calculated for accelerating elements only'
         if(int(sce10).eq.3) write(12,*)
     *   'Space charge calculated for all relevant elements'
       ENDIF
       if(itvol) write(12,*)
     *  ' TOF is operational in accelerating elements  '
       if(imamin) write(12,*)
     *  'Phase adjustments for accelerating elements active'
       WRITE(12,3334)
       ifirst=1
       iit6=0
       nemit=0
!   start (big loop)
       do i=1,idav
         if(davprt(i).ne."") write(12,'(A)') davprt(i)
         if(iitem(i) .eq. 1) then
!  cavity
         n=int(dav1(i,25)+.5)
         if(itvol.and.imamin) then
          write(12,1000) dav1(i,24),n,dav1(i,1),dav1(i,38),dav1(i,39)
1000     format(f9.2,' mm Cavity ',i3,' length ',f7.2,' mm',/,
     *   ' phase offset: before adjustement ',e12.5,' deg',
     *   ' after adjustement ',e14.7,' deg')
         else
          write(12,2789) dav1(i,24),n,dav1(i,1),dav1(i,38)
         endif
2789     format(f9.2,' mm Cavity ',i3,' length ',f7.2,' mm',
     *   ' phase offset: ',e12.5,' deg')
      endif
!
       if(iitem(i) .eq. 2) then
! quadrupole (magnetic)
         write(12,1010) dav1(i,4),dav1(i,1),dav1(i,7),dav1(i,2),
     *   dav1(i,3),dav1(i,5),dav1(i,6),dav1(i,36)
1010     format(f9.2,' mm  Quadrupole:  length = ',e12.5,' mm',
     *   '  aperture radius = ',e12.5,' mm',/,
     *   '   field = ',e13.5,' kG  K2 = ',e12.5,' cm-2 gradient = ',
     *   e13.5,' kG/cm',/,
     *   '   momentum = ',e12.5,' kG.cm  particles left  ',f8.0)
         write(12,*)
       endif
!
       if(iitem(i) .eq. 3) then
! emiprt
         write(12,305)
305      FORMAT('**********          beam (emit card)         ',
     *   '**********')
         nemit=nemit+1
!omment         write(13,556) nemit,xltot(nemit)/100.,dav1(i,12)*1000.,
!omment     *                 dav1(i,6),dav1(i,30)
!omment         write(14,557) nemit,xltot(nemit)/100.,dav1(i,16),dav1(i,21)
!omment556      format(2x,i3,3(3x,f8.3),3x,f6.0)
!omment557      format(2x,i3,3(3x,f8.3))
!   ****************************************
         write(12,1001) (dav1(i,j), j=3,9)
1001     format(2x,f7.5,4(1x,e14.7),2(2x,e12.5),' MeV-deg')
         write(12,2003) (dav1(i,j), j=31,34)
2003     format(4(2x,f7.3),' mm and mrad ')
! --- following lines describe Courant-Snyder parameters
         fh=dav1(i,40)
!     1)  alpz betz
!
!    1-a) emz: emittance (keV*deg) betz(deg/keV)  gamz(keV/deg)
         emz=dav1(i,12)*1000.*(180./pi)
         betz=0.
         if(emz.gt.1.e-10) betz=dav1(i,10)*dav1(i,10)/emz
         dez=dav1(i,11)*1000.
         gamz=0.
         if(emz.gt.1.e-10) gamz=dez*dez/emz
         alpz=0.
         if(betz*gamz.ge.1.) alpz=sqrt(betz*gamz-1.)
         if(dav1(i,23).gt.0.)alpz=-alpz
!
!   1-b) emzz: emittance dE-dphi (keV*ns) betzz(ns/keV) gamzz(keV/ns)
         emzz=1.e12*dav1(i,12)/fh
         dphizz=1.e09 * dav1(i,10)/fh *(pi/180.)
         betzz=0.
         if(emzz.gt.1.e-10) betzz=dphizz*dphizz/emzz
         gamzz=0.
         if(emzz.gt.1.e-10) gamzz=dez*dez/emzz
         alpzz=0.
         if(betzz*gamzz.ge.1.) alpzz=sqrt(betzz*gamzz-1.)
         if(dav1(i,23).gt.0.)alpzz=-alpzz
!
!    2)  alpx btx
!       betx(mm/mrad)  gamx (mrad/mm)
         betx=0.
         emx=dav1(i,17)
         if(emx.gt.1e-10) betx=dav1(i,13)*dav1(i,13)/emx
         gamx=0.
         if(emx.gt.1e-10) gamx=dav1(i,14)*dav1(i,14)/emx
         alpx=0.
         if(betx*gamx.ge.1.) alpx=sqrt(betx*gamx-1.)
         if(dav1(i,15).gt.0.)alpx=-alpx
!
!    3)  alpy bety
!       bety(mm/mrad)  gamy (mrad/mm)
         bety=0.
         emy=dav1(i,22)
         if(emy.gt.1e-10) bety=dav1(i,18)*dav1(i,18)/emy
         gamy=0.
         if(emy.gt.1e-10) gamy=dav1(i,19)*dav1(i,19)/emy
         alpy=0.
         if(bety*gamy.ge.1.) alpy=sqrt(bety*gamy-1.)
         if(dav1(i,20).gt.0.)alpy=-alpy
!
!    betzz: ns/keV
         write(12,3213) alpx,betx,alpy,bety,alpzz,betzz
3213     format(3(2x,e12.5,2x,e12.5),2x,e12.5)
!    emittance (keV*deg) betz(deg/keV)
         write(12,597)alpz,betz,emz,fh/(2.*pi*1.e6)
597      format(2x,f8.4,2x,e13.6,2x,e13.6,' keV.deg',2x,f8.3,' MHz')
         if (emzz.gt.1000.) then
! ns.MeV
          write(12,6332) dav1(i,10),dez,dav1(i,23),
     *     emzz/1000.,DAV1(I,30)
6332     format(2x,f7.3,1x,f10.2,2x,f8.4,3x,f8.3,' ns.MeV   ',
     *         f8.0,' particles left')
         else
! ns.keV
           write(12,1002) dav1(i,10),dez,dav1(i,23),
     *     emzz,DAV1(I,30)
1002     format(2x,e12.5,2x,f7.2,2x,f8.4,2x,f7.3,' ns.keV   ',
     *         f8.0,' particles left')
         endif
         write(12,1003) (dav1(i,j), j=13,22)
1003     format(2(2x,f7.3,3x,f8.3,2x,f8.4,2x,e12.5,' mm.mrad (norm)',
     *   2x,f7.3,' (non norm)',/))
         write(12,*)
       endif
       if(iitem(i) .eq. 4) then
! bending magnet
         write(12,1025) dav1(i,4),dav1(i,1),dav1(i,2),dav1(i,3)
1025     format(f9.2,' mm bending magnet: central trajectory: '
     * ,f8.2,' mm',/,
     *  '     bend angle: ',f7.3,' deg bending radius: ',e12.5,' mm')
         write(12,1029) dav1(i,16),dav1(i,14),dav1(i,15)
1029     format('     field: ',f7.3,' T  n: ',f8.3,
     *  ' beta: ',f8.3)
         write(12,1026) dav1(i,6),dav1(i,9),dav1(i,7),dav1(i,8),
     *                  dav1(i,5)
1026     format( '  *Entrance ',/,'     pole-face rotation:',
     *   f8.3,'  deg curvature: ',f8.3,' mm',/,
     *   '     fringe field corrections: K1 ',f8.3,' K2 ',f8.3,/,
     *   '     vertical half-aperture: ',f8.3,' mm')
         write(12,1027) dav1(i,10),dav1(i,13),dav1(i,11),dav1(i,12),
     *                  dav1(i,17)
1027     format( '   *Exit ',/,'     pole-face rotation  :',
     *   f8.3,' deg  curvature: ',f8.3,' mm',/,
     *   '      fringe field correction: K1 ',f7.3,' K2 ',f7.3,/,
     *   '      vertical half-aperture: ',f8.3,' mm')
         write(12,1028)dav1(i,37)
1028   format('  particles left  ',f8.0)
         write(12,*)
       endif
       if(iitem(i) .eq. 5) then
! solenoid
         write(12,5010) dav1(i,4),dav1(i,1),dav1(i,2),dav1(i,3),
     *     dav1(i,5),dav1(i,36)
5010     format(f9.2,' mm  Solenoid:  length = ',f8.3,' mm',
     *   '   field = ',e12.5,' kG  K = ',e12.5,' cm-1',/,
     *'      momentum = ',e12.5,' kG.cm   particles left ',f8.0)
         write(12,*)
       endif
       if(iitem(i) .eq. 6) then
! From adjust or from entre(not yet introduced) input beam reference
         write(12,303)
303      FORMAT('**********     INITIAL BEAM          **********')
         write(12,2003) (dav1(i,j), j=31,34)
!     1)  alpz betz
!
!    1-a) emz: emittance (keV*deg) betz(deg/keV)  gamz(keV/deg)
         emz=dav1(i,12)*1000.*(180./pi)
         betz=0.
         if(emz.gt.1.e-10) betz=dav1(i,10)*dav1(i,10)/emz
         dez=dav1(i,11)*1000.
         gamz=0.
         if(emz.gt.1.e-10) gamz=dez*dez/emz
         alpz=0.
         if(betz*gamz.ge.1.) alpz=sqrt(betz*gamz-1.)
!
!   1-b) emzz: emittance dE-dphi (keV*ns) betzz(ns/keV) gamzz(keV/ns)
         emzz=1.e12*dav1(i,12)/fhinit
         dphizz=1.e09 * dav1(i,10)/fhinit *(pi/180.)
         betzz=0.
         if(emzz.gt.1.e-10) betzz=dphizz*dphizz/emzz
         gamzz=0.
         if(emzz.gt.1.e-10) gamzz=dez*dez/emzz
         alpzz=0.
         if(betzz*gamzz.ge.1.) alpzz=sqrt(betzz*gamzz-1.)
!
!    2)  alpx btx
!       betx(mm/mrad)  gamx (mrad/mm)
         betx=0.
         emx=dav1(i,17)
         if(emx.gt.1e-10) betx=dav1(i,13)*dav1(i,13)/emx
         gamx=0.
         if(emx.gt.1e-10) gamx=dav1(i,14)*dav1(i,14)/emx
         alpx=0.
         if(betx*gamx.ge.1.) alpx=sqrt(betx*gamx-1.)
!
!    3)  alpy bety
!       bety(mm/mrad)  gamy (mrad/mm)
         bety=0.
         emy=dav1(i,22)
         if(emy.gt.1e-10) bety=dav1(i,18)*dav1(i,18)/emy
         gamy=0.
         if(emy.gt.1e-10) gamy=dav1(i,19)*dav1(i,19)/emy
         alpy=0.
         if(bety*gamy.ge.1.) alpy=sqrt(bety*gamy-1.)
!
!    betzz: ns/keV
         write(12,3213) alpx,betx,alpy,bety,alpzz,betzz
         fh=dav1(i,40)
!    emittance (keV*deg) betz(deg/keV)
         write(12,597)alpz,betz,emz,fh/(2.*pi*1.e6)
         if (emzz.gt.1000.) then
! ns.MeV
          write(12,6332) dav1(i,10),dez,dav1(i,23),
     *     emzz/1000.,DAV1(I,30)
         else
! ns.keV
           write(12,1002) dav1(i,10),dez,dav1(i,23),
     *     emzz,DAV1(I,30)
         endif
         write(12,1003) (dav1(i,j), j=13,22)
         iit6=1
       endif
       if(iitem(i) .eq. 7) then
! drift
         write(12,7010) dav1(i,4),dav1(i,1),dav1(i,36)
7010     format(f9.2,' mm  Drift:  length ',f10.3,' mm ',/,
     *   '   particles left  ',f8.0)
         write(12,*)
       endif
       if(iitem(i) .eq. 8) then
! buncher
       if(.not.imamin)
     * write(12,8010) dav1(i,4),dav1(i,1),dav1(i,2),dav1(i,3),
     *                dav1(i,36)
8010     format(f9.2,' mm  Buncher ',f9.3,' MV ',
     *   '  RF Phase ',f9.3,' deg  Aperture radius',f5.1,' cm',/,
     *   '   particles left  ',f8.0)
       if(imamin)
     * write(12,8110) dav1(i,4),dav1(i,1),dav1(i,2),dav1(i,5),
     *                dav1(i,3),dav1(i,36)
8110     format(f9.2,' mm  Buncher ',f9.3,' MV ',
     *   '  RF Phase ',f9.3,' deg correction ',f9.3,' deg',
     *   '  Aperture radius',f5.1,' cm',/,
     *   '   particles left  ',f8.0)
         write(12,*)
       endif
       if(iitem(i) .eq. 9) then
! steerer
         if (int(dav1(i,2)).eq.0) then
           write(12,8020) dav1(i,3),dav1(i,1)
8020       format(f9.2,' mm  Hor. Mag. Steerer ',E12.5,' Tm ')
         else if (int(dav1(i,2)).eq.1) then
           write(12,8021) dav1(i,3),dav1(i,1)
8021       format(f9.2,' mm  Ver. Mag. Steerer ',f12.5,' Tm ')
         else if (int(dav1(i,2)).eq.2) then
           write(12,8022) dav1(i,3),dav1(i,1)
8022       format(f9.2,' mm  Hor. El. Steerer ',E12.5,' kVm/m ')
         else if (int(dav1(i,2)).eq.3) then
           write(12,8023) dav1(i,3),dav1(i,1)
8023       format(f9.2,' mm  Ver. El. Steerer ',E12.5,' kVm/m ')
         endif
         write(12,*)
       endif
       if(iitem(i) .eq. 10) then
!  sextupole
         write(12,1011) dav1(i,4),dav1(i,1),dav1(i,6),dav1(i,3),
     *                  dav1(i,5),dav1(i,2),
     *                  dav1(i,7),dav1(i,36)
1011     format(f9.2,' mm  Sextupole:  length = ',f7.3,' mm',
     *       '  aperture radius = ',e12.5,' cm',/,
     *       '   field = ',e12.5,' kG  KS2 = ',e12.5,' cm-3',
     *       '   gradient = ',e12.5,' kG/cm2',/,
     *       '   momentum = ',e12.5,' kG.cm   particles left  ',f8.0)
         write(12,*)
       endif
       if(iitem(i) .eq. 11) then
! solenoid+quadrupole
         write(12,5011) dav1(i,4),dav1(i,1),dav1(i,7),dav1(i,2),
     *   dav1(i,6),dav1(i,3),dav1(i,5),dav1(i,8),dav1(i,36)
5011     format(f9.2,' mm Sol+Quad: length = ',f7.3,
     *   ' mm aperture radius= ',e12.5,' mm',/,
     *   ' Solenoid: field = ',e12.5,' kG  K = ',e12.5,' cm-1',/,
     *   ' Quadrupole: field ',e12.5,' kG  K2 = ',e12.5,' cm-2',/,
     *   ' momentum = ',e12.5,' kG.cm   particles left ',f8.0)
         write(12,*)
       endif
       if(iitem(i) .eq. 12) then
! quadrupole + sextupole
         write(12,5021) dav1(i,4),dav1(i,1),dav1(i,6),dav1(i,2),
     *   dav1(i,3),dav1(i,7),dav1(i,8),dav1(i,10),dav1(i,36)
5021     format(f9.2,' mm  Quad+Sext: length = ',e12.5,' mm ',
     *   ' aperture radius = ',e12.5,' mm',/,
     *   '  Quadrupole: B = ',e12.5,' kG  K2 = ',e12.5,' cm-2',/,
     *   '  Sextupole:  B = ',e12.5,' kG  K2 = ',e12.5, ' cm-3',/,
     *   ' momentum = ',e12.5,' kG.cm   particles left ',f8.0)
         write(12,*)
       endif
       if(iitem(i) .eq. 13) then
! electron gun
         write(12,5031) dav1(i,4),dav1(i,1),dav1(i,2),dav1(i,3),
     *   dav1(i,6),dav1(i,36)
5031     format(f9.2,' mm  DC egun  length:',f7.3,' mm',/,
     *   ' Crest field:',f8.3,' MV/m',3x,
     *   ' field integral:',f8.3,' kV',/,
     *   ' beta ( output):',e12.5,' particles left ',f8.0)
! 14/01/2010         write(12,5032) dav1(i,5),dav1(i,7)
! 14/10/2010 5032     format(' beam (emit card) at ',e12.5,
! 14/10/2010     *          ' mm from the cathode, field (MV/m) ',e12.5)
         write(12,*)
       endif
! rfqcl (RFQ cell)
       if(iitem(i) .eq. 14) then
         ncell=int(dav1(i,7))
         write(12,5041) dav1(i,4),ncell,dav1(i,1),dav1(i,2),
     *   dav1(i,3),dav1(i,5),dav1(i,6),dav1(i,36)
5041     format(f9.2,' mm rfq cell:',i5,' length: ',f7.3,' mm',/,
     *   '  V/r02: ',e12.5,' kV/mm**2  AV:',e12.5,' kV ',
     *   '  type: ',f3.0,/,
     *   '  energy(output): ',e12.5,' MeV ','  particles left ',f8.0)
         write(12,*)
       endif
! rfqptq (RFQ)
       if(iitem(i) .eq. 15) then
         ncell=int(dav1(i,7))
         write(12,5042) dav1(i,4),ncell,dav1(i,5),dav1(i,9),
     *   dav1(i,8),dav1(i,6),dav1(i,36)
5042     format(f9.2,' mm rfq: number of cells:',i5,
     *    ' total length: ',e12.5,' mm',/,
     *   '  intervane voltage (reference): ',e12.5,' kV',/,
     *   '  intervane voltage (bunch): ',e12.5,' kV',/,
     *   '  energy (output): ',e12.5,' MeV',/,
     *   '  particles left ',f8.0)
         write(12,*)
      endif
! stipper foils
       if(iitem(i) .eq. 16) then
        write(12,5043) dav1(i,4),dav1(i,1),dav1(i,2),dav1(i,3),
     *                 dav1(i,5),dav1(i,6),dav1(i,36)
5043    format(f9.2,' mm stripper: atomic number: ',f4.0,
     *     '   atomic mass : ',f4.0,'  thickness :',e12.5,
     *     ' g/cm**2',/,4x,'particles charge : ',
     *     f4.0,2x,'energy loss: ',e12.5,' MeV',/,
     *        '    particles left ',f8.0)
         write(12,*)
       endif
! accelerating gap
       if(iitem(i) .eq. 17) then
         n=int(dav1(i,25)+.5)
! 16/12/09         if(itvol.and.imamin) then
! 16/12/09          write(12,1009) dav1(i,24),n,dav1(i,1),dav1(i,2),
! 16/12/09     *                   dav1(i,38),dav1(i,39)
! 16/12/09 1009     format(f9.2,' mm Ac. gap ',i3,' length ',f7.2,
! 16/12/09     *                 'mm field ',e12.5,' kV/mm',/,
! 16/12/09     *   '    phase offset adjusted with TOF',/,
! 16/12/09     *   '    before adjustement ',e12.5,' deg',
! 16/12/09     *   ' after adjustement ',e14.7,' deg')
! 16/12/09         else
          write(12,1008) dav1(i,24),n,dav1(i,1),dav1(i,2),dav1(i,38)
! 16/12/09         endif
1008     format(f9.2,' mm Ac. gap ',i3,' length ',f7.2,' mm field ',
     *   e12.5,' kV/mm  phase of RF (middle): ',e12.5,' deg')
         write(12,*)
       endif
! QUAELEC electric quadrupole
       if(iitem(i) .eq. 18) then
         write(12,2010) dav1(i,4),dav1(i,1),dav1(i,7), dav1(i,2),
     *   dav1(i,6),dav1(i,5),dav1(i,3),dav1(i,36)
2010     format(f9.2,' mm  Quadrupole (electric): length = '
     *   ,e12.5,' mm aperture radius = ',e12.5,' mm',/,
     *   '  voltage = ',f8.3,' kV  K2 = ',e12.5,' cm-2  gradient = ',
     *   e12.5,' kV/(cm*cm) ',/,
     *   '  rigidity = ',e12.5,' kV  particles left  ',f8.0)
         write(12,*)
       endif
!  QUAFK  quadrupole(magnetic or electric)
       if(iitem(i) .eq. 19) then
!  electric quadrupole
        if(ityq) then
         write(12,2110) dav1(i,4),dav1(i,1),dav1(i,7),
     *   dav1(i,2),dav1(i,6),dav1(i,5),dav1(i,3),dav1(i,36)
2110    format(f9.2,' mm  Quadrupole (electric): length = '
     *  ,e12.5,' mm   aperture radius = ',e12.5,' mm',/,' voltage = '
     *  ,e12.5,' kV   K2 = ',e12.5,' cm-2  gradient = ',e12.5,
     * ' kV/cm2',/,' rigidity = ',e12.5,' kV   particles left  ',f8.0)
        else
!  magnetic quadrupole
         write(12,2111) dav1(i,4),dav1(i,1),dav1(i,7),dav1(i,2),
     *   dav1(i,6),dav1(i,5),dav1(i,3),dav1(i,36)
2111     format(f9.2,' mm  Quadrupole (magnetic): length = '
     *  ,e12.5,' mm  aperture radius= ',e12.5,' mm',/,' field = ',e12.5,
     *  ' kG   K2 = ',e12.5,' cm-2  gradient = ',e12.5,' kG/cm',/,
     *  ' momentum = ',e12.5,' kG.cm   particles left  ',f8.0)
       endif
       write(12,*)
      endif
       if(iitem(i) .eq. 20) then
!  rotating the transverse coordinates about the z axis
        write(12,2112) dav1(i,1)
2112    format(9x,'rotating the transverse coordinates',
     *       ' about the z-axis by an angle: ',e12.5,' deg')
       write(12,*)
      endif
! EDFLEC electric deflector
       if(iitem(i) .eq. 21) then
         write(12,3010) dav1(i,4),dav1(i,1),dav1(i,2), dav1(i,3),
     *   dav1(i,5),dav1(i,6),dav1(i,7),dav1(i,8),dav1(i,36)
3010     format(f9.2,' mm  Deflector (electric): length = '
     *   ,e12.5,' mm bend angle = ',e12.5,' deg',/,
     *   '  bend radius = ',e12.5,' mm  radii = ',e12.5,
     *   '  field index = ',e12.5,/,
     *   '  rigidity = ',e12.5,' kV field = ',e12.5,' kV/mm',
     *   '  particles left  ',f8.0)
         write(12,*)
       endif
!   end (big loop)
      enddo
      return
      end
!> *******************************************************************
!! SUBROUTINE POFAR1(GAP)
!!   ENTRANCE OR EXIT OF THE BENDING MAGNET,
!!   MATRIX R AND T ARE IN (M,RD)
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!< *******************************************************************
      SUBROUTINE POFAR1(GAP)
      implicit real(8)(A-Z)
!      -- POLE FACE ROTATION
      COMMON /BLOC21/ BE, APB(2), LAYL, LAYX, RABT
      COMMON /BLOC23/ H, DEVI, NB, BDB,L
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      COMMON/SECDR/ISEOR
      LOGICAL ISEOR
!      H      : INVERSE OF THE MAGNET RADIUS (1./CM)
!      NB     : DIMENSIONLESS TRANSPORT n coefficient
!      BDB    : TRANSPORT beta coefficient
!      APB( ) : HALF GAP (CM)
!      L      : LENGTH OF THE MAGNET (CM)
!      BE     : ANGLE OF INLINATION (RAD)
!      LAYL   : K1 TRANSPORT COEFFICIENT
!      LAYX   : K2 TRANSPORT COEFFICIENT
!      RABT   : INVERSE OF THE RADIUS OF CURVATURE (1/CM)
!
!     SAVE H, GAP AND RABT BEFORE CONVERSION IN M UNITS
      SAH=H
      SARABT=RABT
      SAGAP=GAP
      H=H*100.
      GAP=GAP*1.E-02
      RABT=RABT*100.
      TB = TAN(BE)
      CB = COS(BE)
      SB = (1.0 + SIN(BE)**2)/CB
      TCOR = 2.0*H*GAP*LAYL
      BE1 = BE -TCOR* SB* (  1. -LAYX*TCOR * TB )
      TB1  =  TAN(BE1)
      TB2 = TB**2
      R(2,1) = H*TB
      R(4,3) = - H*TB1
      IF(ISEOR) THEN
        SB=1./CB
        SB2 = SB**2
        SB3 = SB2*  SB
        T(1,1,1)=- 0.5*H*TB2
        T(1,3,3)=0.5*H*SB2
        T(2,1,1)=0.5*H*RABT*SB3- TB*NB*H**2
        T(2,1,2)=H*TB2
        T(2,1,6)=-H*TB
        T(2,3,3)=H**2*(NB+0.5+TB2)*TB-0.5*H*RABT*SB3
        T(2,3,4)=-H*TB2
        T(3,1,3)=H*TB2
        T(4,1,3)=-H*RABT*SB3+2.*H**2*NB*TB
        T(4,1,4)=-H*TB2
        T(4,2,3)=-H*SB2
        SEC2=COS(BE1)*COS(BE1)
        SEC2=1./SEC2
        T(4,3,6)=H*TB-H*TCOR*SEC2
      ENDIF
!     RESTORE H , RABT, APB(2)
      H=SAH
      RABT=SARABT
      GAP=SAGAP
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE POFAR2(GAP)
!!     FIRST AND SECOND order MATRIX R AND T
!!     SAVE H, GAP AND RABT BEFORE CONVERSION IN M UNITY
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!< *******************************************************************
      SUBROUTINE POFAR2(GAP)
      implicit real(8)(A-Z)
!      -- POLE FACE ROTATION
      COMMON /BLOC21/ BE, APB(2), LAYL, LAYX, RABT
      COMMON /BLOC23/ H, DEVI, NB, BDB,L
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      COMMON/SECDR/ISEOR
      LOGICAL ISEOR
!      H      : INVERSE OF THE MAGNET RADIUS (1./CM)
!      NB     : DIMENSIONLESS TRANSPORT n coefficient
!      BDB    : TRANSPORT beta coefficient
!      APB( ) : HALF GAP (CM)
!      L      : LENGTH OF THE MAGNET (CM)
!      BE     : ANGLE OF INLINATION (RAD)
!      LAYL   : K1 TRANSPORT COEFFICIENT
!      LAYX   : K2 TRANSPORT COEFFICIENT
!      RABT   : INVERSE OF THE RADIUS OF CURVATURE (1/CM)
!
      SAH=H
      SARABT=RABT
      SAGAP=GAP
      H=H*100.
      GAP=GAP*1.E-02
      RABT=RABT*100.
      TB = TAN(BE)
      CB = COS(BE)
      SB = (1.0 + SIN(BE)**2)/CB
      TCOR = 2.0*H*GAP*LAYL
      BE1 = BE -TCOR* SB* (  1. -LAYX*TCOR * TB )
      TB1  =  TAN(BE1)
      TB2 = TB**2
      R(2,1) = H*TB
      R(4,3) = - H*TB1
      IF(ISEOR) THEN
        SB=1./CB
        SB2 = SB**2
        SB3 = SB2*  SB
        T(1,1,1)=0.5*H*TB2
        T(1,3,3)=-0.5*H*SB2
        T(2,1,1)=0.5*H*RABT*SB3- TB*(NB+0.5*TB2)*H**2
        T(2,1,2)=-H*TB2
        T(2,1,6)=-H*TB
        T(2,3,3)=H**2*(NB-0.5*TB2)*TB-0.5*H*RABT*SB3
        T(2,3,4)=H*TB2
        T(3,1,3)=-H*TB2
        T(4,1,3)=-H*RABT*SB3+H**2*(2.*NB+SB2)*TB
        T(4,1,4)=H*TB2
        T(4,2,3)=H*SB2
        SEC2=COS(BE1)*COS(BE1)
        SEC2=1./SEC2
        T(4,3,6)=H*TB-H*TCOR*SEC2
      ENDIF
!     RESTORE H , RABT, APB(2)
      H=SAH
      RABT=SARABT
      GAP=SAGAP
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE BENMAG(sbet,fdtot)
!!     IDEAL MAGNET, MATRIX R AND T ARE IN (M,RD)
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!< *******************************************************************
      SUBROUTINE BENMAG(sbet,fdtot)
      implicit real(8)(A-Z)
!      -- POLE FACE ROTATION
      COMMON /BLOC21/ BE, APB(2), LAYL, LAYX, RABT
      COMMON /BLOC23/ H, DEVI, NB, BDB,L
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      COMMON/SECDR/ISEOR
      LOGICAL ISEOR
!      H      : INVERSE OF THE MAGNET RADIUS (1./CM)
!      NB     : DIMENSIONLESS TRANSPORT n coefficient
!      BDB    : TRANSPORT beta coefficient
!      APB( ) : HALF GAP (CM)
!      L      : LENGTH OF THE MAGNET (CM)
!      BE     : ANGLE OF INLINATION (RAD)
!      LAYL   : K1 TRANSPORT COEFFICIENT
!      LAYX   : K2 TRANSPORT COEFFICIENT
!      RABT   : INVERSE OF THE RADIUS OF CURVATURE (1/CM)
!
! sbet is relativistic beta of the charge state of interest
      sgam2=1./(1.-sbet*sbet)
!     SAVE H BEFORE CONVERSION IN m
      SAH=H
      H=H*100.
      FIELDN=NB
      BETA=BDB
      AL=L*1.E-02
      RAD=1.0/H
      H2=H*H
      H3=H2*H
      H4=H3*H
      H5=H4*H
      H6=H5*H
      KX2=(1.0-FIELDN)*H2
      fprec=epsilon(KX2)
      KY2=FIELDN*H2
      KX=SQRT(ABS(KX2))
      KY=SQRT(ABS(KY2))
      KX3=KX2*KX
      ARGX=KX*AL
      ARGY=KY*AL
      SINX=SIN(ARGX)
      SHX=SINH(ARGX)
      AL2=AL*AL
      AL3=AL2*AL
      CX=0.
      SX=0.
      DX=0.
      J1XL=0.
      IF (kx2.lt.6.*0) then
       CX=COSH(ARGX)
       SX=SINH(ARGX)/KX
       DX=H*(1.0-CX)/KX2
       J1XL=(ARGX-SHX)/KX3
      ENDIF
!      IF (KX2.EQ.6.*0) THEN
      IF (abs(KX2).LE.fprec) THEN
       CX=1
       SX=AL
       DX=H*AL2/2.0
       J1XL=AL3/6.0
      ENDIF
      IF (KX2.GT.6.*0) THEN
       CX=COS(ARGX)
       SX=SIN(ARGX)/KX
       DX=H*(1.0-CX)/KX2
       J1XL=(ARGX-SINX)/KX3
      ENDIF
      CPX=-KX2*SX
      SPX=CX
      DPX=H*SX
      CY=0.
      SY=0.
      IF(KY2.LT.6.*0) THEN
       CY=COSH(ARGY)
       SY=SINH(ARGY)/KY
      ENDIF
!      IF(KY2.EQ.6.*0) THEN
      IF(abs(KY2).LE.fprec) THEN
       CY=1.0
       SY=AL
      ENDIF
      IF(KY2.GT.6.*0) THEN
       CY=COS(ARGY)
       SY=SIN(ARGY)/KY
      ENDIF
      CPY=-KY2*SY
      SPY=CY
!    First order Matrix R
      R(1,1)=CX
      R(1,2)=SX
      R(1,6)=DX
      R(2,1)=CPX
      R(2,2)=SPX
      R(2,6)=DPX
      R(3,3)=CY
      R(3,4)=SY
      R(4,3)=CPY
      R(4,4)=SPY
      R(5,1)=H*SX
      R(5,2)=DX
      R(5,6)=H2*J1XL
!  Carey eq.2.41 p 34
      R(5,6)=R(5,6)-AL*fdtot/sgam2
! ************************
      IF(ISEOR) THEN
!   Second order Matrix T
        COSX=COS(ARGX)
        CHX=COSH(ARGX)
        KX4=KX2*KX2
        KX6=KX4*KX2
        ARGY=KY*AL
        SINY=SIN(ARGY)
        COSY=COS(ARGY)
        SHY=SINH(ARGY)
        CHY=COSH(ARGY)
        KY3=KY2*KY
        KY4=KY2*KY2
        TARGX=ARGX+ARGX
        SIN2X=SIN(TARGX)
        COS2X=COS(TARGX)
        SH2X=SINH(TARGX)
        CH2X=COSH(TARGX)
        KX3=KX*KX2
        KX5=KX3*KX2
        KX7=KX5*KX2
        TARGY=ARGY+ARGY
        SIN2Y=SIN(TARGY)
        COS2Y=COS(TARGY)
        SH2Y=SINH(TARGY)
        CH2Y=COSH(TARGY)
        AL4=AL3*AL
        AL5=AL4*AL
        AL6=AL5*AL
        AL7=AL6*AL
        C=1.0/(KX2-4.0*KY2)
        j1l=0.
        j2l=0.
        j3l=0.
        j2xl=0.
        j3xl=0.
        j4xl=0.
        j5xl=0.
        j7xl=0.
        j9xl=0.
        j10xl=0.
        j11xl=0.
        j12xl=0.
        j13xl=0.
        j14xl=0.
        j15xl=0.
        j16xl=0.
        j17xl=0.
        IF(kx2.gt.6.*0) THEN
          CX=DCOS(KX*AL)
          SX=DSIN(KX*AL)/KX
          DX=H*(1.0D0-CX)/KX2
          J1XL=(ARGX-SINX)/KX3
          J2XL=(1.0-COSX-.5*ARGX*SINX)/KX4
          J3XL=.5*(SINX-ARGX*COSX)/KX3
          J4XL=(.5*ARGX-2.0*SINX/3.0+SIN2X/12.)/KX5
          J5XL=(.25D0-COSX/3.0+COS2X/12.0)/KX4
          J10XL=(ARGX-1.5*SINX+.5*ARGX*COSX)/KX5
          J11XL=(-2.0*ARGX+3.0*SINX-ARGX*COSX)/KX5
          J12XL=(4.0*ARGX-5.5*SINX+1.5*ARGX*COSX)/KX3
          J13XL=(.75-2.0*COSX/3.0-COS2X/12.0-.5*ARGX*SINX)
     <          /KX6
          J14XL=(1.5-4.0*COSX/3.0-COS2X/6.0-ARGX*SINX)/KX6
          J15XL=(-1.75+4.0*COSX/3.0+5.0*COS2X/12.0+1.5*ARGX
     <          *SINX)/KX4
          J16XL=(1.5*ARGX-7.0*SINX/3.0-SIN2X/12.0+ARGX*COSX)/
     <          KX7
          J17XL=(-1.75*ARGX+17.0*SINX/6.0+5.0*SIN2X/24.0-1.5
     <          *ARGX*COSX)/KX5
          J1L=(.5*ARGX-.25*SIN2X)/KX3
          J2L=(.5*ARGX+.25*SIN2X)/KX
          J3L=.25*(1.0-COS2X)/KX2
          if(ky2.lt.6.*0) then
            J7XL=.5*(ARGX-SINX+KX2*C*(SINX-.5*KX*SH2Y/KY))/(KX3*KY2)
            J9XL=C*((COSX-1.0)/KX2+(1.0-CH2Y)/(4.0*KY2))
          endif
!          if(ky2.eq.6.*0) then
          if(abs(ky2).le.fprec) then
            J7XL=(2.0*(SINX-ARGX)/KX3+AL3/3.0)/KX2
            J9XL=AL2/(2.0*KX2)+(COSX-1.0)/KX4
          endif
          if(ky2.gt.6.*0) then
            J7XL=.5*(ARGX-SINX+KX2*C*(SINX-.5*KX*SIN2Y/KY))/(KX3*KY2)
           J9XL=C*((COSX-1.0)/KX2+(1.0-COS2Y)/(4.0*KY2))
          endif
!   endif kx2.gt.0.
        ENDIF
        IF (kx2.lt.6.*0) then
          CX=COSH(KX*AL)
          SX=SINH(KX*AL)/KX
          DX=H*(1.0-CX)/KX2
          J1XL=(ARGX-SHX)/KX3
          J2XL=(1.0-CHX+.5*ARGX*SHX)/KX4
          J3XL=.5*(SHX-ARGX*CHX)/KX3
          J4XL=(.5*ARGX-2.0*SHX/3.0+SH2X/12.0)/KX5
          J5XL=(.25-CHX/3.0+CH2X/12.0)/KX4
          J10XL=(ARGX-1.5*SHX+.5*ARGX*CHX)/KX5
          J11XL=(-2.0*ARGX+3.0*SHX-ARGX*CHX)/KX5
          J12XL=(4.0*ARGX-5.5*SHX+1.5*ARGX*CHX)/KX3
          J13XL=(.75-2.0*CHX/3.0-CH2X/12.0+.5*ARGX*SHX)
     <          /KX6
          J14XL=(1.5-4.0*CHX/3.0-CH2X/6.0+ARGX*SHX)/KX6
          J15XL=(-1.75+4.0*CHX/3.0+5.0*CH2X/12.0-1.5*ARGX*SHX)
     <          /KX4
          J16XL=(1.5*ARGX-7.0*SHX/3.0-SH2X/12.0+ARGX*CHX)/
     <          KX7
          J17XL=(-1.75*ARGX+17.0*SHX/6.0+5.0*SH2X/24.0-1.5
     <          *ARGX*CHX)/KX5
          J1L=(.5*ARGX-.25*SH2X)/KX3
          J2L=(.5*ARGX+.25*SH2X)/KX
          J3L=.25*(1.0-CH2X)/KX2
          IF(KY2.LT.6.*0) THEN
            J7XL=.5*(ARGX-SHX+KX2*C*(SHX-.5*KX*SH2Y/KY))/(KX3*KY2)
            J9XL=C*((CHX-1)/KX2+(1.0D0-CH2Y)/(4.0D0*KY2))
          ENDIF
!          IF(KY2.EQ.6.*0) THEN
          if(abs(KY2).le.fprec) then
            J7XL=(2.0*(SINX-ARGX)/KX3+AL3/3.0D0)/KX2
            J9XL=AL2/(2.0D0*KX2)+(CHX-1.0D0)/KX4
          ENDIF
          IF(KY2.GT.6.*0) THEN
           J7XL=.5*(ARGX-SHX+KX2*C*(SHX-.5D0*KX*SIN2Y/KY))/(KX3*KY2)
           J9XL=C*((CHX-1.0)/KX2+(1.0-COS2Y)/(4.0*KY2))
          ENDIF
!   end kx2.lt.0.
        ENDIF
!        IF (KX2.EQ.6.*0) THEN
        IF(abs(KX2).LE.fprec) THEN
          CX=1
          SX=AL
          DX=H*AL*AL/2.0
          J1XL=AL3/6.0
          J2XL=AL4/24.0
          J3XL=AL3/6.0
          J4XL=AL5/60.0
          J5XL=AL4/24.0
          J7XL=(AL3/12.0-AL/(8.0*KY2)-SIN2Y/(16.0*KY3))/KY2
          J10XL=-AL5/24.0
          J11XL=-AL5/60.0
          J12XL=AL3/6.0
          J9XL=AL2/(8.0*KY2)-(1.0-COS2Y)/(16.0*KY4)
          J13XL=AL6/240.0
          J14XL=AL6/1080.0
          J15XL=AL4/12.0
          J16XL=AL7/840.0
          J17XL=AL5/60.0
          J1L=AL3/3.0
          J2L=AL
          J3L=AL2/2.0
!   end kx2.eq.0.
        ENDIF
        CPX=-KX2*SX
        SPX=CX
        DPX=H*SX
        j4l=0.
        j5l=0.
        j6l=0.
        IF (KY2.LT.6.*0) THEN
          CY=COSH(KY*AL)
          SY=SINH(KY*AL)/KY
          J4L=(.5*ARGY-.25*SH2Y)/KY3
          J5L=(.5*ARGY+.25*SH2Y)/KY
          J6L=.25*(1.0-CH2Y)/KY2
        ENDIF
!        IF (KY2.EQ.6.*0) THEN
        IF(abs(KY2).LE.fprec) THEN
          CY=1.0
          SY=AL
          J4L=AL3/3.0
          J5L=AL
          J6L=AL2/2.0
        ENDIF
        IF (KY2.GT.6.*0) THEN
          CY=COS(KY*AL)
          SY=SIN(KY*AL)/KY
          J4L=(.5*ARGY-.25*SIN2Y)/KY3
          J5L=(.5*ARGY+.25*SIN2Y)/KY
          J6L=.25*(1.0-COS2Y)/KY2
        ENDIF
        CPY=-KY2*SY
        SPY=CY
        SY2=SY*SY
        A=2.0*FIELDN-1.0-BETA
        B=(2.0-FIELDN)
        BN1=2.0*FIELDN-1.0-BETA
        BN2=2.5*FIELDN-BETA-1.5
        BN3=2.0*BETA-FIELDN
!  tabulation of the integrals (notations TRANSPORT SLAC R-75 table VIb)
        I10=DX/H
        I11=0.5*AL*SX
        I111=1.0*(SX**2+DX*RAD)/3.0
        I112=SX*DX*RAD/3.0
        I133=DX/H-(KY2/(KX2-4.0*KY2))*(SY2-2.0*DX*RAD)
        I134=C*(SY*CY-SX)
        I144=(SY2-2.0*DX*RAD)*C
        I20=SX
        I21=(SX+AL*CX)/2.0
        I22=I11
        I211=SX*(1.0+2.0*CX)/3.0
        I212=(2.0*SX**2-DX/H)/3.0
        I222=2.0*SX*DX*RAD/3.0
        I233=SX-2.0*KY2*(SY*CY-SX)*C
        I234=(KX2*DX*RAD-2.0*KY2*SY2)*C
        I244=2.0*C*(SY*CY-SX)
        I33=0.5*AL*SY
!        IF(KY2.EQ.6.*0) I34=AL3/6.0
!        IF(KY2.NE.6.*0) I34=0.5*(SY-AL*CY)/KY2
        IF(abs(KY2).LE.fprec) I34=AL3/6.0
        IF(abs(KY2).GT.fprec) I34=0.5*(SY-AL*CY)/KY2
        I314=(2.0*SX*CY-SY*(1.0+CX))*C
        I324=C*(2.0*CY*DX*RAD-SX*SY)
        I43=0.5*(SY+AL*CY)
        I44=I33
        I413=C*((KX2-2.0*KY2)*SX*CY-KY2*SY*(1.0+CX))
        I414=C*((KX2-2.0*KY2)*SX*SY-CY*(1.0-CX))
        I424=C*(CY*SX-CX*SY-2.0*KY2*SY*DX*RAD)
        I12=(SX-AL*CX)*0.5/KX2
        I27=(DX*RAD-.5*AL*SX)/KX2
        I313=C*(KX2*CY*DX*RAD-2.0*SX*SY*KY2)
        I314=(2.0*SX*CY-SY*(1.0+CX))*C
        I324=C*(2.0*CY*DX*RAD-SX*SY)
        I43=0.5*(SY+AL*CY)
        I44=I33
        I413=C*((KX2-2.0*KY2)*SX*CY-KY2*SY*(1.0+CX))
        I414=C*((KX2-2.0*KY2)*SX*SY-CY*(1.0-CX))
        I424=C*(CY*SX-CX*SY-2.0*KY2*SY*DX*RAD)
!        IF (KX.NE.6.*0) THEN
        IF (abs(KX).GT.fprec) THEN
          I12=(SX-AL*CX)*0.5/KX2
          I27=(DX*RAD-.5*AL*SX)/KX2
          I116=(0.5*AL*SX-(SX**2+DX/H)/3.0)*H/KX2
          I122=(2.0*DX/H-SX**2)/3.0/KX2
          I126=H*(SX+2.0*SX*CX-3.0*AL*CX)/6.0/KX2**2
          I166=H2*(4.0*DX*RAD/3.0+SX**2/3.0-AL*SX)/KX2**2
          I216=H*(AL*CX/2.0+SX/6.0-2.0*SX*CX/3.0)/KX2
          I226=H*(0.5*AL*SX-2.0*SX**2/3.0+DX*RAD/3.0)/KX2
          I266=H2*(SX/3.0+2.0*SX*CX/3.0-AL*CX)/KX2**2
          I323=C*(2.0*KY2*SY*(1.0+CX)/KX2-SX*CY)+SY/KX2
          I336=H*(0.5*AL*SY-C*(CY*(1.0-CX)-2.0*KY2*SX*SY))/KX2
          I346=H*(I34-C*(2.0*SX*CY-SY*(1.0+CX)))/KX2
          I423=C*(2.0*KY2*CY*(1.0+CX)/KX2-CX*CY-KY2*SX*SY)+CY/KX2
          I436=H*(0.5*AL*CY+0.5*SY+C*(KY2*SY*(1.0+CX)
     >         -(KX2-2.0*KY2)*SX*CY))/KX2
          I446=H*(AL*SY*0.5-C*((KX2-2.0*KY2)*SX*SY-CY*(1.0-CX)))/KX2
          I26=I12*H
        ELSE
          I12=AL3/6.0
          I27=AL4/12.0
          I116=H*AL4/24.0
          I122=AL4/12.0
          I126=H*AL5/40.0
          I166=H2*AL2/120.0
          I216=H*AL3/6.0
          I226=H*AL4/8.0
          I266=H2*AL5/20.0
          I323=AL2*SY/4.0
          I336=H*AL*(AL2*SY/12.0+(AL*CY-SY)/(KY2*8.0))
          I346=H*AL2*(SY/(KY2*8.0)-AL*CY/(KY2*12.0))
          I423=(AL2*CY+AL*SY)/4.0
          I436=H*AL2*(SY/8.0+CY*AL/12.0)
          I446=H*AL*(AL2*SY/12.0+(SY-AL*CY)/(KY2*8.0))
          I26=I12*H
        ENDIF
!     MATRIX T(i,j,k), TRANSPORT SLAC R-75 table VIa
!
        T(1,1,1)=A*H3*I111+0.5*KX2**2*I122*H
        T(1,1,2)=2.0*A*H3*I112-KX2*H*I112+H*SX
        T(1,1,6)=B*H2*I11+2.0*A*H3*I116-KX2*H2*I122
        T(1,2,2)=A*H3*I122+0.5*H*I111
        T(1,2,6)=B*H2*I12+2.0*A*H3*I126+H2*I112
        T(1,3,3)=BETA*H3*I133-0.5*KY2*H*I10
        T(1,3,4)=2.0*BETA*H3*I134
        T(1,4,4)=BETA*H3*I144-0.5*H*I10
        T(1,6,6)=B*H2*H*I27+A*H3*I166+0.5D0*H3*I122-
     1           H*I10
!
        T(2,1,1)=A*H3*I211+0.5*KX2**2*H*I222-H*CX*CPX
        T(2,1,2)=H*SPX+2.0D0*A*H3*I212-KX2*H*I212
     >       -H*(CX*SPX+CPX*SX)
        T(2,1,6)=B*H2*I21+2.0*A*H3*I216-KX2*H2*I222-H*
     >       (CX*DPX+CPX*DX)
        T(2,2,2)=A*H3*I222+0.5*H*I211-H*SX*SPX
        T(2,2,6)=B*H2*I22+2.0*A*H3*I226+H2*I212
     >        -H*(SX*DPX+SPX*DX)
        T(2,3,3)=BETA*H3*I233-0.5*KY2*H*I20
        T(2,3,4)=2.0*BETA*H3*I234
        T(2,4,4)=BETA*H3*I244-0.5*H*I20
        T(2,6,6)=B*H2*I26+A*H3*I266+0.5*H3*I222-H*DX*DPX-H*I20
!
!     VALUE OF "B" IS CHANGED.
!
        B=BETA-FIELDN
!
        T(3,1,3)=2.0*B*H3*I313+KX2*KY2*H*I324
        T(3,1,4)=H*SY+2.0D0*B*H3*I314-KX2*H*I323
        T(3,2,3)=2.0*B*H3*I323-KY2*H*I314
        T(3,2,4)=2.0*B*H3*I324+H*I313
        T(3,3,6)=KY2*I33+2.0*B*H3*I336-KY2*H2*I324
        T(3,4,6)=KY2*I34+2.0*B*H3*I346+H2*I323
!
        T(4,1,3)=2.0*B*H3*I413+KX2*KY2*H*I424-H*CX*CPY
        T(4,1,4)=H*SPY+2.0*H3*B*I414-KX2*H*I423-H*CX*SPY
        T(4,2,3)=2.0*B*H3*I423-KY2*H*I414-H*SX*CPY
        T(4,2,4)=2.0*B*H3*I424+H*I413-H*SX*SPY
        T(4,3,6)=KY2*I43+2.0*B*H3*I436-KY2*H2*I424-H*DX*CPY
        T(4,4,6)=KY2*I44+2.0*B*H3*I446+H2*I423-H*DX*SPY
!
        T(5,1,1)=H4*(BN1*J1XL-BN2*KX2*J4XL)+.5*KX4*J1L
        T(5,1,2)=H4*2.0*BN2*J5XL-KX2*J3L+H*DX
        T(5,1,6)=H5*J11XL+H3*J12XL+H*KX2*J3XL
     <   +H5*2.0*BN2*J4XL+2.0*BETA*H5*J10XL-H*KX2*J1L
! Carey eq. 7.45  p.143
        T(5,1,6)=T(5,1,6)-R(5,1)/sgam2
!
        T(5,2,2)=.5*(H2*J1XL+H4*2.0*BN2*J4XL+J2L)
        T(5,2,6)=-2.0*BETA*H5*J13XL+H5*J14XL+H3*J15XL+H*KX2*
     <  J2XL+H*J3L
! Carey eq. 7.45  p.143
        T(5,2,6)=T(5,2,6)-R(5,2)/sgam2
!
        T(5,3,3)=.5*(H4*(BN3*J1XL-2.0*BETA*KY2*J7XL)+KY4*J4L)
        T(5,3,4)=2.0*BETA*H4*J9XL-KY2*J6L
        T(5,4,4)=BETA*H4*J7XL-.5*(H2*J1XL-J5L)
        T(5,6,6)=(1.0-BETA)*H6*J16XL+H4*J17XL-H2*J3XL
     >        +.5*H2*J1L
! Carey eq. 7.45  p.143
        T(5,6,6)=T(5,6,6)-R(5,6)/sgam2
        T(5,6,6)=T(5,6,6)+AL*((1./sgam2)**2+1.5*sbet*sbet/sgam2)
! Carey eq.7.46 p.143
        T(5,5,6)=-1./sgam2
!  ENDIF Second order Matrix T
      ENDIF
!     RESTORE H
      H=SAH
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE syrout(ii)
!! SYNCHROTRON RADIATION EXCITATION FOR PARTICLE ii
!! The method is described in 'synchrotron radiation in DYNAC'
!< *******************************************************************
       SUBROUTINE syrout(ii)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       COMMON/RADIA/TRT,RMOY,XINTF,CRAE
!*************************************************************************************
!                    Synchrotron radiation
!  COMMON/RADIA/TRT,RMOY,XINTF,CRAE
!   TRT   : t.o.f in sec for a particle crossing the bending magnet
!   RMOY  : average radius of the bending magnet in the magnetic plane
!   XINTF : integral of (u/uc) * S(u/uc) where S(u/uc) is the spectral function
!            ( see Synchrotron radiation in DYNAC)
!   CRAE    : classical electron radius (cm)
!***************************************************************************************
!   PGAM  : Instantaneous radiation power (MeV/sec)
!   ETA   : eta=u/uc
!   uc    :  critical quanta energy (eV)
!   u     :  quanta energy (eV) considered
!           the most significant quanta are assumed emitted between: 0.1<eta<3.
       e4ii=f(7,ii)**4
       gpaii=f(7,ii)/xmat
       cgam=(4.*pi/3.)*crae/(xmat**3)
       pgam=vl*cgam*e4ii/(2.*pi*rmoy*rmoy)
!   ELOST  : Total energy lost due to radiation (MeV)
       elost=xintf*pgam*trt
!      variation of the momentum (only available for relativistic electrons)
       dmo=-elost/f(7,ii)
!      change the total energy (MeV)
       f(7,ii)=f(7,ii)-elost
!      change f(2,ii) and f(3,ii)
!       dmo*r(1,6) is given in m and  dmo*r(2,6) in rad, convert in cm and mrad
       f(2,ii)=f(2,ii)+dmo*r(1,6)*100.
       f(3,ii)=f(3,ii)+dmo*r(2,6)*1000.
       return
       end
!> *******************************************************************
!! SUBROUTINE syref
!! SYNCHROTRON RADIATION EXCITATION FROM PARTICLE REFERENCE
!! The method is described in 'synchrotron radiation in DYNAC'
!< *******************************************************************
       SUBROUTINE syref
       implicit real(8) (a-h,o-z)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RADIA/TRT,RMOY,XINTF,CRAE
       COMMON/DYN/TREF,VREF
       COMMON /BLOC23/ H, DEVI, NB, BDB,L
       common/itvole/itvol,imamin
       common/tofev/ttvols
       logical itvol,imamin
       real(8) L,NB
       beref=vref/vl
       gamref=1./sqrt(1.-beref*beref)
       ener=xmat*gamref*beref
       trt=l/vref
       e4=ener**4
       cgam=(4.*pi/3.)*crae/(xmat**3)
       pgam=vl*cgam*e4/(2.*pi*rmoy*rmoy)
!   ELOST  : Total energy lost due to radiation (MeV)
!   change vref and tref of the reference
       elost=xintf*pgam*trt
       fener=ener-elost
       fgam=fener/xmat
       fberef=sqrt(1.-1./(fgam*fgam))
       vref=fberef*vl
       tref=tref+l/vref
       if(itvol) ttvols=tref
       write(16,250) elost,ener,fener
250    format(//,' REFERENCE AFTER RADIATION EXITATION*****',/,
     *        '    ENERGY LOST (MeV):  ',e12.5,/,
     *        '    OLD ENERGY  (MeV):  ',e12.5,/,
     *        '    NEW ENERGY  (MeV):  ',e12.5)
       return
       end
!> *******************************************************************
!! SUBROUTINE sextu(imk2,arg,xlsex,rg)
!! magnetic sextupole
!! Space charge at the middle of the lens
!< *******************************************************************
       SUBROUTINE sextu(imk2,arg,xlsex,rg)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RIGID/BORO
       COMMON/FAISC/F(10,iptsz),IMAX,NGOOD
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON/DCSPA/IESP
       LOGICAL IESP
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       LOGICAL ICHAES
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       LOGICAL SHIFT
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/rander/ialin
       LOGICAL IALIN
       common/qskew/qtwist,iqrand,itwist,iaqu
       LOGICAL ITWIST
       common/femt/iemgrw,iemqesg
       LOGICAL IEMGRW
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/QSEX/L,KQ2,KS2
       REAL(8) L,KQ2,KS2
       dimension trans(2)
       ilost=0
       fprec=epsilon(arg)
       write(16,*) ' ******SEXTUPOLE*********'
!      statistics
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
       NRTRE=NRTRE+1
! print out on terminal of transport element # on one and the same line
       call PROGRESS(NRTRE,NRRES)
       len=1
!  if itwist=.true. skews the sextupole before misalignments
       sqtwist=0.
!       if(itwist.and.arg.ne.0.) then
       if(itwist .and. abs(arg).gt.fprec) then
         if(iqrand.eq.0) then
           qtwrad=qtwist
           sqtwist=qtwrad
           call zrotat(qtwrad)
         else
           rdcf=.5
           call rlux(trans,len)
           if(trans(1).le.rdcf) sign=-1.
           if(trans(1).gt.rdcf) sign=1.
           call rlux(trans,len)
           qtwrad=qtwist*sign*trans(1)
           sqtwist=qtwrad
           call zrotat(qtwrad)
         endif
       endif
       if(ialin) call randali
       FH0=FH/VL
       write(16,*)'TOF at input:',tref*fh*180./pi,' deg'
!
       gpa=0.
       do ii=1,ngood
        gpa=gpa+f(7,ii)/xmat
       enddo
       gpa=gpa/float(ngood)
       l=xlsex
       bpa=sqrt(1.-1./(gpa*gpa))
       xmco=xmat*bpa*gpa
       ri=33.356*xmco*1.e-01/qst
       if(imk2.ne.0) then
!   arg: field B (kG)
        fb=arg
        b=arg/(rg*rg)
        ks2=b/ri
       else
!  arg: KS2 (cm-3)
        ks2=arg
        b=ks2*ri
        fb=b*(rg*rg)
       endif
       write(16,3300)xlsex,rg,fb,ks2,b,ri
3300   format(' LENGTH = ',e12.3,' cm  APERTURE RADIUS= ',e12.5,' cm',
     *      /,' FIELD = ',e12.5,' kG  KS2 = ',e12.5,' cm-3',
     *        '  GRADIENT = ',e12.5,' kG/(cm*cm)',/,
     *        ' MOMENTUM = ',e12.5,' kG.cm',/)
       call clear
       call elsex
!    print transport matrix (c.o.g.)
       call matrix
!     start daves
       idav=idav+1
       iitem(idav)=10
       dav1(idav,1)=xlsex*10.
       dav1(idav,2)=b
       dav1(idav,3)=fb
       davtot=davtot+xlsex
       dav1(idav,4)=davtot*10.
       dav1(idav,5)=ks2
       dav1(idav,6)=rg
       dav1(idav,7)=ri
!      first half sextupole
       l=xlsex/2.
       do ii=1,ngood
        CALL CLEAR
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        RI=33.356*XMCO*1.E-01/f(9,ii)
        KS2  =  B/RI
        CALL ELSEX
        CALL cobeam(ii,l)
!       the evolution of the t.o.f is made in routine cobeam)
!omment      f(6,ii)=f(6,ii)+l/(bpai*vl)
       enddo
!      Charge space effect (if dl >0)
       if(ichaes.and.l.gt.0.) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           iesp=.true.
           write(16,*) 'Space charge at the middle  '
           call cesp(xlsex)
           iesp=.false.
         endif
       endif
       bcour=0.
       do i=1,ngood
         gpai=f(7,i)/xmat
         bcour=sqrt(1.-1./(gpai*gpai))+bcour
       enddo
       bcour=bcour/float(ngood)
       gcour=1./sqrt(1.-bcour*bcour)
       wcg=(gcour-1.)*xmat
! ----- convert wdisp in dp/p (window control)
! ---- ifw = 0 ===> wdisp = dW/W
! ---- ifw = 1 ===> wdisp = dW (MeV)
       if(ifw.eq.0) dispr=gcour*gcour*wdisp/(gcour*(gcour+1.))
       if(ifw.eq.1) dispr=gcour*gcour*wdisp/(gcour*(gcour+1.)*wcg)
! ---- Change the dispersion with the new energy
      do i=1,ngood
         gpai=f(7,i)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         fd(i)=bpai/bcour * gpai/gcour
       enddo
! Test window after the first half sextupole
       call cogetc
!  Change the t.o.f of the reference
       tref=tref+xlsex/(2.*vref)
       PRTLAB='SEXTUPO '
       call reject(nlost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       call shuffle
!    second half sextupole
       do ii=1,ngood
        CALL CLEAR
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        RI=33.356*XMCO*1.E-01/f(9,ii)
        KS2  =  B/RI
        CALL ELSEX
        CALL COBEAM(II,L)
       enddo
! Test window after the second half sextupole (only in transverse directions and phase)
       call cogetc
!  Change the t.o.f of the reference
       tref=tref+xlsex/(2.*vref)
       call reject(ilost,PRTLAB)
       ilost=ilost+nlost
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       dav1(idav,36)=ngood
       write(16,*)'TOF at output:',tref*fh*180./pi,' deg'
       write(16,*)' particles lost in sextupole :',ilost
!  returns coordinates to the initial orientation
!       if(itwist.and.b.ne.0.) then
       if(itwist .and. abs(b).gt.fprec) then
         qtwrad=-sqtwist
         call zrotat(qtwrad)
       endif
       if(iemgrw) call emiprt(0)
       PRLAB(IPRF)='SEXTUPO '
       CALL STAPL(davtot*10.)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE qalva(bquad,xlqua,rg)
!! QUADRUPOLE
!! space charge computations at the middle of the lens
!!   BQUAD: field at pole tip (kG)
!!          If BQUAD positive = focalisation in the H-plane (x,z)
!!   XLQUA: EFFECTIVE LENGHT (cm )
!!   RG:    APERTURE RADIUS (cm)
!< *******************************************************************
       SUBROUTINE qalva(bquad,xlqua,rg)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RIGID/BORO
       COMMON/FAISC/F(10,iptsz),IMAX,NGOOD
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON/DCSPA/IESP
       LOGICAL IESP
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       LOGICAL ICHAES
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       LOGICAL SHIFT
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/rander/ialin
       LOGICAL IALIN
       common/qskew/qtwist,iqrand,itwist,iaqu
       LOGICAL ITWIST
       common/femt/iemgrw,iemqesg
       LOGICAL IEMGRW
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/QSEX/L,KQ2,KS2
       common/tofev/ttvols
       COMMON/ITVOLE/ITVOL,IMAMIN
       logical itvol,imamin
       REAL(8) L,KQ2,KS2
       dimension trans(1)
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
       ilost=0
!   B : GRADIENT IN kG/cm
       b=bquad/rg
       fprec=epsilon(b)
!      statistics
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
       write(16,*) ' ***QUADRUPOLE (magnetic) ***'
       fcpi=fh*180./pi
       if(itvol) write(16,10) ttvols*fcpi,davtot
10     FORMAT(' ** TOF (input of the lens): ',e12.5,
     *        ' deg at: ',e12.5,' cm in the lattice')
!   if itwist=.true: skews the quadrupole before misalignments (if b ne 0)
!     len = 1 level in rlux routine
       len=1
!       if(itwist.and.b.ne.0.) then
       if(itwist .and. abs(b).gt.fprec) then
         if(iqrand.eq.0) then
           qtwrad=qtwist
           sqtwist=qtwrad
           call zrotat(qtwrad)
         else
           rdcf=.5
           call rlux(trans,len)
           if(trans(1).le.rdcf) sign=-1.
           if(trans(1).gt.rdcf) sign=1.
           call rlux(trans,len)
           qtwrad=qtwist*sign*trans(1)
           sqtwist=qtwrad
           call zrotat(qtwrad)
         endif
       else
         sqtwist=0.
       endif
       if(ialin) call randali
       fh0=fh/vl
!    print transport matrix (cog)
       gpa=0.
       do ii=1,ngood
        gpa=gpa+f(7,ii)/xmat
       enddo
       gpa=gpa/float(ngood)
       l=xlqua
       bpa=sqrt(1.-1./(gpa*gpa))
       xmco=xmat*bpa*gpa
       ri=33.356*xmco*1.e-01/qst
       kq2=b/ri
       call clear
       call elqua(gpa)
       write(16,3300) xlqua,rg,bquad,kq2,b,ri
3300   format(' LENGTH = ',e12.5,' cm  APERTURE RADIUS= ',e12.5,' cm',
     *      /,' FIELD = ',e12.5,' kG  K2 = ',e12.5,' cm-2 ',
     *        ' GRADIENT = ',e12.5,' kG/cm',/,
     *        ' MOMENTUM = ',e12.5,' kG.cm',/)
       call matrix
!  Daves start
       idav=idav+1
       iitem(idav)=2
       dav1(idav,1)=xlqua*10.
       dav1(idav,2)=bquad
       davtot=davtot+xlqua
       dav1(idav,4)=davtot*10.
       dav1(idav,3)=kq2
       dav1(idav,5)=b
       dav1(idav,6)=ri
       dav1(idav,7)=rg*10.
!      first half quadrupole
       l=xlqua/2.
       do ii=1,ngood
         call clear
         gpai=f(7,ii)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         xmco=xmat*bpai*gpai
         ri=33.356*xmco*1.e-01/f(9,ii)
         kq2=b/ri
         call elqua(gpai)
         call cobeam(ii,l)
       enddo
!      Charge space computations (if dl >0)
       if(ichaes.and.l.gt.0.) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           iesp=.true.
           write(16,*) 'Space charge at the middle  '
           call cesp(xlqua)
           iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
! Test window after the first half quadrupole (after s.c. computations)
       call cogetc
       bcour=0.
       do i=1,ngood
         gpai=f(7,i)/xmat
         bcour=sqrt(1.-1./(gpai*gpai))+bcour
       enddo
       bcour=bcour/float(ngood)
       gcour=1./sqrt(1.-bcour*bcour)
       wcg=(gcour-1.)*xmat
! ----- window control
!  Change the t.o.f of the reference
       tref=tref+xlqua/(2.*vref)
       PRTLAB='QUADRUPO'
       call reject(nlost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!    second half quadrupole
       do ii=1,ngood
         call clear
         gpai=f(7,ii)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         xmco=xmat*bpai*gpai
         ri=33.356*xmco*1.e-01/f(9,ii)
         kq2=b/ri
         call elqua(gpai)
!       ********CONTROL :print matrix for particle number 1 (only for tests)
!omment        if(ii.eq.1) then
!omment        write(16,*) ' *****second half quadrupole'
!omment         xkq2=sqrt(abs(kq2))
!omment         xkql=xkq2*l*57.29578
!omment         write(16,3300) ri,xkq2,xkql
!omment		    call matrix
!omment        endif
         call cobeam(ii,l)
       enddo
! Test window after the second half quadrupole
       call cogetc
!  Change the t.o.f of the reference
       tref=tref+xlqua/(2.*vref)
       call reject(ilost,PRTLAB)
       ilost=ilost+nlost
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       if(itvol) ttvols=tref
       tcog=0.
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       if(itvol) then
         write(16,11) ttvols*fcpi,davtot,tref*fcpi,tcog*fcpi
11       FORMAT(' ** tof: ',e12.5,
     *        ' deg at: ',e12.5,' cm in the lattice',
     * /,3x,'tof of the reference: ',e12.5,' deg tof of the cog: ',
     * e12.5,' deg')
       else
         write(16,12) tref*fcpi,tcog*fcpi
12       FORMAT(' ** tof of the reference: ',e12.5,
     *        ' deg tof of the cog: ',e12.5,' deg')
       endif
       dav1(idav,36)=ngood
       write(16,*)' particles lost in quadrupole :',ilost
!  returns coordinates to the initial orientation
!       if(itwist.and.b.ne.0.) then
       if(itwist .and. abs(b).gt.fprec) then
         qtwrad=-sqtwist
         call zrotat(qtwrad)
       endif
       if(iemgrw) call emiprt(0)
!  envelope
       PRLAB(IPRF)='QUADRUPO'
       call stapl(davtot*10.)
       return
       end
!> *******************************************************************
!! SUBROUTINE qasex(iksq,args,argq,xlqua,rg)
!! quadrupole associated sextupole field
!! space charge computation at the middle of the lens
!!   IKSQ: IFLAG (see ARGS and ARGQ)
!!   ARGS: strength of SEXTUPOLE
!!     IKSQ = 0, then ARGS =KS2 (cm-3), otherwise ARGS = FIELD FS(kG)
!!   ARGQ: strength of QUADRUPOLE
!!   If IKSQ = 0, then ARGQ=KQ2 (cm-2), otherwise ARGQ = FIELD FQ(kG)
!!   XLQUA : EFFECTIVE LENGHT OF THE LENS(cm)
!!   RG : APERTURE RADIUS OF THE LENS (cm)
!< *******************************************************************
       SUBROUTINE qasex(iksq,args,argq,xlqua,rg)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RIGID/BORO
       COMMON/FAISC/F(10,iptsz),IMAX,NGOOD
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON/DCSPA/IESP
       LOGICAL IESP
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       LOGICAL ICHAES
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       LOGICAL SHIFT
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/rander/ialin
       LOGICAL IALIN
       common/qskew/qtwist,iqrand,itwist,iaqu
       LOGICAL ITWIST
       common/femt/iemgrw,iemqesg
       LOGICAL IEMGRW
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/QSEX/L,KQ2,KS2
       REAL(8) L,KQ2,KS2
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
       rgorge=rg
       ilost=0
!      statistics
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
!      if itwist=.true. skews the quasex before misalignments
!omment       len=1
!omment       if(itwist.and.b.ne.0.) then
!omment         if(iqrand.eq.0) then
!omment           qtwrad=qtwist
!omment           sqtwist=qtwrad
!omment           call zrotat(qtwrad)
!omment         else
!omment           rdcf=.5
!omment           call rlux(trans,len)
!omment           if(trans.le.rdcf) sign=-1.
!omment           if(trans.gt.rdcf) sign=1.
!omment           call rlux(trans,len)
!omment           qtwrad=qtwist*sign*trans
!omment           sqtwist=qtwrad
!omment           call zrotat(qtwrad)
!omment         endif
!omment       endif
!   misalignments
       if(ialin) call randali
       gpa=0.
       do ii=1,ngood
        gpa=gpa+f(7,ii)/xmat
       enddo
       gpa=gpa/float(ngood)
       l=xlqua
       bpa=sqrt(1.-1./(gpa*gpa))
       xmco=xmat*bpa*gpa
       ri=33.356*xmco*1.e-01/qst
       if(iksq.ne.0) then
!  --- quadrupole: argq = field fq (kG)
        fq=argq
        bq=fq/rg
! kq2: strength (cm-2)
        kq2=bq/ri
! --- sextupole: args = field fs (kG)
        fs=args
        bs=fs/(rg*rg)
! ks2 strength (cm-3)
        ks2=bs/ri
       else
! --- quadrupole: argq is kq2 (cm-2)
        kq2=argq
        fq=kq2*rg*ri
        bq=kq2*ri
! --- sextupole: args is ks2 (cm-3)
        ks2=args
        bs=ks2*ri
        fs=bs*(rg*rg)
       endif
       call clear
       call elqsex
       write(16,*) ' *****LENS QUADRUPOLE+SEXTUPOLE ********'
       write(16,3300)xlqua,rg,fq,kq2,bq,fs,ks2,bs,ri
3300   format(' LENS: LENGTH = ',e12.5,' cm APERTURE RADIUS = ',e12.5,
     *  ' cm',/,' QUADRUPOLE: FIELD = ',e12.5,' kG   KQ2 = ',e12.5,
     * ' cm-2  GRADIENT = ',e12.5,' kG/cm',/,
     * ' SEXTUPOLE: FIELD = ',e12.5,' kG   KS2 = ',e12.5,' cm-3',
     * ' GRADIENT = ',e12.5,' kG/(cm*cm)',/,
     * ' MOMENTUM = ',e12.5,' kG.cm',/)
       FH0=FH/VL
       write(16,*)'TOF at input:',tref*fh*180./pi,' deg'
!    print transport matrix  (c.o.g.)
       call matrix
!  start Daves
       idav=idav+1
       iitem(idav)=12
       dav1(idav,1)=xlqua*10.
       dav1(idav,6)=rg*10.
       dav1(idav,2)=fq
       dav1(idav,3)=kq2
! gradient (quad)       dav1(idav,5)=bq
       dav1(idav,7)=fs
       dav1(idav,8)=ks2
! gradient (sol)       dav1(idav,9)=bs
       dav1(idav,10)=ri
       davtot=davtot+xlqua
       dav1(idav,4)=davtot*10.
!      first half quasex
       l=xlqua/2.
       do ii=1,ngood
        CALL CLEAR
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        RI=33.356*XMCO*1.E-01/f(9,ii)
        KQ2  =  BQ/RI
        KS2  =  BS/RI
        CALL ELQSEX
!       ********CONTROL :print matrix for particle number 1 (only for tests)
!omment        if(ii.eq.5) then
!omment         write(16,*) ' *****first half quasex'
!omment         xkq2=sqrt(abs(kq2))
!omment         xkql=xkq2*l*57.29578
!omment         xks=sqrt(abs(ks2))
!omment         xksl=xks*l**(1.5)*57.29578
!omment         write(16,3300) ri,xkq2,xkql,xks,xksl
!omment		 call matrix
!omment        endif
!       ********END CONTROL
        CALL cobeam(ii,l)
       enddo
!      Charge space effect (if dl >0)
       if(ichaes.and.l.gt.0.) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           iesp=.true.
           write(16,*) 'Space charge at the middle  '
           call cesp(xlqua)
           iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
! Test window after the first half quasex (after s.c. computations)
       bcour=0.
       do i=1,ngood
         gpai=f(7,i)/xmat
         bcour=sqrt(1.-1./(gpai*gpai))+bcour
       enddo
       bcour=bcour/float(ngood)
       gcour=1./sqrt(1.-bcour*bcour)
       wcg=(gcour-1.)*xmat
! ----- window control
       call cogetc
!  Change the t.o.f of the reference
       tref=tref+xlqua/(2.*vref)
       PRTLAB='QUADSXT '
       call reject(nlost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!    second half quasex
       do ii=1,ngood
        call clear
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        ri=33.356*xmco*1.e-01/f(9,ii)
        kq2  =  bq/ri
        ks2  =  bs/ri
        call elqsex
!       ********CONTROL :print matrix for particle number 1 (only for tests)
!omment        if(ii.eq.5) then
!omment         write(16,*) ' *****second half quasex'
!omment         xkq2=sqrt(abs(kq2))
!omment         xkql=xkq2*l*57.29578
!omment         xks=sqrt(abs(ks2))
!omment         xksl=xks*l**(1.5)*57.29578
!omment         write(16,3300) ri,xkq2,xkql,xks,xksl
!omment		    call matrix
!omment        endif
!       ********END CONTROL
        call cobeam(ii,l)
       enddo
! Test window after the second half quasex (only in transverse directions and phase)
       call cogetc
!  Change the t.o.f of the reference
       tref=tref+xlqua/(2.*vref)
       call reject(ilost,PRTLAB)
       ilost=ilost+nlost
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       dav1(idav,36)=ngood
       write(16,*)'TOF at output:',tref*fh*180./pi,' deg'
       write(16,*)' particles lost:',ilost
!  returns coordinates to the initial orientation
!omment       if(itwist.and.b.ne.0.) then
!omment         qtwrad=-sqtwist
!omment         call zrotat(qtwrad)
!omment       endif
       if(iemgrw) call emiprt(0)
       PRLAB(IPRF)='QUADSXT '
       CALL STAPL(davtot*10.)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE ELQUA(gam)
!! FIRST AND SECOND order TRANSPORT MATRIX R AND T
!!      PURE QUADRUPOLE FIELD, MATRIX R AND T  ARE IN  (M,RD)
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!!       GAM=relativistic gamma of COG
!< *******************************************************************
      SUBROUTINE ELQUA(gam)
      implicit real(8)(A-Z)
      COMMON/QSEX/L,KQ2,KS2
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
      COMMON/SECDR/ISEOR
      LOGICAL ISEOR
      AKQ2=KQ2*1.E04
      AL=L*1.e-02
      AKQ=SQRT(ABS(AKQ2))
      IF(AKQ.LT.1.E-13) AKQ=1.E-13
      ARG=AKQ*AL
      CSIN=SIN(ARG)
      CCOS=COS(ARG)
      HSIN=SINH(ARG)
      HCOS=COSH(ARG)
      IF(AKQ2.GT.0.0) THEN
        SSOK=CSIN/AKQ
        SC=CCOS
        BSOK=HSIN/AKQ
        BC=HCOS
      ELSE
        SSOK=HSIN/AKQ
        SC=HCOS
        BSOK=CSIN/AKQ
        BC=CCOS
      ENDIF
      R(1,1)=SC
      R(1,2)=SSOK
      R(2,1)=-AKQ2*SSOK
      R(2,2)=SC
      R(3,3)=BC
      R(3,4)=BSOK
      R(4,3)=AKQ2*BSOK
      R(4,4)=BC
!      R(5,6)=AL/(gam*gam)
      gam2=gam*gam
      bet2gam2=gam2-1.
      bet=sqrt(bet2gam2/gam2)
!!      R(5,6)=-AL/(bet*gam2*vl*0.01)
!      R(5,6)=0.
      IF(.NOT.ISEOR) RETURN
!     T116=AMAT(12,1)
      T(1,1,6)=AL*AKQ2*SSOK/2.0
!     T126=AMAT(17,1)
      T(1,2,6)=(SSOK-AL*SC)/2.0
!     T216=AMAT(12,2)
      T(2,1,6)=AKQ2*(SSOK+AL*SC)/2.0
!     T226=AMAT(17,2)
      T(2,2,6)=T(1,1,6)
!     T336= AMAT(21,3) T346=AMAT(24,3)
      T(3,3,6)=-AL*AKQ2*BSOK/2.0
      T(3,4,6)=(BSOK-AL*BC)/2.0
!     T436=AMAT(21,4)  T446=AMAT(24,4)
      T(4,3,6)=-AKQ2*(BSOK+AL*BC)/2.0
      T(4,4,6)=T(3,3,6)
!     T511=AMAT(7,5)  T512=AMAT(8,5) T522=AMAT(13,5) T533=AMAT(18,5)
      T(5,1,1)=AKQ2*(AL-SC*SSOK)/4.0
      T(5,1,2)=-AKQ2*SSOK*SSOK/2.0
      T(5,2,2)=(AL+SC*SSOK)/4.0
      T(5,3,3)=-AKQ2*(AL-BC*BSOK)/4.0
!     T534=AMAT(19,5)  T544=AMAT(22,5)
      T(5,3,4)=AKQ2*(BSOK*BSOK)/2.0
      T(5,4,4)=(AL+BC*BSOK)/4.0
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE ELSEX
!! FIRST AND SECOND order TRANSPORT MATRIX R AND T
!!    PURE SEXTUPOLE FIELD, MATRIX R AND T  ARE IN  (M,RD)
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!< *******************************************************************
      SUBROUTINE ELSEX
      implicit real(8)(A-Z)
      COMMON/QSEX/L,KQ2,KS2
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      COMMON/SECDR/ISEOR
      COMMON/ELQ/inisk
      INTEGER inisk
      LOGICAL ISEOR
      if(inisk.eq.0) then
        AKS2=KS2*1.E06
        AL=L*1.e-02
      else
        inisk=0
      endif
      fprec=epsilon(ks2)
      AKL1=AKS2*AL
      AKL2=AKL1*AL
      AKL3=AKL2*AL
      AKL4=AKL3*AL
      R(1,2)=AL
      R(3,4)=AL
      IF(.NOT.ISEOR) RETURN
!      T522=AMAT(13,5) T544=AMAT(22,5)
      T(5,2,2)=AL/2.0
      T(5,4,4)=AL/2.0
!      IF(AKS2.EQ.0.0)RETURN
      IF(abs(AKS2).LE.fprec)RETURN
!     T111=AMAT( 7,1) T112=AMAT( 8,1) T122=AMAT(13,1)
      T(1,1,1)=-AKL2/2.0
      T(1,1,2)=-AKL3/3.0
      T(1,2,2)=-AKL4/12.0
!     T133=AMAT(18,1)  T134=AMAT(19,1)  T144=AMAT(22,1)
      T(1,3,3)= AKL2/2.0
      T(1,3,4)= AKL3/3.0
      T(1,4,4)= AKL4/12.0
!     T211=AMAT( 7,2) T212=AMAT( 8,2) T222=AMAT(13,2)
      T(2,1,1)=-AKL1
      T(2,1,2)=-AKL2
      T(2,2,2)=-AKL3/3.0
!     T233=AMAT(18,2) T234=AMAT(19,2) T244=AMAT(22,2)
      T(2,3,3)= AKL1
      T(2,3,4)= AKL2
      T(2,4,4)= AKL3/3.0
!     T313=AMAT( 9,3) T314=AMAT( 10,3)  T323=AMAT(14,3) T324=AMAT(15,3)
      T(3,1,3)= AKL2
      T(3,1,4)= AKL3/3.0
      T(3,2,3)= AKL3/3.0
      T(3,2,4)= AKL4/6.0
!     T413=AMAT(9,4) T414=AMAT( 10,4) T423=AMAT(14,4) T424=AMAT(15,4)
      T(4,1,3)= AKL1*2.0
      T(4,1,4)= AKL2
      T(4,2,3)= AKL2
      T(4,2,4)= AKL3*2.0/3.0
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE ELQSEX
!! FIRST AND SECOND order TRANSPORT MATRIX R AND T
!!      QUADRUPOLE FIELD	+ SEXTUPOLE FIELD
!! quadrupole field combined with a sextupole field
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!< *******************************************************************
      SUBROUTINE ELQSEX
      implicit real(8)(A-Z)
      COMMON/QSEX/L,KQ2,KS2
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      COMMON/SECDR/ISEOR
      COMMON/ELQ/inisk
      INTEGER inisk
      LOGICAL ISEOR
      AKS2=KS2*1.E06
      AL=L*1.e-02
      AKQ2=KQ2*1.E04
      fprec=epsilon(AKQ2)
      AKQ=SQRT(ABS(AKQ2))
      ARG=AKQ*AL
      CSIN=SIN(ARG)
      CCOS=COS(ARG)
      HSIN=SINH(ARG)
      HCOS=COSH(ARG)
      IF(AKQ2.GT.6.*0) THEN
       SSOK=CSIN/AKQ
       SC=CCOS
       BSOK=HSIN/AKQ
       BC=HCOS
      ELSE
       SSOK=HSIN/AKQ
       SC=HCOS
       BSOK=CSIN/AKQ
       BC=CCOS
      ENDIF
!      IF(AKQ2.EQ.6.*0) THEN
      IF(abs(AKQ2).LE.fprec) THEN
       R(1,2)=AL
       R(3,4)=AL
      ELSE
       R(1,1)=SC
       R(1,2)=SSOK
       R(2,1)=-AKQ2*SSOK
       R(2,2)=SC
       R(3,3)=BC
       R(3,4)=BSOK
       R(4,3)=AKQ2*BSOK
       R(4,4)=BC
      ENDIF
      IF(.NOT.ISEOR) RETURN
!omment       IF(KS2.EQ.0.0)RETURN
!      IF(AKQ2.EQ.6.*0) THEN
      IF(abs(AKQ2).LE.fprec) THEN
        inisk=1
        call elsex
      ELSE
!      T111=AMAT( 7,1)  T112=AMAT( 8,1) T116=AMAT(12,1)
        T(1,1,1)=-AKS2*(SSOK*SSOK+(1.0-SC)/AKQ2)/3.0
        T(1,1,2)=-2.0*AKS2*(SSOK*(1.0-SC)/AKQ2)/3.0
        T(1,1,6)=AL*AKQ2*SSOK/2.0
!       T122=AMAT(13,1) T126=AMAT(17,1)
        T(1,2,2)=-AKS2*(2.0*(1.0-SC)/AKQ2-SSOK*SSOK)/
     >  (3.0*AKQ2)
        T(1,2,6)=(SSOK-AL*SC)/2.0
!      T133=AMAT(18,1) T134=AMAT(19,1) T144=AMAT(22,1)
        T(1,3,3)=AKS2*(BSOK*BSOK+3.0*(1.0-SC)/AKQ2)/5.0
        T(1,3,4)=2.0*AKS2*(BSOK*BC-SSOK)/(5.0*AKQ2)
        T(1,4,4)=AKS2*(BSOK*BSOK-2.0*(1.0-SC)/AKQ2)/
     >  (5.0*AKQ2)
!      T211=AMAT( 7,2) T212= AMAT( 8,2) T216=AMAT(12,2)
        T(2,1,1)=-AKS2*(2.0*SSOK*SC+SSOK)/3.0
        T(2,1,2)=-2.0*AKS2*(SC*(1.0-SC)/AKQ2+SSOK*SSOK)/3.0
        T(2,1,6)=AKQ2*(SSOK+AL*SC)/2.0
!      T222=AMAT(13,2)  T226=AMAT(17,2)
          T(2,2,2)=-AKS2*(2.0*SSOK-2.0*SSOK*SC)/(3.0*AKQ2)
          T(2,2,6)=T(1,1,6)
!       T233=AMAT(18,2) T234=AMAT(19,2) T244=AMAT(22,2)
        T(2,3,3)=AKS2*(2.0*BSOK*BC+3.0*SSOK)/5.0
        T(2,3,4)=2.0*AKS2*(BC*BC+BSOK*BSOK*AKQ2-SC)/
     >       (5.0*AKQ2)
        T(2,4,4)=2.0*AKS2*(BSOK*BC-SSOK)/(5.0*AKQ2)
!       T313=AMAT(9,3)   T314=AMAT(10,3)  T323=AMAT(14,3)
        T(3,1,3)=2.0*AKS2*(BC*(1.0-SC)/AKQ2+
     >                2.0*SSOK*BSOK)/5.0
        T(3,1,4)=2.0*AKS2*(2.0*SSOK*BC-BSOK*(1.0+SC))
     >  /(5.0*AKQ2)
        T(3,2,3)=2.0*AKS2*(3.0*BSOK-2.0*BSOK*SC-
     >    SSOK*BC)/(5.0*AKQ2)
!      T324=AMAT(15,3) T336= AMAT(21,3) T346=AMAT(24,3)
        T(3,2,4)=2.0*AKS2*(2.0*BC*(1.0-SC)/AKQ2-
     >     SSOK*BSOK)/(5.0*AKQ2)
        T(3,3,6)=-AL*AKQ2*BSOK/2.0
        T(3,4,6)=(BSOK-AL*BC)/2.0
!      T413=AMAT( 9,4)  T414=AMAT(10,4)  T423=AMAT(14,4)    T424=AMAT(15,4)
        T(4,1,3)=2.0*AKS2*(BSOK*(1.0-SC)+BC*SSOK+
     >  2.0*SC*BSOK+2.0*SSOK*BC)/5.0
        T(4,1,4)=2.0*AKS2*(2.0*SC*BC+2.0*SSOK*BSOK*AKQ2-
     >   BC*(1.0+SC)+BSOK*SSOK*AKQ2)/(5.0*AKQ2)
        T(4,2,3)=2.0*AKS2*(3.0*BC-2.0*BC*SC
     > +2.0*BSOK*SSOK*AKQ2-SC*BC-SSOK*BSOK*AKQ2)/(5.0*AKQ2)
        T(4,2,4)=2.0*AKS2*(2.0*BSOK*(1.0-SC)+
     >  2.0*BC*SSOK-SC*BSOK-SSOK*BC)/(5.0*AKQ2)
!      T436=AMAT(21,4)  T446=AMAT(24,4)
        T(4,3,6)=-AKQ2*(BSOK+AL*BC)/2.0
        T(4,4,6)=T(3,3,6)
!     T511=AMAT(7,5)  T512=AMAT(8,5) T522=AMAT(13,5) T533=AMAT(18,5)
        T(5,1,1)=AKQ2*(AL-SC*SSOK)/4.0
        T(5,1,2)=-AKQ2*SSOK*SSOK/2.0
        T(5,2,2)=(AL+SC*SSOK)/4.0
        T(5,3,3)=-AKQ2*(AL-BC*BSOK)/4.0
!      T534=AMAT(19,5)  T544=AMAT(22,5)
        T(5,3,4)=AKQ2*(BSOK*BSOK)/2.0
        T(5,4,4)=(AL+BC*BSOK)/4.0
      ENDIF
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE solfield(bcret,intgr)
!! Solenoid with an arbitrary magnetic field
!< *******************************************************************
       SUBROUTINE solfield(bcret,intgr)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DYN/TREF,VREF
       COMMON/RIGID/BORO
       COMMON/DCSPA/IESP
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       common/rander/ialin
       common/femt/iemgrw,iemqesg
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       dimension rs(6,6),rcul(6,6)
       logical iesp,ichaes,shift,ialin,iemgrw
!    print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
!       read the magnetic field on the disk
       read(25,*) ncord
       if(ncord.eq.0) then
        rewind(25)
        read(25,*)ncord
       endif
       crest=0.
       do i=1,ncord
        read(25,*) xspl(i),yspl(i)
        if(yspl(i).gt.crest) crest=yspl(i)
       enddo
       zinf=xspl(1)
       zsup=xspl(ncord)
       call deriv2(ncord)
       npas=intgr
       dsol=(zsup-zinf)/float(npas)
       xlsol=(zsup-zinf)*100.
       write(16,101) xlsol,crest,bcret
101    FORMAT(5X,'Field length =',F7.3,' cm ',/,
     X  5X,'Crest of the field =',F10.4,' kG' ,/
     X  5X,'Attenuation factor =',F10.4,/)
       FH0=FH/VL
!  random errors in alignment
       if(ialin) call randali
! test window
       ilost=0
!      PLOT
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
!  start prints in file 'short.data'
       idav=idav+1
       iitem(idav)=5
       dav1(idav,1)=xlsol*10.
       dav1(idav,2)=crest
       davti=davtot
       davtot=davtot+xlsol
       dav1(idav,4)=davtot*10.
       zc=zinf
       iesp=.true.
       do ia=1,6
         do ib=1,6
          if(ia.eq.ib) rcul(ia,ib)=1.
          if(ia.ne.ib) rcul(ia,ib)=0.
         enddo
       enddo
       bisol=0.
       bisol2=0.
       fnpas=float(npas)
       do i=1,npas
         zcf=zc+dsol
         zcf2=zc+dsol/2.
         bsol=bcret*spline(ncord,zcf2)
         dscm=dsol*100.
         tref=tref+xlsol/(vref*fnpas)
         call fldsol(bsol,dscm)
         write(16,520) i,zc,zcf,bsol
520      format(2x,'**STEP: ',i2,' LIMITS: inf(m)= ',f7.5,
     *        ' sup(m)= ',f7.5,' AVERAGE FIELD(kG): ',e12.5)
         bisol=bisol+bsol*dsol
         bisol2=bisol2+bsol*bsol*dsol
!     save equivalent transport matrix
         do ia=1,6
           do ib=1,6
             rs(ia,ib)=rcul(ia,ib)
           enddo
         enddo
         call mfordre(rcul,r,rs)
!   ************TEST******************
!   print first order matrix
!omment         write(16,*) ' EQUIVALENT FIRST order MATRIX TRANSFORM (m-rad)'
!omment       skl=0.5*acos(2.*r(1,1)-1.)*57.29578
!omment       write(16,*) '**** K*LENGTH: ',skl,' degrees'
!omment       DO IA=1,6
!omment        write(16,100) (r(ia,ib),ib=1,6)
!omment       ENDDO
!omment        write(16,*) '*******cumul***************'
!omment         DO IA=1,6
!omment         write(16,100) (rcul(ia,ib),ib=1,6)
!omment         ENDDO
!      **********END TEST********************
!  SPACE CHARGE
         if(.not.iesp) then
           iesp=.true.
         else
           if(ichaes.and.xlsol.gt.0.) then
             if(int(sce10).eq.1 .or. int(sce10).eq.3) then
               dscm2=dscm*2.
               call cesp(dscm2)
               iesp=.false.
!     dispersion dE/E with respect to the C.O.G of the bunch
               call disp
             endif
           endif
         endif
!  envelope sol
         write(16,*) 'distance',davti,dsol
         davti=davti+dsol*100.
         PRLAB(IPRF)='FSOLE   '
         call stapl((davti)*10.)
         zc=zcf
       enddo
       write(16,922) zc,bisol,bisol2,bisol2/zc
922    format(/,'Field length                 (m): ',e12.5,/,
     *  'Field integral            (kG.m): ',e12.5,/,
     *  'Field squared integral (kG**2.m): ',e12.5,/,
     *  'Field squared integral/L (kG**2): ',e12.5,/)
!110    format(2x,i5,2(2x,e12.5))
!   print first order matrix
       write(16,*) ' EQUIVALENT FIRST order MATRIX TRANSFORM (m-rad)'
       skl=0.5*acos(2.*rcul(1,1)-1.)*57.29578
       write(16,*) ' ******* K*LENGTH: ',skl,' degrees'
       DO IA=1,6
        write(16,100) (rcul(ia,ib),ib=1,6)
       ENDDO
100    format(6(3x,e12.5))
! **************************************************
!   evolution of the t.o.f of the reference (moved inside loop - Alt)
!       TREF=TREF+XLSOL/VREF
       dav1(idav,36)=ngood
!   plots
       PRLAB(IPRF)='FSOLE   '
       CALL STAPL(davtot*10.)
       if(iemgrw) call emiprt(0)
       WRITE(16,*) 'Particles lost in solenoid',ilost
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE fldsol(dbs,step)
!! solenoidal field
!< *******************************************************************
       SUBROUTINE fldsol(dbs,step)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/femt/iemgrw,iemqesg
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/SOLE/L,KL,KO
       REAL(8) L,KL,KO
       CHARACTER*(8) PRTLAB
       l=step
       b=dbs
       gpai=0.
       do ii=1,ngood
        gpai=gpai+f(7,ii)/xmat
       enddo
       gpai=gpai/float(ngood)
       bpai=sqrt(1.-1./(gpai*gpai))
       xmco=xmat*bpai*gpai
       ri=33.356*xmco*1.e-01/qst
       ko = b /ri
       fprec=epsilon(ko)
!       IF(KO .EQ. 0.) KO=1.E-16
       IF(abs(KO) .LE. fprec) KO=1.E-16
       kl = ko*l
! half step
!omment       kl=kl/2.
       call clear
       call elsol
       do ii=1,ngood
!   **********
!omment        call clear
!omment        gpai=f(7,ii)/xmat
!omment        bpai=sqrt(1.-1./(gpai*gpai))
!omment        xmco=xmat*bpai*gpai
!omment        RI=33.356*XMCO*1.E-01/f(9,ii)
!omment        KO = B /RI
!omment        IF(KO .EQ. 0.) KO=1.E-16
!omment        kl=ko*l
!omment        call elsol
!   ***************
        call cobeam(ii,l)
!     evolution of the t.o.f has been made in the routine cobeam
!omment         f(6,ii)=f(6,ii)+step/(bpai*vl)
       enddo
! test window after the step (only in the transverse directions)
       call cogetc
       PRTLAB='FSOLE   '
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       return
       end
!> *******************************************************************
!! SUBROUTINE solnoid(imks,arg,xlsol)
!! SOLENOID (fringe-fields are included in the transport matrix)
!!          space charge computations at the middle of the lens
!!     IMKS: IFLAG (see ARG)
!!     ARG:  IMKS = 0 then ARG is K (cm-1), otherwise ARG is the
!!           field BSOL (kG)
!!     XLSOL : EFFECTIVE LENGHT (CM )
!< *******************************************************************
       SUBROUTINE solnoid(imks,arg,xlsol)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DYN/TREF,VREF
       COMMON/RIGID/BORO
       COMMON/DCSPA/IESP
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       common/rander/ialin
       common/femt/iemgrw,iemqesg
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       common/itvole/itvol,imamin
       common/tofev/ttvols
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       character trace3h*128,trace3t*128,tif*128
       logical itvol,imamin
!       dimension rs(6,6),rcul(6,6)
       logical iesp,ichaes,shift,ialin,iemgrw
       COMMON/SOLE/L,KL,KO
       REAL(8) L,KL,KO
       fprec=epsilon(KO)
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
       write(16,*) ' ****** SOLENOID *********'
!      PLOT
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
       ilost=0
       FH0=FH/VL
       fcpi=fh*180./pi
!  random errors in alignment
       if(ialin) call randali
!    print out transport matrix (cog)
       gpa=0.
       do ii=1,ngood
        gpa=gpa+f(7,ii)/xmat
       enddo
       gpa=gpa/float(ngood)
       l=xlsol
       bpa=sqrt(1.-1./(gpa*gpa))
       xmco=xmat*bpa*gpa
       ri=33.356*xmco*1.e-01/qst
       if(imks.ne.0) then
!   ARG is the field B (kG)
        b=arg
!   KO = 2 * K (see ELSOL)
        KO = B /RI
!        IF(KO .EQ. 0.) KO=1.E-16
        IF(abs(KO) .LE. fprec) KO=1.E-16
       else
!   ARG is the strength K (cm-1)
!   KO = 2 * K (see ELSOL)
        ko = 2.*arg
!        IF(KO .EQ. 0.) KO=1.E-16
        IF(abs(KO) .LE. fprec) KO=1.E-16
        b=ko*ri
       endif
       KL = KO*L
       call clear
       call elsol
       xkql=(kl/2.)*57.29578
! trace3d
       kt3t=kt3t+1
       write(tif,6002) kt3t,kt3t,B*1000.,10.*XLSOL
6002   format('  nt(',i4,')= 5, a(1,',i4,')= ',f12.5,' , ',f9.5)
       trace3t(kt3t)=tif
!
       WRITE(16,101) XLSOL,B,ko/2.,ri,xkql
101    FORMAT('  LENGTH = ',F7.3,' CM ',/,
     X        '  FIELD = ',F10.4,' KG' ,/,
     *        '  K = ',e12.5,' cm-1',/,
     *        '  MOMENTUM = ',e12.5,' kG.cm',/,
     *        '  TRANSVERSE COORDINATES ROTATION = ',e12.5,' deg',/)
       call matrix
       write(16,10) ttvols*fcpi,davtot
10     FORMAT(' ** time of flight (input): ',e12.5,
     *        ' deg  position: ',e12.5,' cm')
!  start prints in file 'short.data'
       idav=idav+1
       iitem(idav)=5
       dav1(idav,1)=xlsol*10.
       dav1(idav,2)=b
       dav1(idav,3)=ko/2.
       davtot=davtot+xlsol
       dav1(idav,4)=davtot*10.
       dav1(idav,5)=ri
!     first half solenoid
       dg=xlsol
       l=xlsol/2.
       do ii=1,ngood
        call clear
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        RI=33.356*XMCO*1.E-01/f(9,ii)
        KO = B /RI
!        IF(KO .EQ. 0.) KO=1.E-16
        IF(abs(KO) .LE. fprec) KO=1.E-16
        KL = KO*L
        CALL ELSOL
        CALL cobeam(ii,l)
!     evolution of the t.o.f is made in routine cbeam
!omment         f(6,ii)=f(6,ii)+l/(bpai*vl)
       enddo
!      space charge computations (only if l >0)
       if(ichaes.and.l.gt.0.) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           iesp=.true.
           write(16,*) 'Space charge at the middle  '
           call cesp(xlsol)
           iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
! test window after the first half solenoid
       call cogetc
       bcour=0.
       do i=1,ngood
         gpai=f(7,i)/xmat
         bcour=sqrt(1.-1./(gpai*gpai))+bcour
       enddo
       bcour=bcour/float(ngood)
       gcour=1./sqrt(1.-bcour*bcour)
       wcg=(gcour-1.)*xmat
! ----- window control
       tref=tref+xlsol/(vref*2.)
       PRTLAB='SOLENO  '
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!  second half solenoid
       do ii=1,ngood
        CALL CLEAR
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        RI=33.356*XMCO*1.E-01/f(9,ii)
        KO = B /RI
!        IF(KO .EQ. 0.) KO=1.E-16
        IF(abs(KO) .LE. fprec) KO=1.E-16
        KL = KO*L
        CALL ELSOL
        CALL cobeam(ii,l)
       enddo
!   t.o.f
       TREF=TREF+XLSOL/(VREF*2.)
       call reject(ilost,PRTLAB)
       if(itvol) ttvols=tref
       tcog=0.
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       if(itvol) then
        write(16,11) ttvols*fcpi,davtot,tref*fcpi,tcog*fcpi
11      FORMAT(' ** tof for adjustments: ',e12.5,
     *        ' deg at position: ',e12.5,' cm in the lattice',
     * /,3x,'tof of the reference: ',e12.5,' deg tof of the cog: ',
     * e12.5,' deg')
       else
        write(16,12) tref*fcpi,tcog*fcpi
12      FORMAT(' ** tof of the reference: ',e12.5,
     *        ' deg tof of the cog: ',e12.5,' deg')
       endif
       dav1(idav,36)=ngood
!   plots
       PRLAB(IPRF)='SOLENO  '
       CALL STAPL(davtot*10.)
       if(iemgrw) call emiprt(0)
       WRITE(16,*) 'Particles lost in solenoid',ilost
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE elsol
!! first order and second order R and T solenoid matrix
!< *******************************************************************
       SUBROUTINE elsol
       implicit real(8) (a-h,o-z)
       COMMON/SOLE/L,KL,KO
       COMMON/RIGID/BORO
       REAL(8) L,KL,KO
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       COMMON/SECDR/ISEOR
       LOGICAL ISEOR
!      PURE SOLENOID FIELD, MATRIX R AND T  ARE IN  (M,RD)
!      SAVE KO AND L
       SAKO=KO
       SAL=L
!      convert (cm,rd) ==> (m,rd)
       KO=KO*100.
       L=L*1.E-02
       SN  = SIN(KL)
       CS  = COS(KL)
       R(4,4)  =  0.5 + 0.5*CS
       R(3,3)   = R(4,4)
       R(2,2)   = R(4,4)
       R(1,1)   = R(4,4)
       R(1,4)    =   (1.- CS)/KO
       R(3,2)    =  -R(1,4)
       R(4,1)    =  0.25*KO*(1.- CS)
       R(2,3)    =  -R(4,1)
       R(4,2)    =  -0.5*SN
       R(3,1)    =  R(4,2)
       R(2,4)    =  -R(3,1)
       R(1,3)    =  R(2,4)
       R(3,4)    =  R(1,3)*2./KO
       R(1,2)    =  R(3,4)
       R(4,3)    =  -0.25*KO*SN
       R(2,1)    =  R(4,3)
!     see element 16;  3.  in TRANSPORT USER MANUAL for SM (here: SM=0)
!omment       R(5,6) = R(5,6)  +  L * SM**2/(RI**2 + SM**2)
      IF(ISEOR) THEN
        TEMP = 0.5*KO*L*SN
        T(1,1,6) = TEMP
        T(2,2,6) = TEMP
        T(3,3,6) = TEMP
        T(4,4,6) = TEMP
        T(1,2,6) = SN/KO - L*CS
        T(3,4,6) = T(1,2,6)
        TEMP = - 0.5*KO*L*CS
        T(1,3,6) = TEMP
        T(2,4,6) = TEMP
        T(4,2,6) = - TEMP
        T(3,1,6) = - TEMP
        T(1,4,6) = (1.0 - CS)/KO - L*SN
        T(3,2,6) = -T(1,4,6)
        T(2,1,6) = 0.25*KO*(KO*L*CS + SN)
        T(4,3,6) =T(2,1,6)
        T(2,3,6) = 0.25*KO*(1.0 - CS + KO*L*SN)
        T(4,1,6) = - T(2,3,6)
        T(5,2,2) =  0.5*L
        T(5,4,4) =  0.5*L
      ENDIF
!     RESTORE KO AND L
      KO=SAKO
      L=SAL
!
!     PATH LENGTH TERMS
! see element 16;  3.  in TRANSPORT USER MANUAL for SM here one takes: SM=0
!omment  T(5,6,6) = T(5,6,6) - L*(SM**2 + 1.5*RI**2)*SM**2/
!omment     1 (SM**2 + RI**2)**2
!omment  T(5,5,6) = SM**2/(SM**2 + RI**2)
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE mfordre(rc,ra,rb)
!! Calculates RC=RA*RB
!< *******************************************************************
      SUBROUTINE mfordre(rc,ra,rb)
       implicit real(8) (a-h,o-z)
       DIMENSION RA(6,6), RB(6,6), RC(6,6)
       DO I1 = 1, 6
         DO I2 = 1, 6
           GHOST = 0.0
           DO I3 = 1, 6
             GHOST = GHOST + RA(I1,I3)*RB(I3,I2)
           ENDDO
           RC(I1,I2) = GHOST
         ENDDO
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE solquad(iksq,args,argq,xlsol,rg)
!! SOLENOID FIELD ASSOCIATED WITH QUADRUPOLE FIELD
!! space charge computations at the middle of the lens
!! --IKSQ: IFLAG
!! --ARGS: STRENGTH or FIELD OF SOLENOID
!!     If IKSQ = 0 then ARGS is the STRENGTH (cm-1), otherwise ARGS
!!     is the FIELD (kG)
!! --ARGQ: STRENGTH or FIELD of QUADRUPOLE
!!     If IKSQ = 0 then ARGQ is the STRENGTH (cm-2), otherwise ARGQ
!!     is the FIELD (kG)
!!   SIGN CONVENTIONS:
!!     SOLENOID: ARGS positive = rotate the transverse coordinates
!!               about the z-axis in the clockwise direction.
!!     QUADRUPOLE: ARGQ positive = focusing in the plane (x,z)
!! --XLSOL : EFFECTIVE LENGHT OF THE LENS(cm)
!! --RG : APERTURE RADIUS OF THE LENS (cm)
!< *******************************************************************
       SUBROUTINE solquad(iksq,args,argq,xlsol,rg)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DYN/TREF,VREF
       COMMON/RIGID/BORO
       COMMON/DCSPA/IESP
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       common/rander/ialin
       common/femt/iemgrw,iemqesg
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       LOGICAL ICHAES
       logical iesp,shift,ialin,iemgrw
       COMMON/SLQ/L,KSO,KQO
       REAL(8) L,KSO,KQO
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
       FH0=FH/VL
!      PLOT
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
!  random errors in alignment
       if(ialin) call randali
       ilost=0
!   magnetic rigidity (cog)
       gpa=0.
       do ii=1,ngood
        gpa=gpa+f(7,ii)/xmat
       enddo
       gpa=gpa/float(ngood)
       l=xlsol
       bpa=sqrt(1.-1./(gpa*gpa))
       xmco=xmat*bpa*gpa
       ri=33.356*xmco*1.e-01/qst
       if(iksq.ne.0) then
!  argq: quadrupole field (kG), args:solenoid field:(kG)
!   quadrupole
        fq=argq
        bq=fq/rg
        kqo=bq/ri
        strq=kqo
!   solenoid (KSO = 2 * K, see ELSQ)
        bs=args
        kso=bs/ri
        fprec=epsilon(kso)
        strs=kso/2
       else
!  argq: quadupole strength (cm-2), args: solenoid strength (cm-1)
!    quadrupole
        kqo=argq
        strq=argq
        bq=argq*ri
        fq=bq*rg
!   solenoid (KSO = 2 * K, see ELSQ)
        strs=args
        bs=2.*strs*ri
        kso=bs/ri
       endif
       xks=kso/2.
       xksl=xks*l*57.29578
       write(16,*) '****SOLENOID+QUADRUPOLE*******'
       write(16,101) xlsol,rg,bs,strs,xksl,fq,strq,ri
101    FORMAT('  LENGTH =',F7.3,' cm  APERTURE RADIUS=',e12.5,' cm',/,
     X        '  SOLENOID: FIELD = ',F10.4,' kG  K = ',e12.5,
     *        ' cm-1  ROTATING ANGLE = ',e12.5,' deg',/,
     X        '  QUADRUPOLE: FIELD  =',F10.4,' kG   K2 =',e12.5,
     *        ' cm-2 ',/,
     *        '  RIGIDITY = ',e12.5,' kG.cm',/)
!    print transport matrix (c.o.g.)
!     For convenience, the matrix R and T are computed for a positive KQO = (B/r)*(1/BRO)
!     if KQO is negative one has seting up 90 degree rotation on the beam
       CALL elsq
       write (16,*)
     *' The matrix R and T are shown for a positive strength'
       write (16,*)
     *' For a negative strength set up 90 deg rotation on the beam'
       call matrix
!  start prints in file 'short.data'
       idav=idav+1
       iitem(idav)=11
       dav1(idav,1)=xlsol*10.
       dav1(idav,2)=bs
       dav1(idav,3)=fq
       dav1(idav,5)=strq
       dav1(idav,6)=kso/2.
       dav1(idav,7)=rg*10.
       dav1(idav,8)=ri
       davtot=davtot+xlsol
       dav1(idav,4)=davtot*10.
!     first half lens
       dg=xlsol
       l=xlsol/2.
       do ii=1,ngood
        CALL CLEAR
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        RI=33.356*XMCO*1.E-01/f(9,ii)
!     KSO =K/2, see ELSQ
        KSO = BS / RI
!        IF(KSO .EQ. 6.*0) KSO=1.E-16
        IF(abs(KSO) .LE. fprec) KSO=1.E-16
        KQO = BQ / RI
        CALL ELSQ
!     the matrix R and T are computed for a positive KQO = (B/rg)*(1/BRO)
!     if KQO is negative set up 90 degree rotation on the beam
        IF(KQO.LT.6.*0) THEN
         irot=ii
         CALL rotat(irot)
         CALL cobeam(ii,l)
!   return the coordinates to their initial orientation
         irot=-ii
         CALL rotat(irot)
        ELSE
         CALL cobeam(ii,l)
       ENDIF
       enddo
!      Charge space effect (if l >0)
!       if(ichaes.and.l.gt.0.) then
       if(ichaes .and. abs(l).gt.fprec) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           iesp=.true.
           write(16,*) 'Space charge at the middle  '
           call cesp(xlsol)
           iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
! test window after the first half solquad
       call cogetc
       bcour=0.
       do i=1,ngood
         gpai=f(7,i)/xmat
         bcour=sqrt(1.-1./(gpai*gpai))+bcour
       enddo
       bcour=bcour/float(ngood)
       gcour=1./sqrt(1.-bcour*bcour)
       wcg=(gcour-1.)*xmat
! ----- convert wdisp in dp/p (for window control)
       tref=tref+xlsol/(2.*vref)
       PRTLAB='SOQUAD  '
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!   beam after the second half lens
       do ii=1,ngood
        CALL CLEAR
        gpai=f(7,ii)/xmat
        bpai=sqrt(1.-1./(gpai*gpai))
        xmco=xmat*bpai*gpai
        RI=33.356*XMCO*1.E-01/f(9,ii)
        KSO = BS / RI
!       KSO =K/2, see ELSQ
!        IF(KSO .EQ. 0.) KSO=1.E-16
        IF(abs(KSO) .LE. fprec) KSO=1.E-16
        KQO = BQ / RI
        CALL ELSQ
!     the matrix R and T are computed for a positive KQO = (B/r)*(1/BRO)
!     if KQO is negative set up 90 degree rotation on the beam
        IF(KQO.LT.6.*0) THEN
         IROT=II
         CALL rotat(irot)
         CALL cobeam(ii,l)
         IROT=-II
         CALL rotat(irot)
        ELSE
         CALL cobeam(ii,l)
        ENDIF
       enddo
!    t.o.f of reference
       TREF=TREF+XLSOL/(VREF*2.)
       call reject(ilost,PRTLAB)
       dav1(idav,36)=ngood
!   plots
       PRLAB(IPRF)='SOQUAD  '
       CALL STAPL(davtot*10.)
       if(iemgrw) call emiprt(0)
       WRITE(16,*) 'Particles lost in solenoid + quad',ilost
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE rotat(ii)
!! (+-) 90 DEG BEAM ROTATION
!< *******************************************************************
       SUBROUTINE rotat(ii)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       DIMENSION  FF(6)
       IF(II.GE.0) THEN
!   90 degree rotation
         FF(1)=F(2,II)
         FF(2)=F(3,II)
         FF(3)=F(4,II)
         FF(4)=F(5,II)
         F(2,II)=FF(3)
         F(3,II)=FF(4)
         F(4,II)=-FF(1)
         F(5,II)=-FF(2)
       ELSE
!   -90 degree rotation
         II=-II
         FF(1)=F(2,II)
         FF(2)=F(3,II)
         FF(3)=F(4,II)
         FF(4)=F(5,II)
         F(2,II)=-FF(3)
         F(3,II)=-FF(4)
         F(4,II)=FF(1)
         F(5,II)=FF(2)
       ENDIF
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE elsq
!! FIRST AND SECOND order MATRIX R AND T  (m,rd)
!!      quadrupole field combined with a solenoid field
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                OTHERWIZE DECLARED *********
!< *******************************************************************
      SUBROUTINE elsq
      implicit real(8)(A-Z)
      COMMON/RIGID/BORO
      COMMON/SLQ/L,KSO,KQO
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      COMMON/SECDR/ISEOR
      LOGICAL ISEOR
      AL=L*1.e-02
      AKQ= KQO*1.E04
      AKS= KSO*1.e02
      AKS=AKS/2.
      AKQ4=AKQ*AKQ
      AKS2=AKS*AKS
      AKS3=AKS2*AKS
      AKS4=AKS2*AKS2
      Q2=DSQRT(AKQ4+4.0*AKS4)
      Q2I=1.0/Q2
      SK1=SQRT(2.0*AKS2+Q2)
      SK3=SQRT(ABS(Q2-2.0*AKS2))
      fprec=epsilon(SK3)
      SS=SIN(SK1*AL)
      SC=COS(SK1*AL)
      BS=SINH(SK3*AL)
      BC=COSH(SK3*AL)
      SKP=0.5*(SK1+SK3)
      SKM=0.5*(SK1-SK3)
      SKP2=SKP*SKP
      SKP3=SKP2*SKP
      SKM2=SKM*SKM
      SKM3=SKM2*SKM
      R(1,1)=Q2I*(SKP2*SC+SKM2*BC)
      R(1,2)=Q2I*(SKP*SS-SKM*BS)
      R(1,3)=Q2I*AKS*(SKM*SS+SKP*BS)
      R(1,4)=Q2I*AKS*(BC-SC)
      R(2,1)=Q2I*(-SKP3*SS-SKM3*BS)
      R(2,2)=Q2I*(SKP2*SC+SKM2*BC)
      R(2,3)=Q2I*AKS3*(SC-BC)
      R(2,4)=Q2I*AKS*(SKP*SS-SKM*BS)
      R(3,1)=Q2I*AKS*(SKM*BS-SKP*SS)
      R(3,2)=Q2I*AKS*(SC-BC)
      R(3,3)=Q2I*(SKM2*SC+SKP2*BC)
      R(3,4)=Q2I*(SKM*SS+SKP*BS)
      R(4,1)=Q2I*AKS3*(BC-SC)
      R(4,2)=Q2I*AKS*(-SKM*SS-SKP*BS)
      R(4,3)=Q2I*(SKP3*BS-SKM3*SS)
      R(4,4)=Q2I*(SKM2*SC+SKP2*BC)
      IF(.NOT.ISEOR) RETURN
      DAKS=-AKS
      DAKQ=-AKQ
      DAKQ4=2.0*AKQ*DAKQ
      DAKS2=2.0*AKS*DAKS
      DAKS3=3.0*AKS2*DAKS
      DAKS4=4.0*AKS3*DAKS
      DQ2=0.5*Q2I*(DAKQ4+4.0*DAKS4)
      Q2I2=Q2I*Q2I
      DQ2I=-Q2I2*DQ2
      DSK1=(2.0*DAKS2+DQ2)/(2.0*SK1)
      DSK3=0.0
!      IF(SK3.NE.6.*0)DSK3=(DQ2-2.0*DAKS2)/(2.0*SK3)
      IF(abs(SK3).GT.fprec)DSK3=(DQ2-2.0*DAKS2)/(2.0*SK3)
      DSS=SC*DSK1*AL
      DSC=-SS*DSK1*AL
      DBS=BC*DSK3*AL
      DBC=BS*DSK3*AL
      DSKP=0.5*(DSK1+DSK3)
      DSKM=0.5*(DSK1-DSK3)
      DSKP2=2.0*SKP*DSKP
      DSKP3=3.0*SKP2*DSKP
      DSKM2=2.0*SKM*DSKM
      DSKM3=3.0*SKM2*DSKM
      T(1,1,6)=DQ2I*(SKP2*SC+SKM2*BC)+
     > Q2I*(DSKP2*SC+SKP2*DSC+DSKM2*BC+SKM2*DBC)
      T(1,2,6)=DQ2I*(SKP*SS-SKM*BS)+
     > Q2I*(DSKP*SS+SKP*DSS-DSKM*BS-SKM*DBS)
      T(1,3,6)=(DQ2I*AKS+Q2I*DAKS)*(SKM*SS+SKP*BS)
     > +Q2I*AKS*(DSKM*SS+SKM*DSS+DSKP*BS+SKP*DBS)
      T(1,4,6)=(DQ2I*AKS+Q2I*DAKS)*(BC-SC)
     > +Q2I*AKS*(DBC-DSC)
      T(2,1,6)=DQ2I*(-SKP3*SS-SKM3*BS)
     > +Q2I*(-DSKP3*SS-SKP3*DSS-DSKM3*BS-SKM3*DBS)
      T(2,2,6)=T(1,1,6)
      T(2,3,6)=(DQ2I*AKS3+Q2I*DAKS3)*(SC-BC)
     > +Q2I*AKS3*(DSC-DBC)
      T(2,4,6)=(DQ2I*AKS+Q2I*DAKS)*(SKP*SS-SKM*BS)
     > +Q2I*AKS*(DSKP*SS+SKP*DSS-DSKM*BS-SKM*DBS)
      T(3,1,6)=-T(2,4,6)
      T(3,2,6)=-T(1,4,6)
      T(3,3,6)=DQ2I*(SKM2*SC+SKP2*BC)
     > +Q2I*(DSKM2*SC+SKM2*DSC+DSKP2*BC+SKP2*DBC)
      T(3,4,6)=DQ2I*(SKM*SS+SKP*BS)
     > +Q2I*(DSKM*SS+SKM*DSS+DSKP*BS+SKP*DBS)
      T(4,1,6)=-T(2,3,6)
!omment      AMAT(17,4,MATADR)=-AMAT(21,1,MATADR)
      T(4,2,6)=-T(1,3,6)
      T(4,3,6)=DQ2I*(SKP3*BS-SKM3*SS)
     > +Q2I*(DSKP3*BS+SKP3*DBS-DSKM3*SS-SKM3*DSS)
      T(4,4,6)=T(3,3,6)
      AISSSC=0.0
!      IF(SK1.NE.0.0)AISSSC=SS*SS/(2.0*SK1)
      IF(abs(SK1).GT.fprec)AISSSC=SS*SS/(2.0*SK1)
      AIBSBC=0.0
!      IF(SK3.NE.0.0)AIBSBC=BS*BS/(2.0*SK3)
      IF(abs(SK3).GT.fprec)AIBSBC=BS*BS/(2.0*SK3)
      AISSBC=Q2I*(SK3*SS*BS-SK1*SC*BC+SK1)
      AISCBS=Q2I*(SK3*SC*BC+SK1*SS*BS-SK3)
      AISS2=0.0
      AISC2=AL
      AIBS2=0.0
      AIBC2=AL
!      IF(SK1.NE.0.0)AISS2=0.5*(AL-SS*SC/SK1)
!      IF(SK1.NE.0.0)AISC2=0.5*(AL+SS*SC/SK1)
      IF(abs(SK1).GT.fprec)AISS2=0.5*(AL-SS*SC/SK1)
      IF(abs(SK1).GT.fprec)AISC2=0.5*(AL+SS*SC/SK1)
!      IF(SK3.NE.0.0)AIBS2=0.5*(BS*BC/SK3 - AL)
!      IF(SK3.NE.0.0)AIBC2=0.5*(AL+BS*BC/SK3)
      IF(abs(SK3).GT.fprec)AIBS2=0.5*(BS*BC/SK3 - AL)
      IF(abs(SK3).GT.fprec)AIBC2=0.5*(AL+BS*BC/SK3)
      AISSBS=Q2I*(SK3*SS*BC-SK1*SC*BS)
      AISCBC=Q2I*(SK1*SS*BC+SK3*SC*BS)
      AKS5=AKS4*AKS
      AKS6=AKS5*AKS
      SKP4=SKP3*SKP
      SKP5=SKP4*SKP
      SKP6=SKP5*SKP
      SKM4=SKM3*SKM
      SKM5=SKM4*SKM
      SKM6=SKM5*SKM
      Q4I=Q2I*Q2I
      T(5,1,1)=Q4I*0.5*(SKP6*AISS2+SKM6*AIBS2-2.0*SKP3*SKM3
     >   *AISSBS+AKS6*(AISC2+AIBC2-2.0*AISCBC))
      T(5,1,2)=Q4I*(-SKP5*AISSSC-SKP3*SKM2*AISSBC
     >      -SKM3*SKP2*AISCBS
     >      -SKM5*AIBSBC-AKS4*(-SKM*AISSSC-SKP*AISCBS+
     >      SKM*AISSBC+SKP*AIBSBC))
      T(5,1,3)=Q4I*AKS3*((SKP3-SKM3)*(AISSBC-AISSSC)
     >  +(SKP3+SKM3)*(AIBSBC-AISCBS))
      T(5,1,4)=Q4I*(AKS*(-SKP4*AISS2-(SKP3*SKM+SKM3*SKP)*AISSBS
     >  +SKM4*AIBS2)+AKS3*(-SKM2*AISC2-(SKP2-SKM2)*AISCBC+SKP2*AIBC2))
      T(5,2,2)=Q4I*0.5*(SKP4*AISC2+2.0*SKP2*SKM2*AISCBC
     >  +SKM4*AIBC2+AKS2*(SKM2*AISS2+2.0*SKP*SKM*AISSBS+SKP2*AIBS2))
      T(5,2,3)=Q4I*(AKS3*(SKP2*AISC2-(SKP2-SKM2)*AISCBC
     >  -SKM2*AIBC2)-AKS*(-SKM4*AISS2+(SKM*SKP3-SKP*SKM3)*AISSBS+
     >  SKP4*AIBS2))
      T(5,2,4)=Q4I*AKS*((SKP3-SKM3)*AISSSC-(SKP2*SKM+SKP*SKM2)
     >  *AISCBS+(SKM2*SKP-SKM*SKP2)*AISSBC-(SKM3+SKP3)*AIBSBC)
      T(5,3,3)=Q4I*0.5*(AKS6*(AISC2-2.0*AISCBC+AIBC2)
     >  +SKM6*AISS2-2.0*SKM3*SKP3*AISSBS+SKP6*AIBS2)
      T(5,3,4)=Q4I*(AKS4*(SKP*AISSSC-SKM*AISCBS-SKP*AISSBC
     >  +SKM*AIBSBC)-SKM5*AISSSC-SKM3*SKP2*AISSBC+SKP3*SKM2*AISCBS
     >  +SKP5*AIBSBC)
      T(5,4,4)=Q4I*0.5*(AKS2*(SKP2*AISS2-2.0*SKP*SKM*AISSBS
     > +SKM2*AIBS2)+SKM4*AISC2+2.0*SKM2*SKP2*AISCBC+SKP4*AIBC2)
      RETURN
      END
!> *******************************************************************
!! SUBROUTINE fdrift(xl,npart,imit)
!! DIVIDE A DRIFT LENGHT OF :XL CM  IN :NPART PARTIAL DRIFTS
!! This will allow several space charge computations in the drift
!< *******************************************************************
       SUBROUTINE fdrift(xl,npart,imit)
       implicit real(8) (a-h,o-z)
       dl=xl/float(npart)
       do i=1,npart
         call drift(dl)
         if(imit.ne.0) call emiprt(0)
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE drift(dl)
!! DRIFT LENGHT (cm)
!! space charge computation at the middle of the drift
!< *******************************************************************
       SUBROUTINE drift(dl)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/RIGID/BORO
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/tapes/in,ifile,meta,ierr
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DCSPA/IESP
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/SHIF/DTIPH,SHIFT
       common/femt/iemgrw,iemqesg
       common/posc/xpsc
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       common/tofev/ttvols
       COMMON/ITVOLE/ITVOL,IMAMIN
       logical iesp,ichaes,shift,iemgrw,itvol,imamin
       ilost=0
       FH0=FH/VL
       fcpi=fh*180./pi
       write(16,*)'*** DRIFT of length ',dl,' cm'
       if(itvol)write(16,10) ttvols*fcpi,davtot
10     FORMAT(' ** tof for adjustments at input: ',e12.5,
     *        ' deg at position: ',e12.5,' cm in the lattice')
!      STATISTICS
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
!       random error in position only if dl is positif
!        Beam at the half drift
       dg2=dl/2.
! 2016-Nov-04 test
!
!       bref=vref/vl
!       gref=sqrt(1./(1.-bref*bref))
!       R56ref=dg2/(gref*gref)
!       write(97,*) 'DRIFT,test ',dg2       
!       write(97,*) 'DRIFT, R56 ',R56ref       
       do i=1,ngood
!   conversion mrad ===> rad
         F2=F(3,I)*.001
         F4=F(5,I)*.001
         F(2,I)=F(2,I)+DG2*TAN(F2)
         F(4,I)=F(4,I)+DG2*TAN(F4) / COS(F2)
         gpai=f(7,i)/xmat
         gpai2=gpai*gpai
         bpai=sqrt(1.-1./(gpai2))
         bpai2=bpai*bpai
         vpai=vl*bpai
         f(6,i)=f(6,i)+dg2/(vpai*cos(f2)*cos(f4))
!! 2016-Nov-04 new
!         SF5=dg2/(cos(f2)*cos(f4))
!         R56SF6=(FD(i)-1.)*SF5/(bpai2*gpai2)
!         R56SF6=SF5/(gpai*gpai)
!         R56SF6=(FD(i))*SF5/(gpai*gpai)
!         F(6,i)=F(6,i)+(SF5+R56SF6)/VPAI
!         F(6,i)=F(6,i)+(SF5)/VPAI
       enddo
!      ENVEL
!  start prints in file 'short.data'
       davtot=davtot+dl
       if(dl.gt.0.) then
!         nlength=nlength+1
         idav=idav+1
         iitem(idav)=7
         dav1(idav,1)=dl*10.
         dav1(idav,4)=davtot*10.
       endif
!      Space charge   (if dl >1.e-04)
       if(ichaes.and.dl.ge.1.e-04) then
!         if(sce10.eq.3.) then
         if(int(sce10).eq.3) then
           iesp=.true.
           write(16,*) ' Space charge at the middle'
           call cesp(dl)
           iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
! Test window after the first half drift
       tref=tref+dl/(vref*2.)
       PRTLAB='DRIFT   '
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       il=ilost
!        Beam for the second half drift
       do i=1,ngood
         f2=f(3,i)*.001
         f4=f(5,i)*.001
         f(2,i)=f(2,i)+dg2*tan(f2)
         f(4,i)=f(4,i)+dg2*tan(f4) / cos(f2)
         gpai=f(7,i)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
         vpai=vl*bpai
         f(6,i)=f(6,i)+dg2/(vpai*cos(f2)*cos(f4))
! 2016-Nov-04 new
!         SF5=dg2/(cos(f2)*cos(f4))
!         R56SF6=(FD(i)-1.)*SF5/(gpai*gpai)
!         R56SF6=(FD(i))*SF5/(gpai*gpai)
!         R56SF6=SF5/(gpai*gpai)
!         F(6,i)=F(6,i)+(SF5+R56SF6)/VPAI
!         F(6,i)=F(6,i)+(SF5)/VPAI
       enddo
! Test window after the second half drift (only in transverse directions and phase)
       tref=tref+dl/(vref*2.)
       call reject(ilost,PRTLAB)
       il=il+ilost
!     change the reference and the TOF
       if(itvol) ttvols=tref
       if(dl.gt.0.)then
         dav1(idav,36)=ngood
!  envelope
         PRLAB(IPRF)='DRIFT   '
         call stapl(davtot*10.)
       endif
       tcog=0.
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       if(itvol) then
        write(16,11) ttvols*fcpi,davtot,tref*fcpi,tcog*fcpi
11      FORMAT(' ** tof for adjustments : ',e12.5,
     *        ' deg at position: ',e12.5,' cm in the lattice',
     * /,3x,'tof of the reference: ',e12.5,' deg tof of the cog: ',
     * e12.5,' deg')
       else
        write(16,12) tref*fcpi,tcog*fcpi
12      FORMAT(' ** tof of the reference: ',e12.5,
     *        ' deg tof of the cog: ',e12.5,' deg')
       endif
       write(16,*) 'particles lost in drift: ',il
       if(iemgrw.and.dl.gt.0.) then
         if(iemqesg.eq.2) call emiprt(0)
       endif
       RETURN
       END
       SUBROUTINE clear
!    CLEAR MATRIX R AND T
       implicit real(8) (a-h,o-z)
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       COMMON/SECDR/ISEOR
       LOGICAL ISEOR
!   CLEAR R
       DO IA=1,6
         DO IB=1,6
           R(IA,IB)=0.
           IF(IA.EQ.IB) R(IA,IB)=1.
         ENDDO
       ENDDO
!   CLEAR T
       IF(ISEOR) THEN
         DO IA=1,6
           DO IB=1,6
             DO IC=1,6
               T(IA,IB,IC)=0.
             ENDDO
           ENDDO
         ENDDO
       ENDIF
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE cobeam(ii,xl)
!! MATRIX BASED BEAM COMPUTATION
!< *******************************************************************
       SUBROUTINE cobeam(ii,xl)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RADIA/TRT,RMOY,XINTF,CRAE
       COMMON/SECDR/ISEOR
       LOGICAL ISEOR
       DIMENSION SF(6),SSF(6)
!     MATRIX R AND T ARE IN  M-RD
!   beam conversion:  CM ===> M      MRD ==> RD
       SF(1)=F(2,II)*1.E-02
       SF(2)=F(3,II)*1.E-03
       SF(3)=F(4,II)*1.E-02
       SF(4)=F(5,II)*1.E-03
       SF(5)=XL*1.E-02
       SF(5)=SF(5)/(cos(sf(2))*cos(sf(4)))
       SF(6)=(FD(II)-1.)
!       FIRST order COMPUTATION (M-RD)
       DO IA=1,6
         SSF(IA)=0.
         DO IB=1,6
           SSF(IA)=R(IA,IB)*SF(IB)+SSF(IA)
         ENDDO
       ENDDO
       IF(ISEOR) THEN
!    SECOND order COMPUTATION  (M-RD)
         DO IA=1,6
           DO IB=1,6
             DO IC=1,6
               SSF(IA)=SSF(IA)+T(IA,IB,IC)*SF(IB)*SF(IC)
             ENDDO
           ENDDO
         ENDDO
       ENDIF
       DO IA=1,4
         F(IA+1,II)=SSF(IA)
       ENDDO
!   CONVERT RD ==> MRD    M ==> CM
       F(3,II)=F(3,II)*1000.
       F(5,II)=F(5,II)*1000.
       F(2,II)=F(2,II)*100.
       F(4,II)=F(4,II)*100.
       GPAI=F(7,II)/XMAT
       BPAI=SQRT(1.-1./(GPAI*GPAI))
       VPAI=VL*BPAI
       TRT=100.*SSF(5)/VPAI
       F(6,II)=F(6,II)+TRT
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE disp
!! Compute the dispersion dE/E with respect to the center of
!! gravity of the bunch
!< *******************************************************************
       SUBROUTINE disp
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/mcs/imcs,ncstat,cstat(20)
       common /consta/ vl,pi,xmat,rpel,qst
       gcog=0.
       do i=1,ngood
         gcog=f(7,i)/xmat+gcog
       enddo
       gcog=gcog/float(ngood)
       bcog=sqrt(1.-1./(gcog*gcog))
       do i=1,ngood
         gpai=f(7,i)/xmat
         if(gpai.ge.1.) then
           bpai=sqrt(1.-1./(gpai*gpai))
         else
           bpai=0.
         endif
         fd(i)=bpai/bcog * gpai/gcog
       enddo
       return
       end
!old    do ist=1,ncstat
!old         gcog=0.
!old         nii=0
!old         do ii=1,ngood
!old          if(f(9,ii).eq.cstat(ist)) then
!old            gcog=gcog+f(7,ii)/xmat
!old            nii=nii+1
!old           endif
!old          enddo
!old           gcog=gcog/float(nii)
!old           bcog=sqrt(1.-1./(gcog*gcog))
!old          DO II=1,NGOOD
!old           if(f(9,ii).eq.cstat(ist)) then
!old            gpai=f(7,ii)/xmat
!old            bpai=sqrt(1.-1./(gpai*gpai))
!old            fd(ii)=(gpai*bpai)/(gcog*bcog)
!old           endif
!old          enddo
!old         enddo
!old        return
!old        end
!> *******************************************************************
!! SUBROUTINE zrotat(zrot)
!! BEAM ROTATION
!!     the transverse coordinates X and Y may be rotated
!!     through an angle about the axis tangent to the
!!     central trajectory at the point in question.
!< *******************************************************************
       SUBROUTINE zrotat(zrot)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       common/faisc/f(10,iptsz),imax,ngood
       common/grot/rzot,izrot
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       logical izrot
       DIMENSION  RS(6,6),FF(6),FC(6)
       WRITE(16,100) ZROT
 100   FORMAT(/,20X,'BEAM ROTATION ',F10.4
     1 ,'  degrees  ABOUT THE POSITIVE Z-AXIS',/)
       if(.not.izrot) then
         izrot=.true.
         rzot=zrot
       else
         izrot=.false.
       endif
!  Daves start
       idav=idav+1
       iitem(idav)=20
       dav1(idav,1)=zrot
! initialize
       DO IA=1,4
         DO IB=1,4
           RS(IA,IB)=0.
         ENDDO
       ENDDO
!      Conversion DEG ==> RAD
       ZROT=  ZROT*pi/180.
       RS44  =  COS(ZROT)
       RS( 4,4 )  =    RS44
       RS( 3,3 )  =    RS44
       RS( 2,2 )  =    RS44
       RS( 1,1 )  =    RS44
       RS24     =  SIN(ZROT)
       RS( 2,4 )  =    RS24
       RS( 1,3 )  =    RS24
       RS( 4,2 )  =  - RS24
       RS( 3,1 )  =  - RS24
       DO II=1,ngood
         FF(1)=F(2,II)
         FF(2)=F(3,II)
         FF(3)=F(4,II)
         FF(4)=F(5,II)
         DO IA=1,4
           FC(IA)=0.
           DO IB=1,4
             FC(IA)=FC(IA)+FF(IB)*RS(IA,IB)
           ENDDO
         ENDDO
         F(2,II)=FC(1)
         F(3,II)=FC(2)
         F(4,II)=FC(3)
         F(5,II)=FC(4)
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE zrotap(zrot)
!! BEAM ROTATION
!!     the transverse coordinates X and Y may be rotated
!!     through an angle about the axis tangent to the
!!     central trajectory at the point in question.
!< *******************************************************************
       SUBROUTINE zrotap(zrot)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       common/grot/rzot,izrot
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       logical izrot
       DIMENSION  RS(6,6),FF(6),FC(6)
       WRITE(16,100) ZROT
 100   FORMAT(/,20X,'BEAM ROTATION ',F10.4
     1 ,'  degrees  ABOUT THE POSITIVE Z-AXIS',/)
       rzot=zrot
       RS( 1,2 )  =    0.
       RS( 1,4 )  =    0.
       RS( 2,1 )  =    0.
       RS( 2,3 )  =    0.
       RS( 3,2 )  =    0.
       RS( 3,4 )  =    0.
       RS( 4,1 )  =    0.
       RS( 4,3 )  =    0.
!      Conversion DEG ==> RAD
       ZROT=  ZROT*pi/180.
       RS44  =  COS(ZROT)
       RS( 4,4 )  =    RS44
       RS( 3,3 )  =    RS44
       RS( 2,2 )  =    RS44
       RS( 1,1 )  =    RS44
       RS24     =  SIN(ZROT)
       RS( 2,4 )  =    RS24
       RS( 1,3 )  =    RS24
       RS( 4,2 )  =  - RS24
       RS( 3,1 )  =  - RS24
       DO II=1,ngood
         FF(1)=F(2,II)
         FF(2)=F(3,II)
         FF(3)=F(4,II)
         FF(4)=F(5,II)
         DO IA=1,4
           FC(IA)=0.
           DO IB=1,4
             FC(IA)=FC(IA)+FF(IB)*RS(IA,IB)
           ENDDO
         ENDDO
         F(2,II)=FC(1)
         F(3,II)=FC(2)
         F(4,II)=FC(3)
         F(5,II)=FC(4)
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE aliner
!! ALIGNMENT  errors:
!!       HORIZONTAL : XL(cm) XLP(mrad)
!!       VERTICAL   : YL(cm) YLP(mrad)
!< *******************************************************************
       SUBROUTINE aliner
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/ALIN/XL,YL,XPL,YPL
       common/faisc/f(10,iptsz),imax,ngood
       WRITE(16,100) XL,YL,XPL,YPL
100    FORMAT(/,5X,' DISPLACEMENT x(cm)    y(cm)  : ',2(e12.5,2x),/,
     *          5X,' KICK        xp(mrad) yp(mrad): ',2(e12.5,2x),//)
!    CALCUL DES COORDONNEES DES TRAJECTOIRES
!       UNITES  =  CM-MRD
       DO II=1,ngood
         F(2,II)=F(2,II) + XL
         F(4,II)=F(4,II) + YL
         F(3,II)=F(3,II) + XPL
         F(5,II)=F(5,II) + YPL
       ENDDO
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE randali
!! RANDOM ALIGNMENT  errors :
!!     HORIZONTAL PLANE : XL(cm) XLP(mrad)
!!     VERTICAL PLANE   : YL(cm) YLP(mrad)
!< *******************************************************************
       SUBROUTINE randali
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/ALIN/XL,YL,XPL,YPL
       common/faisc/f(10,iptsz),imax,ngood
       common/apel/iapel
       dimension trans(1)
       write(16,*) ' random error in alignment with:'
       WRITE(16,100) XL,YL,XPL,YPL
100    FORMAT(/,5X,' KICK x(cm)    y(cm)   : ',2(e12.5,2x),/,
     *         5X,' KICK xp(mrad) yp(mrad): ',2(e12.5,2x),//)
       len=1
       rdcf=.5
       call rlux(trans,len)
       if(trans(1).le.rdcf) sign=-1.
       if(trans(1).gt.rdcf) sign=1.
       call rlux(trans,len)
       xla=xl*sign*trans(1)
       call rlux(trans,len)
       if(trans(1).le.rdcf) sign=-1.
       if(trans(1).gt.rdcf) sign=1.
       call rlux(trans,len)
       yla=yl*sign*trans(1)
       call rlux(trans,len)
       if(trans(1).le.rdcf) sign=-1.
       if(trans(1).gt.rdcf) sign=1.
       call rlux(trans,len)
       xpla=xpl*sign*trans(1)
       call rlux(trans,len)
       if(trans(1).le.rdcf) sign=-1.
       if(trans(1).gt.rdcf) sign=1.
       call rlux(trans,len)
       ypla=ypl*sign*trans(1)
       WRITE(16,100) XLA,YLA,XPLA,YPLA
       DO II=1,ngood
         f(2,ii)=f(2,ii)+xla
         f(4,ii)=f(4,ii)+yla
         f(3,ii)=f(3,ii)+xpla
         f(5,ii)=f(5,ii)+ypla
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE matrix
!! print first and second order matrix of a lens
!< *******************************************************************
       SUBROUTINE matrix
       implicit real(8) (a-h,o-z)
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       COMMON/SECDR/ISEOR
       LOGICAL ISEOR
       write(16,*) ' TRANSPORT MATRIX (m-rd)'
       write(16,*) ' FIRST ORDER TRANSPORT********'
       fprec=epsilon(T(1,1,1))
       DO IA=1,6
         write(16,100) (r(ia,ib),ib=1,6)
       ENDDO
100    format(6(3x,e12.5))
       write(16,*)   '**********************************************'
       IF(ISEOR) THEN
         write(16,*) '******* SECOND ORDER TRANSPORT (m-rd) ********'
         DO IA=1,6
           DO IB=1,6
             DO IC=1,6
!               IF(T(IA,IB,IC).NE.0.)WRITE(16,101)IA,IB,IC,T(IA,IB,IC)
               IF(abs(T(IA,IB,IC)).gt.fprec)
     X            WRITE(16,101)IA,IB,IC,T(IA,IB,IC)
             ENDDO
           ENDDO
         ENDDO
         write(16,*) '**********************************************'
       ENDIF
101    format(' T',3(i1),3x,e12.5)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE egun(fmult,indp)
!! method:Bode's rule
!! read the axial field of the DC gun field from disk
!!     z (m)   E(z) is normalized
!< *******************************************************************
       SUBROUTINE egun(fmult,indp)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/ vl,pi, xmat,rpel,qst
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/DYN/TREF,VREF
       COMMON/RIGID/BORO
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/femt/iemgrw,iemqesg
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/dcspa/iesp
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       dimension gam(3000),xe(3000),xpe(3000),ye(3000),ype(3000)
       logical flgsc,iesp,ichaes,iemgrw
!    print out on terminal of transport element # on one and the same line
       nrres=nrres+1
       call PROGRESS(NRTRE,NRRES)
       write(6,'(A)') 'EGUN calculation started'
!  energy at the entrance
       we=0.
       e0=xmat
       do i=1,ngood
         we=we+f(7,i)
         tref=tref+f(6,ij)
       enddo
       tref=tref/float(ngood)
       tcgprt=fh*tref*180./pi   
       we=we/float(ngood)
       gref=we/e0
       we=we-xmat
       bets=sqrt(1.-1./(gref*gref))
!  indp: define the number of space charge computations
!   indp = 1 : 8 space charge computations. The EGUN field is divided in 16 elements
!   indp = 2 : 16 space charge computation.                           in 32 elements
!   indp = 3 : 32 space charge computation.                           in 64 elements
       if(indp.gt.3) indp=3
       if(indp.eq.1) ipart=16
       if(indp.ge.2) ipart=32
       if(indp.eq.3) ipart=64
! research the number of steps w.r.t. the input energy
!    convert energy: MeV --> eV
       we=we*1.e06
       weinf=19.99
       if(we.le.weinf) then
         write(ierr,*) ' Energy at the cathode: ',we,
     *             ' eV is below the lower limit of 20 eV '
         stop
       endif
!    read egun field on the disk
       vlm=vl*1.e-02
       read(22,*)npt
       do i=1,npt
         read(22,*) xspl(i),yspl(i)
       enddo
       zinf=xspl(1)
       zsup=xspl(npt)
       egl=zsup-zinf
       call deriv2(npt)
       elgun=egl*100.
!      PLOT
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
!  start prints in file 'short.data'
       idav=idav+1
       idavs=idav
       iitem(idav)=13
       dav1(idav,1)=egl*1000.
       dav1(idav,2)=fmult
       davtot=davtot+elgun
       dav1(idav,4)=elgun*10.
!    divide the length in ipart partitions
!    the space charge computations are made at the middle of each partition
       eglp=egl/float(ipart)
!      eglsc :space charge acting length (cm)  (of each part)
       scl=float(ipart)/2.
       eglsc=egl*100./scl
!    compute the EGUN field (MV)
       npas=200
!       xpas=eglp/float(npas)
       xpas=egl/float(npas)
       xnhf=0
       dcfld=0.
       do i=1,npas
         fpos=xnhf*xpas
         tspl=spline(npt,fpos)*fmult
         dcfld=dcfld+qst*tspl*xpas
         xnhf=xnhf+1.
       enddo
!4443   format(2x,i5,3(2x,e12.5))
       dav1(idav,3)=dcfld*1000.
       write(16,101) elgun,fmult,dcfld*1000.
!       write(16,101) elgun,fmult
101    FORMAT(5X,'  FIELD LENGTH  = ',F9.4,'      cm ',/,
     x  5x,'  FIELD CREST   =',F10.4,'      MV/m',/,
     x  5x,'  FIELD INTEGRAL=  ',E13.5,' kV',/)
!omment       write(49,5557)
!omment5557   format(6x,'z(m)',14x,'x(m)',14x,'xp(rad)',11x,'y(m)',14x,
!omment     *        'yp(rad)',11x,'energy(MeV)')
! **** demarrage sur 0.5 mm (?) soit 0.5 e-03 m
!     thresold of energy
       swe1=19.99
       swe2=79.99
       npas=200
       if(we.lt.swe1) npas=400
       if(we.lt.swe2) npas=300
       xlstart=0.5e-03
       xpas=xlstart/float(npas)
       npas1=npas+1
       iflg=-1
       xnht=0.
       flgsc=.false.
       idum=0
       dum=0.
       trnsms=100.*float(ngood)/float(imax)
       write(50,*) '# egun.dmp'
       write(50,*) '# egun    Z       trans   ',
     *   'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ',
     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
     *   'El,RMS        dWref       EffVolt'
       write(50,*) '#  #     (m)       (%)  ',
     *  '(not used)  (deg)        beta     (MeV)          (deg)      ',
     *  '   beta        (MeV)      (mm.mrad)    (mm.mrad)    ',
     *  '(ns.keV)      (MeV)        (not used)'
!       write(50,7023) idum,0.01*(davtot-elgun),trnsms,dum,tcgprt,
!     *  bets,we/1.E6,tcgprt,bets,we/1.E6,
!     *  0.25*dav1(idav,16),0.25*dav1(idav,21),dum,dum,dum
       DO       
         if(iflg.eq.ipart) EXIT
         do j=1,ngood
           xnh=xnht
           qc=f(9,j)
           gam0=f(7,j)/e0
           gam(1)=gam0
           tof=f(6,j)
!       the tranverse coordinates are converted to (m,rad)
           x0=f(2,j)*1.e-02
           y0=f(4,j)*1.e-02
           t0=f(3,j)*1.e-03
           p0=f(5,j)*1.e-03
!       Picht transformation
           xe0=x0*(gam0*gam0-1.)**0.25
           xpe0=t0*(gam0*gam0-1.)**0.25
           ye0=y0*(gam0*gam0-1.)**0.25
           ype0=p0*(gam0*gam0-1.)**0.25
           fpos=xnh*xpas
           tspl=spline(npt,fpos)*fmult
           dgam=(qc/e0)*tspl
           dgami=dgam
           xpe0=xpe0+.5*xe0*gam0*dgam/(gam0*gam0-1)
           ype0=ype0+.5*ye0*gam0*dgam/(gam0*gam0-1)
           a1=qc*qc/(4.*e0*e0)
           a2=qc/(e0*vlm)
           xe(1)=xe0
           xpe(1)=xpe0
           ye(1)=ye0
           ype(1)=ype0
           do i=2,npas1
             i1=i-1
             fpos1=xnh*xpas
             fpos2=(xnh+0.25)*xpas
             fpos3=(xnh+0.5)*xpas
             fpos4=(xnh+0.75)*xpas
             fpos5=(xnh+1.)*xpas
             tspl1=spline(npt,fpos1)*fmult
             tspl2=spline(npt,fpos2)*fmult
             tspl3=spline(npt,fpos3)*fmult
             tspl4=spline(npt,fpos4)*fmult
             tspl5=spline(npt,fpos5)*fmult
             cw=(qc/e0)*xpas/90.
             tspl=7.*tspl1+32.*tspl2+12.*tspl3+32.*tspl4+7.*tspl5
             gam(i)=cw*tspl+gam(i1)
             gam1=gam(i1)
             gam5=gam(i)
             dgam1=(qc/e0)*tspl1
             cof1=(gam5-gam1)/(xpas*xpas)
             cof2=dgam1/xpas
             cof=cof1-cof2
             gam2=gam1+dgam1*xpas/4.+cof*xpas*xpas/16.
             gam3=gam1+dgam1*xpas*0.5+cof*xpas*xpas/4.
             gam4=gam1+dgam1*xpas*0.75+cof*9.*xpas*xpas/16.
             gams1=gam1*gam1
             gams2=gam2*gam2
             gams3=gam3*gam3
             gams4=gam4*gam4
             gams5=gam5*gam5
!omment          bgt1=(gams1-1.)**1.5
             bgt2=(gams2-1.)**1.5
             bgt3=(gams3-1.)**1.5
             bgt4=(gams4-1.)**1.5
             bgt5=(gams5-1.)**1.5
             tslpt=8.*tspl2/bgt2+6.*tspl3/bgt3+24.*tspl4/bgt4
     *          +7.*tspl5/bgt5
             dt=a2*xpas*xpas*tslpt/90.
             bet=sqrt(1.-1./gams1)
             tof=tof+xpas/(vlm*bet)+dt
             f(7,j)=gam(i)*e0
             f(6,j)=tof
             bg1=(gams1+2.)/((gams1-1.)*(gams1-1.))
             bg2=(gams2+2.)/((gams2-1.)*(gams2-1.))
             bg3=(gams3+2.)/((gams3-1.)*(gams3-1.))
             bg4=(gams4+2.)/((gams4-1.)*(gams4-1.))
             bg5=(gams5+2.)/((gams5-1.)*(gams5-1.))
             bgts1=bg1*tspl1*tspl1
             bgts2=bg2*tspl2*tspl2
             bgts3=bg3*tspl3*tspl3
             bgts4=bg4*tspl4*tspl4
             bgts5=bg5*tspl5*tspl5
!            gtpm=bgts1+3.*bgts2+3.*bgts3+bgts4
             gtpm=7.*bgts1+32.*bgts2+12.*bgts3+32.*bgts4+7.*bgts5
!                      gtm=bgts1+2.*bgts2+bgts3
             gtm=7.*bgts1+24.*bgts2+6.*bgts3+8.*bgts4
!                 gtpz=bgts2+2.*bgts3+bgts4
             gtpz=8.*bgts2+6.*bgts3+24.*bgts4+7.*bgts5
             gtm1=2.*bgts2+3.*bgts3+18.*bgts4+7.*bgts5
             de=-a1*xpas*xpas*gtm/90.
             de1=-a1*xpas*xpas*xpas*gtm1/90.
             dpe1=-a1*xpas*gtpm/90.
             dpe2=-a1*xpas*xpas*gtpz/90.
             dxpe1=dpe1*xe(i1)
             dype1=dpe1*ye(i1)
             dxpe2=dpe2*xpe(i1)
             dype2=dpe2*ype(i1)
             dxe=de*xe(i1)+de1*xpe(i1)
             dye=de*ye(i1)+de1*ype(i1)
             xpe(i)=xpe(i1)+dxpe1+dxpe2
             ype(i)=ype(i1)+dype1+dype2
             xe(i)=xe(i1)+dxe+xpe(i1)*xpas
             ye(i)=ye(i1)+dye+ype(i1)*xpas
!       back to the real variables and convert to (cm,mrad)
             gamm1=(gams5-1.)**0.25
             gamm2=(gams5-1.)**1.25
             dgam=(qc/e0)*tspl5
             xi=xe(i)/gamm1
             xpi=xpe(i)/gamm1-xe(i)*gam(i)*dgam/(gamm2*2.)
             yi=ye(i)/gamm1
             ypi=ype(i)/gamm1-ye(i)*gam(i)*dgam/(gamm2*2.)
!      convert in cm and mrd
             f(2,j)=xi*1.e02
             f(4,j)=yi*1.e02
             f(3,j)=xpi*1.e03
             f(5,j)=ypi*1.e03
!    *****  follow prtcl ifpt  not active ************
!omment          if(j.eq.ifpt)
!omment     *    write(49,4445) fpos5,xi,xpi,yi,ypi,e0*(gam5-1.)
!omment4445      format(6(2x,e12.5))
             xnh=xnh+1.
           enddo
         enddo
         iflg=iflg+1
         xnht=xnh
         if(iflg.eq.0) then
           if(indp.eq.1) npas=96
           if(indp.eq.2) npas=48
           if(indp.eq.3) npas=24
           npas1=npas+1
           xlres=egl-xlstart
           xpas=xlres/(float(npas)*float(ipart))
           xnht=fpos5/xpas
           flgsc=.true.
           dav1(idavs,7)=tspl5
           dav1(idav,5)=xlstart*1000.
           call disp
           cycle
         endif
         if(iflg.eq.1) then
           if(indp.eq.1) npas=48
           if(indp.eq.2) npas=24
           if(indp.eq.3) npas=12
           npas1=npas+1
           xlres=egl-xlstart
           xpas=xlres/(float(npas)*float(ipart))
           xnht=fpos5/xpas
         endif
         if(.not.flgsc) then
           flgsc=.true.
           call disp
           cycle
         endif
         if(flgsc) then
           if(ichaes) then
!     Space charge
             iesp=.true.
             call cesp(eglsc)
             iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           endif
           call disp
           flgsc=.false.
!    reference ( c.o.g. of the bunch)
           tref=0.
           gref=0.
           do ij=1,ngood
             tref=tref+f(6,ij)
             gref=gref+f(7,ij)/e0
           enddo
           tref=tref/float(ngood)
           gref=gref/float(ngood)
           bets=sqrt(1.-1./(gref*gref))
           vref=bets*vl
!omment    call emiprt(0)
           write(16,562) fpos5*1000,tref,bets,tspl5
           write(6,1562,advance='no') fpos5*1000,bets,cr
562        format(' ref.(c.o.g.) at ',e12.5,' mm of the  cathode',/,
     * 5x,' tof: ',e12.5,' sec beta: ',e12.5,' field (MV/m) ',e12.5)
1562       format(' EGUN: at ',e12.5,' mm from the cathode; beta: ',
     *     e12.5,a1)
         endif
       ENDDO
       write(6,*)
       write(6,*) 'EGUN calculation finished'
! Test window 
       call cogetc
       PRTLAB='EGUN    '
       call reject(ilost,PRTLAB)
       write(16,*)'particles lost :',ilost
       write(16,*) 'EGUN calculation finished'
!    reference ( c.o.g. of the bunch)
       tref=0.
       gref=0.
       do i=1,ngood
         tref=tref+f(6,i)
         gref=gref+f(7,i)/e0
       enddo
       tref=tref/float(ngood)
       gref=gref/float(ngood)
       bets=sqrt(1.-1./(gref*gref))
       write(16,561) tref,bets
561    format(' Reference at output of the DC gun',/,
     *        5x,' tof: ',e12.5,' sec beta: ',e12.5)
       vref=bets*vl
       WREF=XMAT*(gref-1.)
!      new magnetic rigidity of the reference
       xmor=xmat*bets*gref
       boro=33.356*xmor*1.e-01/qst
       dav1(idavs,6)=bets
       dav1(idavs,36)=ngood
      
!   plots
       PRLAB(IPRF)='EGUN    '
       CALL STAPL(davtot*10.)
       call emiprt(0)
! egun number (set to 1), z(m), transmission (%), synchronous phase (deg), time of flight (deg) (cog), COG relativistic beta (@ output)
! COG output energy (MeV), time of flight (deg) (REF), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
       trnsms=100.*float(ngood)/float(imax)
       idum=1
       dum=0.
       tcgprt=fh*tref*180./pi   
       emns=(1.E12)*dav1(idav,12)/fh
       delwrm=wref-we/1.E6    
       write(50,7023) idum,0.01*davtot,trnsms,dum,tcgprt,
     *  bets,wref,tcgprt,bets,wref,
     *  0.25*dav1(idav,16),0.25*dav1(idav,21),0.25*emns,delwrm,dum
7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
     *   2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x))
       write(50,*) '# '
       return
       end
!> *******************************************************************
!! SUBROUTINE cpardyn(pib)
!! --- make up a list of cell by cell RFQ data based on a file
!!     generated by the external code
!!
!!     nc: cell number
!!     ityp = 0: Standard accelerating cell
!!     ityp = 1: Transition cell of type T
!!     ityp = 2: Transition cell of type E
!!     ityp = 3: Transition cell of type M
!!     ityp = 4: Fringe-field region from the potential function
!!               (after type T, M or accelerating cell)
!!     ityp = 5: Radial matching section based on coefficients
!!     ityp = 6: Radial matching section based on RMS shape defined in
!!               an external file
!!     ityp = 7: Fringe-field region; the profile is defined in an
!!               external file (after type T, M or accelerating cell)
!!     a(1): cell length (cm)
!!     a(2): coefficient A10 (no dimension)
!!     a(3): smallest aperture  a  of vanes (cm)
!!     a(4): modulation factor  m  (no dimension)
!!     a(5): mean aperture ( r0 ) of vanes (middle of cells)   (cm)
!!     a(6): transverse radius of curvature (rh0) of the surface of
!!           electrodes at the vane tip (cm)
!!     a(7): phase (deg) (at the entrance of cells)
!!     a(8): factor FVOLT to be applied at the intervane potential
!!           (only for particles)
!!              VOLT =  (1 + FVOLT )* (intervane voltage)
!!     a(9): intervane-voltage (KV)
!!
!!     ipar: cell parity (like for PARMTEQ cells)
!! --- Note: the last line in file must be:
!!           0  0  0. 0. 0. 0. 0. 0. 0. 0. 0. 0
!< *******************************************************************
       SUBROUTINE cpardyn(pib)
       implicit real(8) (a-h,o-z)
       common/tapes/in,ifile,meta,ierr
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/rf1ptq/tvolt,avolt,fph,mlc,nceltot
       common/rf2ptq/rfq1(500),rfq2(500),rfq3(500),rfq4(500),rfq6(500)
     *        ,rfq7(500),rfq8(500),rfq9(500)
       common/rf5ptq/tdvolt,rfq10(500),rfq11(500)
       common/rfq3ptq/itype(500),ipari(500),evens,evenr
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       common/bonda/cbx(500),bbx(500),ablx(500),cby(500),
     *        bby(500),ably(500)
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/spff/xspf(400),yspf(400),sf(500),pf(500),qf(500)
       common/rms_prfl/npt,npf
       common/paths/dpath
       character*(256) dpath,myfile       
       dimension a(16),vptq(16)
       character vprof*80,fprof*80
       logical even,evens,evenr
       myfile=''
       fprec=epsilon(erest)
!  Do so by shifting particles belonging to the same bunch outside the (+/-) pib (rad) window
!   w.r.t.the REF to inside the (+/-) pib window w.r.t.the COG
       if(abs(pib) .gt. 0.) then
         pib=pi
         call accep_rfq(pib)
       endif
       erest=xmat
! --- for simulating PARMTEQ cells, odd cells have A01 positive and even cells have A01 negative
! ---  even: logical flag, even = true ==> A01 is positive, otherwise A01 is negative
       even=.true.
       netc=0
! do loop on reading and prepping cell data       
       DO
! --- read the data of the RFQ from the input file
! ****************************************************************
! ---   read 11 parameters from unit 27, file 'myfile', in the form:
!      nc  ityp intervane-voltage (kV) cl(cm)  A10  a(cm)  m  r0(cm) rho(cm) phase(deg) fvolt ipar
       netc=netc+1
       read(27,*) nc,ityp,(vptq(j),j=1,9),ipar
       if(ityp.eq.6) then
! if the RMS is of type 6, get the filename of the RMS descriptor
         read(27,'(A80)') vprof
         write(16,*) 'Read RMS from file ',vprof
       endif
       if(ityp.eq.7) then
! if the Fringe Field is of type 7, get the filename of the FF descriptor
         read(27,'(A80)') fprof
         write(16,*) 'Read Fringe Field from file ',fprof
       endif
       a(1)=vptq(2)
       a(2)=vptq(3)
       a(3)=vptq(4)
       a(4)=vptq(5)
       a(5)=vptq(6)
       a(6)=vptq(7)
       a(7)=vptq(8)
       a(8)=vptq(9)
       a(9)=vptq(1)
! **************************************************
! convert intervane voltage in MV
       a(9)=a(9)*1.e-03
       if(nc.eq.1) tdvolt=a(9)
! ----  stop at the last line with nc = 0
       if(nc.eq.0) exit
       if(nc.gt.nceltot) exit
       itype(nc)=ityp
       ipari(nc)=ipar
! ------------
! ITYPE 5    !
! ------------
       if(itype(nc).eq.5) then
! Radial matching section from potential function
! ---------------------------------------------------------------------------------------------
! Note: The total length L(rms) of the RMS must be the sum of the RMS-cell lengths in the
!       Parmteq file. rho is equal to the distance between the axis and the vane, r0, at the
!       exit of the RMS
!       we have used the approximation of the modified Bessel functions for small arguments
!       and we have negleted the terms of higher order in r greater than 2
! ----------------------------------------------------------------------------------------------
         write(16,*) 'RFQ RMS from potential function'
         cl=a(1)
         r0=a(5)
         rh0=a(6)
         phim=a(7)
         fact=1.+a(8)
         xk=pi/(2.*cl)
         xq0=1./6.*xk*xk*rh0*rh0
         aq=1./xq0
! ---   limits x-vane y-vane
         cbx(nc)=1.5*r0*1.e-02
         cby(nc)=1.5*r0*1.e-02
         ablx(nc)=0.
         ably(nc)=0.
         bbx(nc)=0.
         bby(nc)=0.
! ---  convert all parameters in units (MeV, m)
!     rfq1(nc): Aq (no dimension)
!     rfq2(nc): not used
!     rfq3(nc): RMS length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!     rfq10(nc):intervane voltage applied to the synchronous particle (kV)
!     rfq11(nc):intervane voltage applied to the particles (kV)
!
         rfq1(nc)=aq
         rfq2(nc)=0.
         rfq3(nc)=cl*1.e-02
         rfq4(nc)=phim
         rfq7(nc)=r0*1.e-02
         rfq9(nc)=fact
         rfq10(nc)=(1.+tvolt)*a(9)
         rfq11(nc)=(1.+avolt)*a(9)
       elseif(itype(nc).eq.6) then
! ------------
! ITYPE 6    !
! ------------
!  read from disk the RMS profile in the form (z,R(z)), with z,R in meter
!  npt is the number of (z,R(z)) coordinates
         myfile(1:80)=vprof
         lpath=LEN_TRIM(dpath)
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
!         write(16,*) 'RFQ RMS from file: ',myfile
         open(67,file=myfile,status='unknown')
         npt=0
         do
           read(67,*,END=777) xspl(npt+1),yspl(npt+1)
           npt=npt+1
         enddo
777      write(16,*) 'RFQ RMS from file with ',npt,' data points'
         call deriv2(npt)
! cl; length of the RMS (in M)
         cl=xspl(npt)
         r0=yspl(npt)
         phim=a(7)
         fact=1.+a(8)
! ---   limits x-vane y-vane
         cbx(nc)=1.5*r0
         cby(nc)=1.5*r0
         ablx(nc)=0.
         ably(nc)=0.
         bbx(nc)=0.
         bby(nc)=0.
!     rfq1(nc) : not used
!     rfq2(nc): not used
!     rfq3(nc): RMS length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): distance axe-vanes at the end of the RMS (m)
!     rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!     rfq10(nc):intervane voltage applied to the synchronous particle (kV)
!     rfq11(nc):intervane voltage applied to the particles (kV)
!       rfq1(nc)=0.
        rfq2(nc)=0.
        rfq3(nc)=cl
        rfq4(nc)=phim
        rfq7(nc)=r0
        rfq9(nc)=fact
        rfq10(nc)=(1.+tvolt)*a(9)
        rfq11(nc)=(1.+avolt)*a(9)
        close(67)
!cc        write(16,579)nc,npt,cl,phim,r0,rfq10(nc),rfq11(nc)
!cc579     format(2(2x,i4),5(2x,e12.5))
!  End Radial matching section
       elseif(itype(nc).eq.0) then
! ------------
! ITYPE 0    !
! ------------
! --- Standard accelerating cell
        cl=a(1)
        a10=a(2)
        xa=a(3)
        xm=a(4)
        r0=a(5)
        rh0=a(6)
! fph : factor affecting the phase at entrance of cells (only available for type = 0)
        a(7)=fph*a(7)
        phim=a(7)
        fact=1.+a(8)
!    coefficient A01 (1/(cm*cm))
        alpha=rh0/r0
        a01=3.*(1.+5.*alpha)/(2.*r0*r0*(1.+7.*alpha))
!    coefficient A03: (1/(cm**6) )
        a03=-(1.+alpha)/(2.*r0**6*(1.+7.*alpha))
!  coefficient A12: no dimensions
        xam=xa*xm
        a12=0.
        xk1=1.-a01*xa*xa-a03*(xa**6)
        yk2=-1.+a01*xam*xam+a03*(xam**6)
!   Bessel functions: I0(ka) I0(mka) I4(ka) I4(mka)
        xk=pi/cl
        za0=xk*xa
        zam=za0*xm
        no=0
        bi0=bint(no,za0)
!old        bi0=1.+za0*za0/4.+za0**4/64.+za0**6/2304.+za0**8/1.47456e05
!old        bi0=bi0+za0**10/1.47456e07
        bim=bint(no,zam)
!old        bim=1.+zam*zam/4.+zam**4/64.+zam**6/2304.+zam**8/1.47456e05
!old        bim=bim+zam**10/1.47456e07
        no=4
        bi4=bint(no,za0)
!old        bi4=(za0/2.)**4/24.
!old        zaa0=za0*za0/4.
!old        bi4=bi4+(za0/2.)**4*zaa0/120.
!old        bi4=bi4+(za0/2.)**4*zaa0*zaa0/1440.
        bim4=bint(no,zam)
!old        zamm=zam*zam/4.
!old        bim4=(zam/2.)**4/24.
!old        bim4=bim4+(zam/2.)**4*zamm/120.
!old        bim4=bim4+(zam/2.)**4*zamm*zamm/1440.
        den1=bim4*bi0-bim*bi4
        if(abs(den1).gt.1.e-09) a12=(yk2*bi0-xk1*bim)/den1
! ********************************************************************************************
! NOTE: the coefficient A10 is read in the file 'myfile' but it also can be computed in Dynac
!        from multipolar expansions (see the two following fortran lines):
!cc        a10=0.
!cc        if(abs(den1).gt.1.e-09) a10=(xk1*bim4-yk2*bi4)/den1
! ************************************
!        or from first order computations (see the two following lines):
!cc        dencc=xm*xm*bi0+bim
!cc        a10=(xm*xm-1.)/dencc
! ********************************************************************************************
! ---  convert all parameters in units (MeV, m)
!     rfq1(nc): A01 ( 1/(m*m) )
!     rfq2(nc): A10 (no dimension)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq6(nc): A12 (no dimension)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq8(nc): A03 (1/(m**6)
!     rfq9(nc): error factor F = 1 + a(8)
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
! ---  odds cells have a01 positive, even cells have a01 negative
!
        rfq1(nc)=a01*1.e04
! ---  limits x-vane y-vane
        ncf=(ipari(nc)/2)*2-ipari(nc)
        if(ncf.ne.0) then
!  odd number standard cell limits
         cbx(nc)=xa
         bbx(nc)=(4.*r0-xm*xa-3.*cbx(nc))/cl
         ablx(nc)=xa*xm/(cl*cl)-bbx(nc)/cl-cbx(nc)/(cl*cl)
         cby(nc)=xa*xm
         bby(nc)=(4.*r0-xa-3.*cby(nc))/cl
         ably(nc)=xa/(cl*cl)-bby(nc)/cl-cby(nc)/(cl*cl)
        else
!  even number standard cell limits
         cbx(nc)=xm*xa
         bbx(nc)=(4.*r0-xa-3.*cbx(nc))/cl
         ablx(nc)=xa/(cl*cl)-bbx(nc)/cl-cbx(nc)/(cl*cl)
         cby(nc)=xa
         bby(nc)=(4.*r0-xm*xa-3.*cby(nc))/cl
         ably(nc)=xm*xa/(cl*cl)-bby(nc)/cl-cby(nc)/(cl*cl)
        endif
!   conversion: cm --> m
        cbx(nc)=cbx(nc)*1.e-02
        ablx(nc)=ablx(nc)*1.e02
        cby(nc)=cby(nc)*1.e-02
        ably(nc)=ably(nc)*1.e02
!  end limits ******************************
        rfq2(nc)=a10
        rfq3(nc)=cl*1.e-02
        rfq4(nc)=phim
        rfq6(nc)=a12
        rfq7(nc)=r0*1.e-02
        rfq8(nc)=a03*1.e12
        rfq9(nc)=fact
        rfq10(nc)=(1.+tvolt)*a(9)
        rfq11(nc)=(1.+avolt)*a(9)
!  endif of itype(nc) = 0 (accelerating cell)
      elseif(itype(nc).eq.1) then
! ------------
! ITYPE 1    !
! ------------
! ------ T-cell(ityp = 1) (must follow a standard cell and be followed by an M-cell or by fringe-field region)
        cl=a(1)
        xa=a(3)
        xm=a(4)
        r0=a(5)
        phim=a(7)
        fact=1.+a(8)
        xk=pi/(2.*cl)
        za0=xk*xa
        zam=za0*xm
!   Bessel functions
        no=0
        bi0=bint(no,za0)
        bim=bint(no,zam)
        bi3=bint(no,3.*za0)
        bim3=bint(no,3.*zam)
!   coefficients A10 and A30 (no dimensions)
        t10k=xm*xm*bi0+bim
        t30k=xm*xm*bi3+bim3
        zr0=xk*r0
        zr3=3.*zr0
        bir0=bint(no,zr0)
        bir3=bint(no,zr3)
        alpk=0.
!        if(abs(bir3).ne.6.*0.) alpk=bir0/bir3
        if(abs(bir3).gt.fprec) alpk=bir0/bir3
        dtk=t10k+alpk*t30k/3.
        a10=0.
!        if(abs(dtk).ne.6.*0.) a10=(xm*xm-1.)/dtk
        if(abs(dtk).gt.fprec) a10=(xm*xm-1.)/dtk
        a30=alpk*a10/3.
! -- limits x-vane  y-vane
        cbx(nc)=xm*xa
        bbx(nc)=(4.*r0-xa-3.*cbx(nc))/(2.*cl)
        ablx(nc)=xa/(4.*cl*cl)-bbx(nc)/(2.*cl)-cbx(nc)/(4.*cl*cl)
        cby(nc)=xa
        bby(nc)=(4.*r0-xm*xa-3.*cby(nc))/(2.*cl)
        ably(nc)=xm*xa/(4.*cl*cl)-bby(nc)/(2.*cl)-cby(nc)/(4.*cl*cl)
!   conversion: cm --> m
        cbx(nc)=cbx(nc)*1.e-02
        ablx(nc)=ablx(nc)*1.e02
        cby(nc)=cby(nc)*1.e-02
        ably(nc)=ably(nc)*1.e02
!  end limits ******************************
! ---  convert all parameters in units (MeV, m)
!     rfq1(nc): A30 (no dimension)
!     rfq2(nc): A10 (no dimension)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
!
        rfq1(nc)=a30
        rfq2(nc)=a10
        rfq3(nc)=cl*1.e-02
        rfq4(nc)=phim
        rfq7(nc)=r0*1.e-02
        rfq9(nc)=fact
        rfq10(nc)=(1.+tvolt)*a(9)
        rfq11(nc)=(1.+avolt)*a(9)
!  endif for T-cell
      elseif(itype(nc).eq.2) then
! ------------
! ITYPE 2    !
! ------------
! --- E-cell(itype = 2) must follow a RMS and be folllowed by an even standard cell
        cl=a(1)
        xa=a(3)
        xm=a(4)
        r0=a(5)
        a(7)=fph*a(7)
        phim=a(7)
        fact=1.+a(8)
        xk=pi/(2.*cl)
        za0=xk*xa
        zam=za0*xm
        xam=xa*xm
!   Bessel functions
        no=0
        bi0=bint(no,za0)
        bim=bint(no,zam)
        bi3=bint(no,3.*za0)
        bim3=bint(no,3.*zam)
!   coefficients A10 and A30 (no dimensions)
        t10k=xm*xm*bi0+bim
        t30k=xm*xm*bi3+bim3
        zr0=xk*r0
        zr3=3.*zr0
        bir0=bint(no,zr0)
        bir3=bint(no,3.*zr3)
        alpk=0.
!        if(abs(bir3).ne.6.*0.) alpk=bir0/bir3
        if(abs(bir3).gt.fprec) alpk=bir0/bir3
        dtk=t10k+alpk*t30k/3.
        a10=0.
!        if(abs(dtk).ne.6.*0.) a10=(xm*xm-1.)/dtk
        if(abs(dtk).gt.fprec) a10=(xm*xm-1.)/dtk
!old   E-cell is a even cell number (followed by a odd number standard cell
!old        ncf=(nc/2)*2-nc
!old        if(ncf.eq.0) a10=-a10
        a30=-alpk*a10/3.
!  cell limits x-vane y-vane
        cbx(nc)=r0
        bbx(nc)=(xm*xa-r0)/cl
        ablx(nc)=0.
        cby(nc)=r0
        bby(nc)=(xa-r0)/cl
        ably(nc)=0.
!   conversion: cm --> m
         cbx(nc)=cbx(nc)*1.e-02
         cby(nc)=cby(nc)*1.e-02
! ---  convert in units (MeV, m)
!     rfq1(nc): A30 (no dimensions)
!     rfq2(nc): A10 (no dimensions)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor applied at the inter-vane potentiel
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
        rfq1(nc)=a30
        rfq2(nc)=a10
        rfq3(nc)=cl*1.e-02
        rfq4(nc)=phim
        rfq7(nc)=r0*1.e-02
        rfq9(nc)=fact
        rfq10(nc)=(1.+tvolt)*a(9)
        rfq11(nc)=(1.+avolt)*a(9)
      elseif(itype(nc).eq.3) then
! ------------
! ITYPE 3    !
! ------------
!   M-cell  (ityp = 3)
        cl=a(1)
        xa=a(3)
        xm=a(4)
        r0=a(5)
        phim=a(7)
        fact=1.+a(8)
!  cell limits x-vane = y-vane = average radius
        cbx(nc)=r0
        bbx(nc)=0.
        ablx(nc)=0.
        cby(nc)=r0
        bby(nc)=0.
        ably(nc)=0.
!   conversion: cm --> m
        cbx(nc)=cbx(nc)*1.e-02
        cby(nc)=cby(nc)*1.e-02
!  end vanes limits ******************************
! ---  convert the parameters in units (MeV, m)
!     rfq1(nc): A30 = 0
!     rfq2(nc): A10 = 0
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor applied at the inter-vane potentiel(F = 1 + a(15))
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)c
        rfq1(nc)=0.
        rfq2(nc)=0.
        rfq3(nc)=cl*1.e-02
        rfq4(nc)=phim
        rfq7(nc)=r0*1.e-02
        rfq9(nc)=fact
        rfq10(nc)=(1.+tvolt)*a(9)
        rfq11(nc)=(1.+avolt)*a(9)
! endif M-cell
       elseif(itype(nc).eq.4) then
! ------------
! ITYPE 4    !
! ------------
!   Fringe-field region after T-cell or M-cell  (Type = 4)
        cl=a(1)
        a10=a(2)
        xa=a(3)
        xm=a(4)
        r0=a(5)
        rh0=a(6)
        phim=a(7)
        fact=1.+a(8)
!  fringe field region limits
        cbx(nc)=r0*1.5
        bbx(nc)=0.
        ablx(nc)=0.
        cby(nc)=r0*1.5
        bby(nc)=0.
        ably(nc)=0.
!   conversion: cm --> m
        cbx(nc)=cbx(nc)*1.e-02
        cby(nc)=cby(nc)*1.e-02
!  end limits ******************************
! ---  convert the parameters in units (MeV, m)
!     rfq1(nc): A01 ( 1/(m*m) )
!     rfq2(nc): A10 (no dimensions)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor applied at the inter-vane potentiel (F = 1 + a(15))
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
!old        rfq1(nc)=a01*1.e04
        rfq2(nc)=a10
        rfq3(nc)=cl*1.e-02
        rfq4(nc)=phim
        rfq7(nc)=r0*1.e-02
        rfq9(nc)=fact
        rfq10(nc)=(1.+tvolt)*a(9)
        rfq11(nc)=(1.+avolt)*a(9)
       elseif(itype(nc).eq.7) then
! ------------
! ITYPE 7    !
! ------------
!  fringe field region the profil is read from disk
!  read the ff profile in the form (z,R(z)) in M
!    npt is the number of coordinates (z,R(z)
         myfile(1:80)=fprof
         lpath=LEN_TRIM(dpath)
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
!         write(16,*) 'RFQ FF from file: ',myfile
         open(67,file=myfile,status='unknown')
         npf=0
         do
           read(67,*,END=888) xspf(npf+1),yspf(npf+1)
           npf=npf+1
         enddo
888      write(16,*) 'RFQ FF from file with ',npf,' data points'
         reca=xspf(1)
         do i=1,npf
           xspf(i)=xspf(i)-reca
         enddo
! length of the fringe field  m
         cl=xspf(npf)
         call derif2(npf)
         phim=a(7)
         fact=1.+a(8)
         write(16,*) 'Fringe Field length=',cl,' m'
         write(16,*) 'Fringe Field Phase=',phim
         write(16,*) 'Fringe Field Field Factor=',fact
! ---   limits x-vane y-vane
         cbx(nc)=100.
         cby(nc)=100.
         ablx(nc)=0.
         ably(nc)=0.
         bbx(nc)=0.
         bby(nc)=0.
!     rfq1(nc) : not used
!     rfq2(nc): not used
!     rfq3(nc): Fringe field length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): distance axe-vanes at the start of the FF (m)
!     rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
        rfq1(nc)=0.
        rfq2(nc)=0.
        rfq3(nc)=cl
        rfq4(nc)=phim
        rfq7(nc)=r0
        rfq9(nc)=fact
        rfq10(nc)=(1.+tvolt)*a(9)
        rfq11(nc)=(1.+avolt)*a(9)
        close(67)
!cc        write(16,579)nc,npt,cl,phim,r0,rfq10(nc),rfq11(nc)
!cc579     format(2(2x,i4),5(2x,e12.5))
       endif
! end do on cell data loop       
       enddo
!********************************************
       if(netc.lt.nceltot) then
         write(ierr,*) 'Error: Parameter NCELTOT after RFQPTQ entry',
     *   ' in DYNAC input file is ',NCELTOT
         write(ierr,*) 'This is larger than the',
     *   ' number of cells in the RFQ datafile, which is ',netc
         write(16,*) 'Error: Parameter NCELTOT after RFQPTQ entry in',
     *   ' DYNAC input file is ',NCELTOT
         write(16,*) 'This is larger than the',
     *   ' number of cells in the RFQ datafile, which is ',netc
         stop
       endif
       call rfq_parm
       return
       end
!> *******************************************************************
!! function bint(n,z)
!! ---  integral representation of modified Bessel functions
!!      n integer order    z argument
!< *******************************************************************
       function bint(n,z)
        implicit real(8) (a-h,o-z)
        COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
        dimension ui(16),wi(16)
!   GAUSS n=16 de -1. a 1
       DATA (UI(J),J=1,16)/-.9894009,-.9445750,-.8656312,-.7554044,
     1   -.6178762,-.4580168,-.2816036,-.0950125,
     2    .0950125,.2816036,.4580168,.6178762,.7554044,.8656312,
     3    .9445750,.9894009/
        DATA (WI(J),J=1,16)/.0271524,.0622535,.0951585,.1246288,
     1   .1495960,.1691565,.1826034,.1894506,.1894506,.1826034,
     2   .1691565,.1495960,.1246288,.0951585,.0622535,.0271524/
        bint=0.
        do i=1,16
         thet=pi/2.*(1.+ui(i))
         fln=float(n)
         cthet=cos(thet)
         fonc=exp(cthet*z)*cos(fln*thet)
         bint=bint+fonc*wi(i)
        enddo
        bint=bint/2.
        return
        end
!> *******************************************************************
!! SUBROUTINE accep_rfq(pib)
!! Do so by shifting particles belonging to the same bunch from
!! outside to inside (+/-) pi w.r.t.the synchronous particle
!< *******************************************************************
       SUBROUTINE accep_rfq(pib)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common/faisc/f(10,iptsz),imax,ngood
!       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       common/sc3/beamc,scdist,sce10,cplm,ectt,apl,ichaes,iscsp
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       common/mcs/imcs,ncstat,cstat(20)
       common/tapes/in,ifile,meta,ierr
       common/etcha3/ichxyz(iptsz)
       common/rec/irec
       common/etcom/cog(8),exten(17),fd(iptsz)
!       logical chasit
       do ite=1,3
         do i=1,ngood
           drad=(f(6,i)-tref)*fh
           if(drad.gt.pib) then
!old             f(6,i)=(f(6,i)-pi/fh)
             f(6,i)=(f(6,i)-2.*pi/fh)
           endif
           if(drad.lt.-pib) then
!old             f(6,i)=(f(6,i)+pi/fh)
             f(6,i)=(f(6,i)+2.*pi/fh)
           endif
         enddo
       enddo
       tcog=0.
! --- cog in time of bunch after reinjecting particles into the bunch
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       write(16,59) tcog*fh*180./pi
59     format(' Phase of COG after reinjecting particles into the ',
     *        'bunch: ',e13.7,' deg')
       return
       end
!> *******************************************************************
!! SUBROUTINE rfq_parm
!!  NOTE:
!!      The reference particle and particles may evolve separately or
!!      may be connected
!!      Only the SCHEFF space charge method is available
!!      Space charge computations are automaticaly made at the middle
!!      of each cell
!!
!! -------------------------------------------------------------------
!!  Radial matching section
!!     rfq1(nc): Aq (no dimension)
!!     rfq2(nc): not used
!!     rfq3(nc): RMS length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor to be applied at the inter-vane potentiel
!!               (only for particles)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  Standard accelerating cells (ityp = 0)
!!     rfq1(nc): A01 ( 1/(m*m) )
!!     rfq2(nc): A10 (no dimensions)
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq6(nc): A12 (no dimension)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq8(nc): A03 (1/(m**6)
!!     rfq9(nc): factor F = 1 + a() (only for inter-vane potentiel
!!               of particles)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!!  odds cells have a01 positive, even cells have a01 negative
!!
!! -------------------------------------------------------------------
!!  Transition T-cell and E-cell
!!     rfq1(nc): A30 (no dimensions)
!!     rfq2(nc): A10 (no dimensions)
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  M-cell
!!     rfq1(nc): A30 = 0
!!     rfq2(nc): A10 = 0
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  Fringe-field region from the potential function (F-cell)
!!     rfq1(nc): A01 ( 1/(m*m) )
!!     rfq2(nc): A10 (no dimensions)
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  Fringe-field region the profil is read from disk (F-cell)
!!     rfq1(nc): not used
!!     rfq2(nc): not used
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m) (not used)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!< *******************************************************************
       SUBROUTINE rfq_parm
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/RIGID/BORO
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/tapes/in,ifile,meta,ierr
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DCSPA/IESP
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/SHIF/DTIPH,SHIFT
       common/femt/iemgrw,iemqesg
       common/posc/xpsc
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/AZLIST/ICONT,IPRIN
       common/trfq/icour,ncell
       logical iesp,ichaes,shift,iemgrw,iflag
       common/itvole/itvol,imamin
       common/tofev/ttvols
       common/rf1ptq/tvolt,avolt,fph,mlc,nceltot
       common/rf2ptq/rfq1(500),rfq2(500),rfq3(500),rfq4(500),rfq6(500)
     *        ,rfq7(500),rfq8(500),rfq9(500)
       common/rf5ptq/tdvolt,rfq10(500),rfq11(500)
       common/rfq3ptq/itype(500),ipari(500),evens,evenr
       common/bonda/cbx(500),bbx(500),ablx(500),cby(500),
     *        bby(500),ably(500)
       logical itvol,imamin,fromrfq
       common/conti/irfqp
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/spff/xspf(400),yspf(400),sf(500),pf(500),qf(500)
       common/rms_prfl/npt,npf
       common/rec/irec
       common/rfqwdst/rfqwfil,rfqirec,rfqiflg,iwcl(20),nrwc,iflgr
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       logical chasit
       dimension lossreason(iptsz)
!********************************************
! v28/04/2015
       common/fcont/ifcont
       logical ifcont
!********************************************
       logical irfqp,evens,evenr
       dimension rfqdmp(500,10)
       character cr*1,rfqwfil*80
       integer rfqiflg,rfqirec
       PRTLAB='RFQPTQ  '
! allow for print out on terminal of cell# on one and the same line
       cr=char(13)
       irfqp=.true.
       iflag=.false.
       radian=pi/180.
       ilost=0
       twopi=2.*pi
!  convert vl in m
       vlm=vl/100.
       wavel=2.*pi*vlm/fh
       er=xmat
! set flag that optional RFQ .dst file is not open       
       ISTAT=0
!      STATISTIQUES FOR PLOTS
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
!  start prints in file 'short.data'
       tlgth=0.
       fprec=epsilon(pi)
       idav=idav+1
       iitem(idav)=15
       dav1(idav,9)=tdvolt*1000.
       dav1(idav,7)=float(nceltot)
       dav1(idav,8)=tdvolt*1000.
! --- end daves
       xlrfq=0.
!  the integer nn is only used if the RMS profile is required
       nn=0
!  nrwcc is a counter used for the optional WRBEAM behind cells listed        
       nrwcc=1
       do ncell=1,nceltot
         write(6,8254,advance='no') nrtre,ncell,cr
8254     format('Transport element:',i5,'      RFQ cell :',
     *     i5,'            ',a1)
!  ns = 18: number of steps in cells (except for the fringe field region and RMS)
         ns=18
         if(itype(ncell).eq.5) ns=126
         if(itype(ncell).eq.6) ns=126
         nsm=ns/2
         r0=rfq7(ncell)
         cl=rfq3(ncell)
         davtot=davtot+cl*100.
         xlrfq=xlrfq+cl*100.
!********************************************
         if(itype(ncell).eq.0) then
! ------------- accelerating cells(ityp = 0)
           cay=pi/cl
! --- synchronous particle
           rtvolt=rfq10(ncell)
!  vorsq not needed            
!           vorsq=rfq1(ncell)*rtvolt
           av=rfq2(ncell)*rtvolt
!  a12v not needed           
!           a12v=rfq6(ncell)*rtvolt
! --- particles
           pavolt=rfq11(ncell)
           vorb=rfq1(ncell)*pavolt*rfq9(ncell)
           avb=rfq2(ncell)*pavolt*rfq9(ncell)
           a12vb=rfq6(ncell)*pavolt*rfq9(ncell)
! a03vb not needed (?)           
           a03vb=rfq8(ncell)*pavolt*rfq9(ncell)
         endif
!********************************************
         if(itype(ncell).eq.1) then
! ---------------- T-cell(Type = 1)
           cay=pi/(2.*cl)
! ---- synchronous particle
           rtvolt=rfq10(ncell)
           a31v=rfq1(ncell)*rtvolt
           a10v=rfq2(ncell)*rtvolt
! ---- particles (field)
           pavolt=rfq11(ncell)
           a31vb=rfq1(ncell)*pavolt*rfq9(ncell)
           a10vb=rfq2(ncell)*pavolt*rfq9(ncell)
         endif
!********************************************
         if(itype(ncell).eq.2) then
! --------   E-cell(Type = 2)
           cay=pi/(2.*cl)
! ---- synchronous particle
           rtvolt=rfq10(ncell)
           a31v=rfq1(ncell)*rtvolt
           a10v=rfq2(ncell)*rtvolt
! ---- particles
           pavolt=rfq11(ncell)
           a31vb=rfq1(ncell)*pavolt*rfq9(ncell)
           a10vb=rfq2(ncell)*pavolt*rfq9(ncell)
         endif
!********************************************
         if(itype(ncell).eq.4) then
! ------- F-cell (ityp = 4)
! --- synchronous particle
           rtvolt=rfq10(ncell)
           av=rfq2(ncell)*rtvolt
! --- particles
           pavolt=rfq11(ncell)
           avb=rfq2(ncell)*pavolt*rfq9(ncell)
         endif
!********************************************
         if(itype(ncell).eq.7) then
!  fringe field type 7
! ------- F-cell (ityp = 7)
! --- synchronous particle
           rtvolt=rfq10(ncell)
! --- particles
           pavolt=rfq11(ncell)
           a31vb=pavolt*rfq9(ncell)
         endif
!********************************************
         if(itype(ncell).eq.5) then
! -----Radial matching section from potential function (Type = 5)
           cay=pi/(2.*cl)
! ---- synchronous particle
           rtvolt=rfq10(ncell)
           a31v=rfq1(ncell)*rtvolt
           a10v=rfq2(ncell)*rtvolt
! ---- particles (field)
           pavolt=rfq11(ncell)
           a31vb=rfq1(ncell)*pavolt*rfq9(ncell)
           av10b=rfq2(ncell)*pavolt*rfq9(ncell)
         endif
!********************************************
         if(itype(ncell).eq.6) then
! -----Radial matching section with vanes profile read from disk (Type = 6)
           cay=pi/(2.*cl)
! ---- potential applied to the synchronous particle
           rtvolt=rfq10(ncell)
! ---- potential applied to particles
           pavolt=rfq11(ncell)
           a31vb=pavolt*rfq9(ncell)
         endif
!********************************************
!   c.o.g of the bunch
         tcog=0.
         ecog=0.
         do i =1,ngood
           tcog=tcog+f(6,i)
           ecog=ecog+f(7,i)
         enddo
         tcog=tcog/float(ngood)
         ecog=ecog/float(ngood)
         gcog=ecog/er
         bcog=sqrt(1.-1./(gcog*gcog))
         wcog=ecog-er
         if(ncell.eq.1) then
! ---- shift = .false. ==> the synchronous particle is the center of gravity
           if(.not.shift) then
             tref=tcog
             bref=bcog
             vref=bref*vl
             gref=gcog
             wref=wcog
             wrefi=wref
           else
! ---- shift = .true. ==> the synchronous particle and the c.o.g are separated
             bref=vref/vl
             gref=1./sqrt(1.-bref*bref)
             wref=er*(gref-1.)
             wrefi=wref
           endif
         endif
!********************************************
! --- fringe field region type 4
         if(itype(ncell).eq.4) then
           cay=pi/(2.*cl)
           NS=int(36.*CL/(BREF*WAVEL))
           if(ns.le.5) ns=6
           nsm=ns/2
         endif
!********************************************
!   Fringe field region type 7
         if(itype(ncell).eq.7) then
           cay=pi/(2.*cl)
           NS=int(36.*CL/(BREF*WAVEL))
           ns=3*ns
           nsm=ns/2
         endif
!********************************************
! ---  M-cell (itype = 3)
!old sv         if(itype(ncell).eq.3) cay=pi/cl
!********************************************
         xl=cl/float(ns)
         hl=.5*xl
!----  scl: space charge length in SCHEFF unit (cm)
         scl=cl*100.
!----  phini: phase of the synchronous at input of the cell
         phini=-tref*fh+rfq4(ncell)*radian
         if(ncell.eq.1) then
           write(16,178)
178        format(/,' Dynamics at the input',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
           write(16,1788) bcog,gcog,wcog,tcog*fh*180./pi,tcog
1788       FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
           WRITE(16,165) bref,gref,wref,tref*fh*180./pi,tref
165        FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
           write(16,*)
           write(75,9627)
9627       format(5x,'ncell',4x,'A01(m-2)',8x,'A10',
     *         12x,'A12',11x,'r0(m)',11x,'A03(m-6)')
           write(70,9977)
9977       format('#',3x,'ncell',4x,'Lcell(m)',7x,'Ztot(m)',8x,
     *     'Phi(deg)',7x,'Phm(deg)',7x,'Pho(deg)',7x,'Wsyn',11x,
     *     'Wcog',9x,'ngood')
         endif
         z=0.
         dr0=0.
         if(ncell.eq.1) dr0=(rfq7(2)-rfq7(1))
         if(ncell.gt.1) dr0=(rfq7(ncell)-rfq7(ncell-1))
         eddav=0.         
         eddavb=0.         
         if(ncell.gt.1 .and. itype(ncell).eq.0) then
           eddav=(rfq2(ncell)-rfq2(ncell-1))*rtvolt         
           eddavb=(rfq2(ncell)-rfq2(ncell-1))*pavolt*rfq9(ncell)
         endif  
         eddav=eddav/float(ns)         
         eddavb=eddavb/float(ns)         
! ---- iterations over steps xl
         nsp1=ns+1
         do n=1,nsp1
           z=z+hl
           fns=float(n-1) 
           if(z.gt.cl) then
             zl=z-hl
             tlgth=tlgth+zl
             phfin=tref*fh+phini
             phfin=phfin*180./pi
!cc            phfin=phref*180./pi
             if(ncell.eq.1) then
               rfqdmp(ncell,1)=zl
               rfqdmp(ncell,3)=wref-wrefi
             else
               rfqdmp(ncell,1)=zl+rfqdmp(ncell-1,1)
               rfqdmp(ncell,3)=wref-wrefin
             endif
             wrefin=wref
             rfqdmp(ncell,2)=phdep
! the maximum energy gain is pi/4 * A * V 
             rfqdmp(ncell,4)=0.25*pi*rfq2(ncell)*rfq10(ncell)
             write(70,9999)ncell,zl,tlgth,phdep,phmil,phfin,
     *                wref,wcog,ngood
9999         format(2x,i5,7(3x,e12.5),3x,i6)
             exit
           endif
! --- change of reference over the half step hl
           tref=tref+hl/(bref*vlm)
           if(itvol) ttvols=tref
           phref=tref*fh+phini
           skz=sin(cay*z)
           ckz=cos(cay*z)
! ---  synchronous particle
!        change of energy over the step xl
           sp=sin(phref)
! standard accelerating cell
           if(itype(ncell).eq.0) then
             if(ncell.gt.1) then
               av=rfq2(ncell-1)*rtvolt+eddav*fns
               avb=rfq2(ncell-1)*pavolt*rfq9(ncell)+eddavb*fns
             else
               av=rfq2(ncell)*rtvolt
               avb=rfq2(ncell)*pavolt*rfq9(ncell)
             endif
             dwref=.5*qst*cay*av*skz*sp*xl
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
! T-cell (type = 1)
           if(itype(ncell).eq.1) then
             skz3=sin(3.*cay*z)
             ckz3=cos(3.*cay*z)
             dwref=0.5*qst*cay*(a10v*skz+3.*a31v*skz3)*sp*xl
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
! E-cell (type = 2)
           if(itype(ncell).eq.2) then
             skz3=sin(3.*cay*z)
             ckz3=cos(3.*cay*z)
             dwref=0.5*qst*cay*(a10v*ckz+3.*a31v*ckz3)*sp*xl
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
! M-cell (type = 3)
           if(itype(ncell).eq.3) then
             dwref=0.
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
! Fringe-field region (itype = 4)
           if(itype(ncell).eq.4) then
             rtvolt=rfq10(ncell)
             av=rfq2(ncell-1)*rtvolt+eddav*fns
             avb=rfq2(ncell-1)*pavolt*rfq9(ncell)+eddavb*fns
             r0=rfq7(ncell)
             c3kz=cos(3.*cay*z)
             skpz=.75*(skz+sin(3.*cay*z))
             dwref=.5*qst*cay*av*skpz*sp*xl
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
!********************************************
! Fringe-field region (itype = 7)
           if(itype(ncell).eq.7) then
             av=rfq2(ncell-1)*rtvolt+eddav*fns
             avb=rfq2(ncell-1)*pavolt*rfq9(ncell)+eddavb*fns
             skpz=.75*(skz+sin(3.*cay*z))
             dwref=.5*qst*cay*av*skpz*sp*xl
!   rprof: current fringe field profile at the azimutal position z
             r0=rfq7(ncell-1)+dr0*fns
             c3kz=cos(3.*cay*z)
             rproff=splinf(npf,z)
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
!********************************************
! --- RMS (type = 5)
           if(itype(ncell).eq.5) then
             dwref=0.
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
! --- RMS (type = 6)
           if(itype(ncell).eq.6) then
             dwref=0.
!   rprof: current RMS profile given at z
             rprof=spline(npt,z)
! print in file rfq_list1.data
             if(n.eq.1) phdep=rfq4(ncell)
           endif
! --- gain of energy (synchronous particle)
           wrefm=wref+0.5*dwref
           grefm=wrefm/er+1.
           brefm=sqrt(1.-1./(grefm*grefm))
           wref=wref+dwref
           gref=wref/er+1.
           bref=sqrt(1.-1./(gref*gref))
           dez=0.
           dref=0.
! ****************           
! ---- Beam ---- *
! ****************           
!         coordinates x, xp,y, yp convert in m and rad
           do ip=1,ngood
             xi=f(2,ip)*1.e-02
             xpi=f(3,ip)*1.e-03
             yi=f(4,ip)*1.e-02
             ypi=f(5,ip)*1.e-03
             ww=f(7,ip)-er
! remove from the bunch particles that have energy < 0
             if(ww.lt.0.)then
               f(8,ip)=0.
               ilost=ilost+1
               lossreason(ip)=-2
               f6i=f(6,ip)-tref               
               write(49,3928) PRTLAB,ncell,davtot/100.,ip,
     *         int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip),
     *         f6i*fh*180./pi,f(7,ip)-er,f(9,ip),lossreason(ip)     
               iflag=.true.
               cycle
             endif
3928         FORMAT(1x,A8,1x,I4,1x,E12.5,1x,i5,1x,i5,1x,6(f12.3,1x),
     *              1x,f5.2,3x,i2)
             gi=ww/er+1.
             if(gi.lt.1.) then
               f(8,ip)=0.
               ilost=ilost+1
! needs to be on energy
               lossreason(ip)=-2
               f6i=f(6,ip)-tref
               write(49,3928) PRTLAB,ncell,davtot/100.,ip,
     *         int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip),
     *         f6i*fh*180./pi,f(7,ip)-er,f(9,ip),lossreason(ip)     
               iflag=.true.
               cycle
             endif
             bi=sqrt(1.-1./(gi*gi))
             bgi=bi*gi
! move particles back in the bunch if they have abs(phi) > pi
             tim=f(6,ip)+hl/(bi*vlm)
             phi=fh*(tim-tref)
             if(phi.ge.pi) then
               f(6,ip)=f(6,ip)-2.*pi/fh
               tim=f(6,ip)+hl/(bi*vlm)
               phi=fh*(tim-tref)
               if(abs(phi).gt.pi) then
                 f(8,ip)=0.
                 ilost=ilost+1
                 lossreason(ip)=-1
                 f6i=tim-tref
                 write(49,3928) PRTLAB,ncell,davtot/100.,ip,
     *           int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip),
     *           f6i*fh*180./pi,f(7,ip)-er,f(9,ip),lossreason(ip)     
                 iflag=.true.
                 cycle
               endif
             endif
             if(phi.le.-pi) then
               f(6,ip)=f(6,ip)+2.*pi/fh
               tim=f(6,ip)+hl/(bi*vlm)
               phi=fh*(tim-tref)
               if(abs(phi).gt.pi) then
                 f(8,ip)=0.
                 ilost=ilost+1
                 lossreason(ip)=-1
                 f6i=tim-tref
                 write(49,3928) PRTLAB,ncell,davtot/100.,ip,
     *           int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip),
     *           f6i*fh*180./pi,f(7,ip)-er,f(9,ip),lossreason(ip)     
                 iflag=.true.
                 cycle
               endif
             endif
             tim=f(6,ip)+hl/(bi*vlm)
             phi=phini+fh*tim
             qq=abs(f(9,ip))
             sp=sin(phi)
             cp=cos(phi)
             bav=bi
             gav=gi
             bgav=bgi
             bg=bgi
             beta=bi
             delt=0.
             amort=1.
             xm=xi+xpi*hl
             ym=yi+ypi*hl
             rm=sqrt(xm*xm+ym*ym)
! ---- particle is lost if abs(xm) > vanx or abs(ym) > vany
             if(n.ne.ns/2) then
               vanx=ablx(ncell)*z*z+bbx(ncell)*z+cbx(ncell)
               vany=ably(ncell)*z*z+bby(ncell)*z+cby(ncell)
               vanx=vanx*0.7523
               vany=vany*0.7523
               if(abs(xm).ge.vanx) then
                 f(8,ip)=0.
                 lossreason(ip)=2
               endif  
               if(abs(ym).ge.vany) then
                 f(8,ip)=0.
                 lossreason(ip)=3
               endif  
               if(int(f(8,ip)).eq.0) then
                 ilost=ilost+1
                 f6i=tim-tref
                 write(49,3928) PRTLAB,ncell,davtot/100.,ip,
     *           int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip),
     *           f6i*fh*180./pi,f(7,ip)-er,f(9,ip),lossreason(ip)     
                 iflag=.true.
                 cycle
               endif
             else  
!             endif
!             if(n.eq.ns/2) then
               if(rm.gt.r0) then
                 f(8,ip)=0.
                 ilost=ilost+1
                 lossreason(ip)=1
                 f6i=tim-tref
                 write(49,3928) PRTLAB,ncell,davtot/100.,ip,
     *           int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip),
     *           f6i*fh*180./pi,f(7,ip)-er,f(9,ip),lossreason(ip)     
                 iflag=.true.
                 cycle
               endif
             endif
             theta=0.
             signx=0.
             signy=0.
             xml=xm
             yml=ym
             if(abs(xm).gt.1.e-10) then
               theta=atan(ym/xm)
               signx=1.
               signy=1.
               if(theta.gt.0.) then
                 if(xm.lt.0.) signx=-1.
                 if(ym.lt.0.) signy=-1.
               endif
               if(theta.lt.0.) then
                 if(xm.lt.0.) signx=-1.
                 if(ym.gt.0.) signy=-1.
               endif
             endif
             if(abs(xm).le.1.e-10) then
               if(abs(ym).gt.1.e-10) then
                 if(xm.ge.0..and.ym.gt.0.) theta=pi/2
                 if(xm.ge.0..and.ym.lt.0.) theta=-pi/2
                 if(xm.lt.0..and.ym.lt.0.) theta=pi/2
                 if(xm.lt.0..and.ym.gt.0.) theta=-pi/2
               endif
             endif
!             if(theta.eq.0.) then
             if(abs(theta).le.fprec) then
               signx=0.
               signy=0.
             endif
             if(itype(ncell).eq.0) then
! ----  standard accelerating cell
               zrm=cay*rm
! ----- Bessel functions: I0 to I4
               bi0=1.+zrm*zrm/4.+zrm**4/64.
!old     *     +zrm**6/2304 +zrm**8/1.47456e05
!old      bi0=bi0+zrm**10/1.47456e07
!old             bi1=zrm/2.+zrm**3/16.+zrm**5/128.
!             bi1=zrm/2.+zrm**3/16.+zrm**5/384.
               bi1=zrm/2.+zrm**3/16.
               bi1p=0.
!             if(rm.ne.6.*0.) bi1p=bi1/rm
               if(abs(rm).gt.fprec) bi1p=bi1/rm
               bi3=zrm**3/48.+zrm**5/768.
               bi4=zrm**4/384.
               bi4r=0.
               if(rm.gt.1.e-06) bi4r=bi4/rm
               bi5=zrm**5/3840.
               c2t=cos(2.*theta)
               s2t=sin(2.*theta)
               c1t=cos(theta)
               s1t=sin(theta)
! ---   transverse fields (cylindrical coordinates)
               erf=vorb*c2t*2.*rm+
     *         cay*(avb*bi1+a12vb*(bi3+bi5)*cos(4.*theta)/2.)*ckz
               erf=-erf/2.
               etf=vorb*s2t*2.*rm+
     *         4.*a12vb*bi4r*sin(4.*theta)*ckz
               etf=etf/2.
!old sv            evens=.false.
!old            ncf=(ncell/2)*2-ncell
               ncf=(ipari(ncell)/2)*2-ipari(ncell)
               if(ncf.eq.0) then
                 erf=-erf
                 etf=-etf
!old sv            evens=.true.
               endif
!  cartesian fields Ex and Ey
               ex=erf*c1t-etf*s1t
               ey=erf*s1t+etf*c1t
               ex=signx*ex
               ey=signy*ey
             endif
! ---- T-cell (Type = 1)
            if(itype(ncell).eq.1) then
!   transverse fields (cylindrical coordinates)
              zrm=cay*rm
              zrm3=zrm*3.
              bi0=1.+zrm*zrm/4.+zrm**4/64.+zrm**6/2304.
!old     *              +zrm**8/1.47456e05
              bi03=1.+zrm3*zrm3/4.+zrm3**4/64.+zrm3**6/2304.
!old     *              +zrm**8/1.47456e05
              bi1=zrm/2.+zrm**3/16.+zrm**5/384.
!old             bi1p=0.
!old             if(rm.ne.6.*0.) bi1p=bi1/rm
              bi13=zrm3/2.+zrm3**3/16.+zrm3**5/384.
!old             bi13p=0.
!old             if(rm.ne.6.*0.) bi13p=bi13/rm
              c2t=cos(2.*theta)
              s2t=sin(2.*theta)
              c1t=cos(theta)
              s1t=sin(theta)
              pavolt=rfq11(ncell)
              rpv=pavolt*rfq9(ncell)
              ncf=(ipari(ncell)/2)*2-ipari(ncell)
              if(ncf.eq.0) then
                rpv=-rpv
                erf=-rpv/(r0*r0)*c2t*rm
                erf=erf+cay/2.*(a10vb*bi1*ckz+3.*a31vb*bi13*ckz3)
                etf=rpv/(r0*r0)*s2t*rm
              else
                erf=-rpv/(r0*r0)*c2t*rm
                erf=erf-cay/2.*(a10vb*bi1*ckz+3.*a31vb*bi13*ckz3)
                etf=rpv/(r0*r0)*s2t*rm
              endif
              ex=erf*c1t-etf*s1t
              ey=erf*s1t+etf*c1t
              ex=signx*ex
              ey=signy*ey
            endif
!   tof over the length xl
! ---- E-cell (Type = 2)
            if(itype(ncell).eq.2) then
! ---   transverse fields (cylindrical coordinates)
              zrm=cay*rm
              zrm3=zrm*3.
              bi0=1.+zrm*zrm/4.+zrm**4/64.+zrm**6/2304.
!old     *              +zrm**8/1.47456e05
              bi03=1.+zrm3*zrm3/4.+zrm3**4/64.+zrm3**6/2304.
!old     *              +zrm**8/1.47456e05
              bi1=zrm/2.+zrm**3/16.+zrm**5/384.
!old             bi1p=0.
!old             if(rm.ne.6.*0.) bi1p=bi1/rm
              bi13=zrm3/2.+zrm3**3/16.+zrm3**5/384.
!old             bi13p=0.
!old             if(rm.ne.6.*0.) bi13p=bi13/rm
              c2t=cos(2.*theta)
              s2t=sin(2.*theta)
              c1t=cos(theta)
              s1t=sin(theta)
              pavolt=rfq11(ncell)
              rpv=pavolt*rfq9(ncell)
              erf=-rpv/(r0*r0)*c2t*rm
              erf=erf+0.5*cay*(a10vb*bi1*skz+3.*a31vb*bi13*skz3)
              etf=rpv/(r0*r0)*s2t*rm
!  control polarity of the cell
              ncf=(ipari(ncell)/2)*2-ipari(ncell)
              if(ncf.eq.0) then
                erf=-erf
                etf=-etf
              endif
              ex=erf*c1t-etf*s1t
              ey=erf*s1t+etf*c1t
              ex=signx*ex
              ey=signy*ey
            endif
! ---- M-cell (Type = 3)
            if(itype(ncell).eq.3) then
              c2t=cos(2.*theta)
              s2t=sin(2.*theta)
              c1t=cos(theta)
              s1t=sin(theta)
              pavolt=rfq11(ncell)
              rpv=pavolt*rfq9(ncell)
              erf=-rpv/(r0*r0)*c2t*rm
              etf=rpv/(r0*r0)*s2t*rm
! ---- M-cell (Type = 3)
!old            if(itype(ncell).eq.3) then
!old             c2t=cos(2.*theta)
!old             s2t=sin(2.*theta)
!old             c1t=cos(theta)
!old             s1t=sin(theta)
!old             pavolt=rfq11(ncell)
!old             rpv=pavolt*rfq9(ncell)
!old             erf=-rpv/(r0*r0)*c2t*rm
!old             etf=rpv/(r0*r0)*s2t*rm
!old             c3kz=cos(3.*cay*z)
!old            erf=erf*(ckz+c3kz/3.)*0.75
!old            etf=etf*(ckz+c3kz/3.)*0.75
! *************************************************
!  control polarity of the cell
!old            ncf=(ncell/2)*2-ncell
              ncf=(ipari(ncell)/2)*2-ipari(ncell)
              if(ncf.eq.0) then
                erf=-erf
                etf=-etf
              endif
              ex=erf*c1t-etf*s1t
              ey=erf*s1t+etf*c1t
              ex=signx*ex
              ey=signy*ey
            endif
! ---- Radial matching section (type = 5)
           if(itype(ncell).eq.5) then
             c2t=cos(2.*theta)
             s2t=sin(2.*theta)
             c1t=cos(theta)
             s1t=sin(theta)
             skz3=sin(3.*cay*z)
             ckz3=cos(3.*cay*z)
             zrm=cay*rm
             b2kr=zrm*zrm/8.
             b2kr3=(9./8.)*zrm*zrm
             qzrm=0.
             erf=0.
             etf=0.
             if(rm.gt.6*0.) then
               qzrm=(b2kr*skz-(1./27.)*b2kr3*skz3)
               erf=-a31vb*cay*cay*(skz-1/3.*skz3)*c2t/8.
               erf=erf*rm
               etf=a31vb*qzrm*s2t/rm
             endif
             ex=erf*c1t-etf*s1t
             ey=erf*s1t+etf*c1t
             ex=signx*ex
             ey=signy*ey
           endif
! ****************************************************
           if(itype(ncell).eq.6) then
             BGFAC=GAV*BAV**2
             cc=a31vb*qq*xl*sp/(bgfac*er)
             rr1=-cc/(rprof*rprof)
             rr2=cc/(rprof*rprof)
             rr1=rr1*xm
             rr2=rr2*ym
           endif
!********************************************
! Fringe field profile from the disk (type 7)
           if(itype(ncell).eq.7) then
             BGFAC=GAV*BAV**2
             c1=.75*(ckz+c3kz/3.)
             cc=a31vb*qq*xl*sp/(bgfac*er)
             rr1=-cc/(rproff*rproff)
             rr2=cc/(rproff*rproff)
!  test the cell parity
             ncf=(ipari(ncell)/2)*2-ipari(ncell)
             if(ncf.eq.0) then
               rr1=-rr1
               rr2=-rr2
             endif
             rr1=rr1*xm
             rr2=rr2*ym
!old       if(ip.eq.25) write(16,5287)n,z,rproff,rr1/xm,rr2/ym
!5287       format(2x,i4,4(2x,e12.5))
           endif
!********************************************
!----  CHANGE ENERGY OVER the STEP XL
! ------  standard accelerating cell (Type = 0)
           if(itype(ncell).eq.0) then
             ez=0.5*(avb*bi0+a12vb*bi4*cos(4.*theta))*skz*cay
             dw=qq*ez*sp*xl
           endif
! -------  T-cell (Type = 1)
           if(itype(ncell).eq.1) then
             ez=0.5*cay*(a10vb*skz*bi0+3.*a31vb*skz3*bi03)
             dw=qq*ez*sp*xl
           endif
! -------  E-cell (Type = 2)
           if(itype(ncell).eq.2) then
             ez=0.5*cay*(a10vb*ckz*bi0+3.*a31vb*ckz3*bi03)
             dw=qq*ez*sp*xl
           endif
! ------- M-cell (itype = 3)
           if(itype(ncell).eq.3) dw=0.
! ----    fringe field region (itype = 4)
!********************************************
           if(itype(ncell).eq.4) dw=.5*qq*cay*avb*skz*sp*xl
           if(itype(ncell).eq.7) dw=.5*qq*cay*avb*skz*sp*xl
!********************************************
! --------RMS (itype = 5)
           if(itype(ncell).eq.5) then
             ez=-1./16.*a31vb*cay**3*rm*rm*(ckz-ckz3)*c2t
             dw=qq*ez*sp*xl
           endif
! --------RMS (itype = 6)
           if(itype(ncell).eq.6) then
             dw=0.
           endif
! ----  WAV: energy at the middle of the element
           WAV=WW+.5*DW
           GA=WAV/ER
           if(ga.le.0.) then
             f(8,ip)=0.
             ilost=ilost+1
! needs to be on energy
             lossreason(ip)=-2 
             f6i=f(6,ip)-tref
             write(49,3928) PRTLAB,ncell,davtot/100.,ip,int(f(1,ip)),
     *       f(2,ip),f(3,ip),f(4,ip),f(5,ip),f6i*fh*180./pi,
     *       WAV,f(9,ip),lossreason(ip)     
             iflag=.true.
             cycle
           endif
           BGAV=SQRT(GA*(2.+GA))
           GAV=1.+GA
           BAV=BGAV/GAV
! ---- energy over step xl
           WW=WW+DW
           GA=WW/ER
           GAM=1.+GA
           if(gam.le.1.) then
             f(8,ip)=0.
             ilost=ilost+1
! needs to be on energy
             lossreason(ip)=-2 
             f6i=f(6,ip)-tref
             write(49,3928) PRTLAB,ncell,davtot/100.,ip,int(f(1,ip)),
     *       f(2,ip),f(3,ip),f(4,ip),f(5,ip),f6i*fh*180./pi,
     *       WAV,f(9,ip),lossreason(ip)     
             iflag=.true.
             cycle
           endif
           BG=SQRT(GA*(2.+GA))
           beta=sqrt(1.-1/(gam*gam))
!old jump of phase (sec) of particles (only for standard accelerating cells)
           delt=0.
!old           if(itype(ncell).eq.0) then
!old             dez=.5*qq*cay*avb*skz*sp
!old             delt=.5*(dez/er) * xl*xl/(bav**3*gav**3*vlm)
!old           endif
           amort=bgi/bg
           BGFAC=GAV*BAV**2
           cc=qq*xl*sp/(bgfac*er)
!********************************************
           if(itype(ncell).ne.4) then
             if(itype(ncell).ne.6) then
               if(itype(ncell).ne.7) then
                 rr1=cc*ex
                 rr2=cc*ey
               endif
             endif
             xpm=xpi*amort+rr1
             ypm=ypi*amort+rr2
             xf=xm+xpm*hl
             yf=ym+ypm*hl
           else
!********************************************
! ------- Fringe-field region (itype = 4)
!           if(itype(ncell).eq.4) then
!*********************************************************
!         C1 = (1/m**2) * (m) = (1/m)
!         C2 = (1/m**2) * (m) = (1/m)
!         RF1 = (MeV/(MeV*m**2)) = (1/m**2)
!         RF2 =  (MeV/MeV) * (1/m**2) = (1/m**2)
!*******************************************************
!old              RF1=QQ*VORB/ER
!old              RF2=.25*QQ*CAY*CAY*AVB/ER
!old              C1=RF1*SP*XL/BGFAC
!old              C2=RF2*CKZ*SP*XL/BGFAC
!old              C1=C1*.75*(CKZ+C3KZ/3.)
!old              C2=C2*.75*(CKZ+3.*C3KZ)
!old              RR1=-(C1+C2)
!old              RR2=(C1-C2)
! rfq11(ncell) is (1.+avolt)*VV , where VV is intervane voltage seen by particles
             pavolt=rfq11(ncell)
! rfq9(ncell) is 1.+fvolt
             rpv=pavolt*rfq9(ncell)
             rf1=qq*rpv/(r0*r0*er)
! avb is a10*rpv
             rf2=.25*qq*cay*cay*avb/er
!  test cell parity
             ncf=(ipari(ncell)/2)*2-ipari(ncell)
             if(ncf.eq.0) then
               rf1=-rf1
               rf2=-rf2
             endif
             c1=rf1*sp*xl/bgfac
             c2=rf2*sp*xl/bgfac
!             c2=rf2*ckz*sp*xl/bgfac
             c1=c1*.75*(ckz+c3kz/3.)
             c2=c2*.75*(ckz+3.*c3kz)
             rr1=-(c1+c2)
             rr2=(c1-c2)
             xpm=xpi*amort+rr1*xm
             ypm=ypi*amort+rr2*ym
             xf=xm+xpm*hl
             yf=ym+ypm*hl
           endif
!      restore coordinates x, xp, y, yp in cm and mrad
            f(2,ip)=xf*100.
            f(4,ip)=yf*100.
            f(3,ip)=xpm*1000.
            f(5,ip)=ypm*1000.
!   tof over the length xl
!            if(beta.eq.0.) then
            if(abs(beta).le.fprec) then
              f(6,ip)=f(6,ip)+hl/(bi*vlm)
            else
              f(6,ip)=f(6,ip)+hl/(bi*vlm)+hl/(beta*vlm)
            endif
            f(7,ip)=ww+er
! --- end do ip (particle loop)
           enddo
! ----- reshuffle the good particles at the end of each element
           if(iflag) then
             call shuffle
             iflag=.false.
           endif
!    Space charge at the middle of the cell
           if(n.eq.nsm) then
             if(ichaes) then
!      Space Charge
               iesp=.true.
               call cesp(scl)
               iesp=.false.
             endif
           endif
! --- change the reference over the half step hl
           tref=tref+hl/(bref*vlm)
           if(itvol) ttvols=tref
           vref=bref*vl
           z=z+hl
! save RF phase in the middle of the cell
           if(n.eq.ns/2) then
             phmil=(tref*fh+phini)*180./pi
           endif
!     Change  dp/p over the cell
           call disp
!      end of do n=1,nsp1 (steps in cell)
         enddo
!----  c.o.g of the bunch at the output of the cell
         tcog=0.
         ecog=0.
         do i =1,ngood
           tcog=tcog+f(6,i)
           ecog=ecog+f(7,i)
         enddo
         tcog=tcog/float(ngood)
         ecog=ecog/float(ngood)
         gcog=ecog/er
         bcog=sqrt(1.-1./(gcog*gcog))
         wcog=ecog-er
!---  window control relative to the energy of the c.o.g of the bunch
! ---- ifw = 0 ===> wdisp = dW/W
! ---- ifw = 1 ===> wdisp = dW (MeV)
! ----- convert wdisp in dp/p
         if(ifw.eq.0 .or. ifw.eq.10) then
           dispr=gcog*gcog*wdisp/(gcog*(gcog+1.))
         endif
         if(ifw.eq.1 .or. ifw.eq.11) then
           dispr=gcog*gcog*wdisp/(gcog*(gcog+1.)*wcog)
         endif
         iflag=.false.
         do i=1,ngood
           dese=abs(fd(i)-1.)
           if(dese.gt.dispr) then
             ilost=ilost+1
             f(8,i)=0.
             lossreason(i)=-2 
             f6i=f(6,i)-tref
             write(49,3928) PRTLAB,ncell,davtot/100.,i,int(f(1,i)),
     *       f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180./pi,WAV,f(9,i),
     *       lossreason(i)     
             iflag=.true.
           endif
         enddo
         if(iflag) then
           call shuffle
!----  c.o.g of the bunch after shuffle
           tcog=0.
           ecog=0.
           do i =1,ngood
             tcog=tcog+f(6,i)
             ecog=ecog+f(7,i)
           enddo
           tcog=tcog/float(ngood)
           ecog=ecog/float(ngood)
           gcog=ecog/er
           bcog=sqrt(1.-1./(gcog*gcog))
           wcog=ecog-er
         endif
         br0=rfq7(ncell)*rfq7(ncell)
         bff=(1./er)*wavel*wavel*tdvolt/br0
         write(75,5555)ncell,rfq1(ncell),rfq2(ncell),
     *   rfq6(ncell),rfq7(ncell),rfq8(ncell)
5555     format(3x,i5,5(3x,e12.5))
!et2010s
! dphete,dav1(idav,16),dav1(idav,21) and dav1(idav,12) still to be assigned correct value
         dphete=0.
         trfprt=fh*tref*180./pi
         tcgprt=fh*tcog*180./pi
!         n2kp=int(tofprt/360.)
!         tofprt=tofprt-float(n2kp)*360.
!         if(tofprt.gt.180.) tofprt=tofprt-360.
! cavity number, transmission (%), synchronous phase (deg), time of flight (deg) (reference),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
         trnsms=100.*float(ngood)/float(imax)
         call cdg(1)
         encog=cog(1)
         gcog=encog/xmat
         bcog=sqrt(1.-1./(gcog*gcog))
         tcog=cog(3)
         CALL EXT2D(1)
         SURXTH=SQRT(exten(4)*exten(5)-exten(8)**2)
         SURYPH=SQRT(exten(6)*exten(7)-exten(9)**2)
         sqmdv=sqrt(exten(1)*exten(3)-exten(2)*exten(2))
         exns=bcog*surxth*10./sqrt(1.-bcog*bcog)
         eyns=bcog*suryph*10./sqrt(1.-bcog*bcog)
         emns=sqmdv*1.e12/fh
         if(ncell.eq.1) then
           write(50,*) '# rfqparm.dmp'
           write(50,*) '# cell    Z       trans   ',
     *   'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ',
     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
     *   'El,RMS        dWref        EffVolt'
           write(50,*) '#  #     (m)       (%)    ',
     *  '(deg)     (deg)        beta     (MeV)          (deg)      ',
     *  '   beta        (MeV)      (mm.mrad)    (mm.mrad)    ',
     *  '(ns.keV)      (MeV)          (MV)'
         endif
         write(50,7023) ncell,rfqdmp(ncell,1),trnsms,
     *   rfqdmp(ncell,2),tcgprt,bcog,wcog,trfprt,bref,wref,
     *   exns,eyns,emns,rfqdmp(ncell,3),rfqdmp(ncell,4)
7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
     *   2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x))
         if(ncell.eq.nceltot) then
           write(16,179)
179        format(/,' Dynamics at the output',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
           write(16,1788) bcog,gcog,wcog,tcog*fh*180./pi,tcog
           write(16,165) bref,gref,wref,tref*fh*180./pi,tref
           if(itvol) write(16,*) '  time of flight: ',
     *               ttvols*fh*180./pi,' deg'
!----  new magnetic rigidity of the reference
           xmor=xmat*bref*gref
           boro=33.356*xmor*1.e-01/qst
           dav1(idav,4)=davtot*10.
           dav1(idav,5)=xlrfq*10.
           dav1(idav,6)=(gref-1.)*er
           dav1(idav,36)=ngood
           irfqp=.false.
         endif
!   plots
         PRLAB(IPRF)='RFQPTQ  '
         CALL STAPL(davtot*10.)
!
! write particle distribution to file if selected with WRBEAM
!
         if(rfqiflg.gt.0) then
           fromrfq=.true. 
! check if file already open
           if(ISTAT.eq.0) then
             istat=1
             open(57,file=rfqwfil,status='unknown')
           endif
           if(rfqiflg.gt.nceltot) then
! print behind every cell
!
!title line
             if(iflgr.eq.100) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)' 
             elseif(iflgr.eq.101) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)  particle#' 
             elseif(iflgr.eq.102) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)  charge' 
             elseif(iflgr.eq.103) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)  charge    ', 
     *                   'particle#' 
             else
               write(57,*) 'cell ',ncell
             endif          
             irec=rfqirec
             call prbeam(iflgr,rfqwfil,fromrfq)
           elseif(rfqiflg.eq.ncell) then
! print behind the single cell indicated           
             if(iflgr.eq.100) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)' 
             elseif(iflgr.eq.101) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)  particle#' 
             elseif(iflgr.eq.102) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)  charge' 
             elseif(iflgr.eq.103) then 
               write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                   'yp(rad) phi(rad) W(MeV)  charge    ', 
     *                   'particle#' 
             else
               write(57,*) 'cell ',ncell
             endif          
             irec=rfqirec
             call prbeam(iflgr,rfqwfil,fromrfq)            
             close(57)
           endif
         elseif(rfqiflg.lt.0) then
!  print behind the cells in the list
           fromrfq=.true. 
! check if file already open
           if(ISTAT.eq.0) then
             istat=1
             open(57,file=rfqwfil,status='unknown')
           endif
           if(nrwcc.le.nrwc) then  
             if(iwcl(nrwcc).eq.ncell) then
! plot behind the cell indicated           
               if(iflgr.eq.100) then 
                 write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                       'yp(rad) phi(rad) W(MeV)' 
               elseif(iflgr.eq.101) then 
                 write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                       'yp(rad) phi(rad) W(MeV)  particle#' 
               elseif(iflgr.eq.102) then 
                 write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                       'yp(rad) phi(rad) W(MeV)  charge' 
               elseif(iflgr.eq.103) then 
                 write(57,*) 'cell ',ncell,' x(cm) xp(rad) y(cm) ',
     *                       'yp(rad) phi(rad) W(MeV)  charge    ', 
     *                       'particle#' 
               else
                 write(57,*) 'cell ',ncell
               endif          
               irec=rfqirec
               call prbeam(iflgr,rfqwfil,fromrfq)
               nrwcc=nrwcc+1
             endif
           else              
             close(57)
           endif
         endif
! 2016-05-17
         if(chasit) call emiprt(0)
! --- end do ncell
       enddo
       if(rfqiflg.gt.nceltot) close(57)
       call emiprt(0)
! v28/04/2015
       ifcont=.false.
       WRITE(16,*) 'After RFQ, bunched beam assumed'
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE stripp
!!  solid stripper foils for low velocity hadron particles
!< *******************************************************************
       SUBROUTINE stripp
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON /SPL/X(4000),Y(4000),S(3000),P(3000),Q(3000)
       common/strip/atm,qs,atms,ths,qop,sqst(6),anp,nqst
       common/mcs/imcs,ncstat,cstat(20)
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X                SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       common/faisc/f(10,iptsz),imax,ngood
       dimension pc(20),npcent(20)
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
!                       dimension charge(6),pcent(6),charm(6),pc(6),eoff(6)
       character cr*1
       dimension xeast(21),yeast(21),vecx(1)
! --- Eastham curve (reduced half angle over reduced thickness)
! ---- xeast: reduced thickness
! ---- yeast: reduced half angle
        data xeast/0.0,2.0,4.0,6.0,8.0,10.0,
     1             12.0,14.0,16.0,18.0,20.0,
     2             22.0,24.0,26.0,28.0,30.0,
     3             32.0,34.0,36.0,38.0,40.0/
        data yeast/0.00,0.60,1.04,1.56,1.80,2.08,2.32,
     1             2.72,2.96,3.20,3.44,3.624,3.808,
     2             3.992,4.176,4.360,4.544,4.728,4.912,
     3             5.096,5.28/
! ---- characteristics of the stripper:
! ---- qs : atomic number
! ---- atms   : Atomic mass (amu)
! ---- ths:thickness (g/cm**2)
! allow for print out on terminal of stripper number on one and the same line
       cr=char(13)
       nstrp=1
       imcs=1
       write(6,8254,advance='no') nrtre,nstrp,cr
8254   format('Transport element:',i5,
     *        '      Charge Stripper     :',i5,a1)
       write(16,101)anp,atm
101    format('***** Projectile ',/,1x,
     *  'atomic number: ',f4.0,' atomic mass : ',f4.0)
       write(16,100)qs,atms,ths
100    format('***** Charge Stripper ',/,1x,
     *  'atomic number: ',f4.0,' atomic mass : ',f4.0,
     1     ' thickness: ',e12.5,' g/cm**2')
! ---- characteristics of particles
! --------- qp=f(9,i)
! --------- uem: atomic mass (amu)
! --------- wp=f(7,i)-xmat
! ----------------------------
! ----      ENVELOPE
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
! ---- start prints in file 'short.data'
       idav=idav+1
       iitem(idav)=16
       dav1(idav,1)=qs
       dav1(idav,2)=atms
       dav1(idav,3)=ths
       dav1(idav,4)=davtot*10.
! ---- kinetic energy at the input
       wicg=0.
       do i=1,ngood
         wicg=f(7,i)+wicg
       enddo
       wicg=wicg/float(ngood)
       gcog=wicg/xmat
       bcog=sqrt(gcog*gcog-1.)/gcog
       wicg=wicg-xmat
       np=21
       denes=0.
       do i=1,np
         x(i)=xeast(i)
         y(i)=yeast(i)
       enddo
! ----  deriv2: develop the matrix for the b-splines functions
       call deriv2(np)
       len=1
       do ip=1,ngood
         wp=f(7,ip)-xmat
! --- wpatm: MeV/atm
         wpatm=wp/atm
         qp=f(9,ip)
! ---- xa: screening distance (cm)
         qsp=qs**(2./3.)+qp**(2./3.)
         xa=4.68165e-9/sqrt(qsp)
! ---- reduced thickness: thck
         xn=6.022e23/atms
         thck=xn*pi*xa*xa*ths
! --- reduce half angle: rtheta(rad) from Eastham curve
! ----  b-splines interpollation if thck<40, otherwise: rthet = 9.2e-02*thck + 1.6 (linear interpolation)
         if (thck.lt.40.) then
           rthet=spline(np,thck)
         else
           rthet=9.2e-02*thck+1.6
         endif
! ---- half angle of diffusion: dthet (mrad)
         zps=qs*qp/(xa*wp)
         dthet=2.88e-10*zps*rthet
! ---  angle of diffusion (mrad) scattered from M.C. separatly in xp and yp directions from a uniform law
!unif         call rlux(vec,len)
!unif         rx=(2.*vec-1.)*dthet*2.
!unif         f(3,ip)=f(3,ip)+rx
!unif         call rlux(vec,len)
!unif         ry=(2.*vec-1.)*dthet*2.
!unif         f(5,ip)=f(5,ip)+ry
! ---  angle of diffusion (mrad) scattered from M.C. separatly in xp and yp directions from a Gaussian law
         ax=f(3,ip)
         sm=dthet*2.
         call randga(len,sm,ax,vx)
         f(3,ip)=vx
         ay=f(5,ip)
         call randga(len,sm,ay,vy)
         f(5,ip)=vy
! ---  closest distance of approach: xb(cm)
         aps=(atms+atm)/(atms*atm)
         xb=1.44e-13*aps*qs*qp/sqrt(wpatm)
         if(ip.eq.1) then
           alpha=1.576e-02*qp*qs/sqrt(wpatm)
           write(16,5830)xa,thck,rthet,xb,dthet,alpha
5830       format(1x,'screening distance: ',e12.5,' cm',/,
     *      1x,'reduced thickness: ',e12.5,' reduced half angle: ',
     *      e12.5,' rad ',/,1x,'closest distance of approach: ',
     *      e12.5,' cm',/,1x,
     *      'half angle of diffusion: ',e12.5,' mrad',/,1x,
     *      'Bohr parameter: ',e12.5)
         endif
         wapc=4.*atm*atms/((atm+atms)**2)
         if(int(qs).eq.6) then
! energy loss in the case of carbon ions
! dke_Bethe routine supplied by Ji-Ho Jang, RAON/IBS
           dene=dkeBethe(wp)
         else  
! ----  loss of energy per scatter in the stripper (eq.16)
           dene=wapc*xb*xb*rthet*rthet/(xa*xa)*wp
         endif  
         denes=denes+dene
         f(7,ip)=f(7,ip)-dene
! ---- change the electric charge state of the particle over the foil
         f(9,ip)=qop
       enddo
       denes=denes/float(ngood)
       if(int(qs).eq.6) then
         write(16,*)'dE (Bethe-Bloch): ',denes,' MeV or ',denes/atm,
     *               ' MeV/u'
       else  
         write(16,*)'dE (Eastham): ',denes,' MeV or ',denes/atm,
     *               ' MeV/u'
       endif
       if(int(qs).eq.6 .or. int(qs).eq.3) then
! ---- change the electric charge state of the particles (carbon foil case)
! ---- Based on E.Baron et al, NIM A328 (1993) p.177-182
! calculate dX', dY', dZ'
         fksi=0.1535375*(qs/atms)*anp*ths/(bcog*bcog)
         des=0.5*0.001*(1.866+1.57*log(wicg/atm))*(anp/atm)
         des=des*sqrt(1000000.*ths*qs/atms)
         write(16,*)'dE(MeV) stripping: ',des,des*atm,wicg,wicg/atm
         write(16,*)'dE(MeV) ksi: ',fksi
! calculate the charge state distribution
         qbar=anp*(1.-exp(-83.275*bcog/(anp**0.447)))
         qavg=qbar*(1.-exp(-12.905+0.2124*anp-0.00122*anp*anp))
         yy=qbar/anp
         stdv=sqrt(qbar*(0.07535+0.19*yy-0.2654*yy*yy))
         con=1./(stdv*sqrt(2.*pi))
         fact=-1./(2.*stdv*stdv)
         pcsum=0.
         numchs=0
         qst=int(qavg)
! ---- only take charge states that have more than thresh % of the particles
         thresh=100./float(ngood)
         write(16,7830) thresh
7830     format(1x,'Carbon foil stripper. Charge state distribution',
     *    ' based on E.Baron et al, NIM A328 (1993) p.177-182',/,1x,
     *    'Threshhold for cutoff of the distribution: ',f12.7,' %')
         do i=1,100
           tmp=fact*(float(i)-qavg)*(float(i)-qavg)
! next line to avoid underflow condition            
           if(tmp .lt. -700.) tmp=-700.
!            pcent=100.*con*exp(fact*(float(i)-qavg)*(float(i)-qavg))
           pcent=100.*con*exp(tmp)
           if(pcent.gt.thresh) then
             numchs=numchs+1
             sqst(numchs)=float(i)
             pc(numchs)=pcent
             pcsum=pcsum+pcent
           endif
         enddo
         nqst=numchs
         f(9,1)=float(int(qavg))
         qavg=f(9,1)
         write(16,111) nqst,int(qavg)
         netac=nqst
111      format(1x,'Number of charge states after the foil ',I2,/,
     *           1x,'Average charge state: ',i3)
! FIRST TRAJECTORY HAS AVERAGE CHARGE STATE
         NTOT=0
         DO I=1,numchs
           NPCENT(I)=int(pc(i)*float(ngood)/100.)
           ntot=ntot+NPCENT(I)
         enddo
!*temp*2012 : before correction
!          DO I=1,numchs
!            write(16,122) sqst(i),npcent(i),pc(i)
!          enddo
! add missing number of particles to central charge state
         ncstat=numchs
!         write(16,*) ' ntot,ngood=',ntot,ngood,' particles'
         DO I=1,numchs
           if(int(sqst(i)) .eq. int(f(9,1))) then
              NPCENT(I)=NPCENT(I)+ngood-ntot
           endif
           cstat(i)=float(int(sqst(i)))
           charm(i)=cstat(i)
           write(16,122) sqst(i),npcent(i),pc(i)
         enddo
122      format(1x,'Charge=',f3.0,' with ',i7,' particles',
     *      ' or ',f12.7,' %')
         write(16,*) ' Total number of particles: ',ngood
         len=1
         i=2
         DO
           if(i.gt.ngood) exit
           DO
             call rlux(vecx,len)
             XARPHA=VECX(1)
             NCOUNT=int(XARPHA*(float(numchs)+0.5))
             IF(NCOUNT.gt.0) exit
           ENDDO
           IF(NPCENT(NCOUNT).gt.0) then
             NPCENT(NCOUNT)=NPCENT(NCOUNT)-1
             f(9,i)=float(int(sqst(NCOUNT)))
             i=i+1
           ENDIF
         ENDDO
       endif
       call cogetc
! ----  Change  dp/p over the stripper
       call disp
!
! ----  the new reference is the cog
       qcg=0.
       wcg=0.
       do i=1,ngood
         wcg=f(7,i)+wcg
         qcg=f(9,i)+qcg
       enddo
       wcg=wcg/float(ngood)
       gcg=wcg/xmat
       qcg=qcg/float(ngood)
       qmoy=qcg
       bref=sqrt(gcg*gcg-1.)/gcg
       vref=bref*vl
!----  new magnetic rigidity
       xmor=xmat*bref*gcg
       boro=33.356*xmor*1.e-01/qcg
       diff=(wcg-xmat)-wicg
       if(int(qs).eq.6 .or. int(qs).eq.3) then
         dav1(idav,5)=qavg
       else
         dav1(idav,5)=qmoy
       endif         
       dav1(idav,6)=diff
       dav1(idav,36)=ngood
       write(16,5420) wicg,-diff
5420   format(1x,'Energy of cog: at entrance: ',e12.5,' MeV',/,
     *  1x,'Energy loss of cog: ',e12.5,' MeV')
!   plots
       PRLAB(IPRF)='STRIPPER'
       CALL STAPL(davtot*10.)
       call emiprt(0)
       return
       end
!> *******************************************************************
!! SUBROUTINE randga(len,s,am,v)
!! generateur aleatoire selon une loi normale
!!         s : ecart-type de la distribution
!!         am: moyenne de la distribution
!!         v : nombre aleatoire selon la loi normale
!< *******************************************************************
       SUBROUTINE randga(len,s,am,v)
       implicit real(8) (a-h,o-z)
       dimension vecx(1)
       a=0.
       do i=1,24
         call rlux(vecx,len)
         y=vecx(1)
         a=a+y
       enddo
       v=(a-12.)*s+am
       return
       end
!> *******************************************************************
!! SUBROUTINE qelec(volt,xlqua,rs)
!! electrostatic quadrupole
!! space charge computation at the middle of the lens
!!       VOLT: electric voltage at pole tip (kV)
!!       XLQUA: effective length  (cm)
!!       RS: radial distance of pole tip from axis (cm)
!< *******************************************************************
       SUBROUTINE qelec(volt,xlqua,rs)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RIGID/BORO
       COMMON/FAISC/F(10,iptsz),IMAX,NGOOD
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON/DCSPA/IESP
       LOGICAL IESP
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       LOGICAL ICHAES
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       LOGICAL SHIFT
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/rander/ialin
       LOGICAL IALIN
       common/qskew/qtwist,iqrand,itwist,iaqu
       LOGICAL ITWIST
       common/femt/iemgrw,iemqesg
       LOGICAL IEMGRW
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/QSEX/L,KQ2,KS2
       common/tofev/ttvols
       COMMON/ITVOLE/ITVOL,IMAMIN
       logical itvol,imamin
       REAL(8) L,KQ2,KS2
       dimension trans(1)
       ilost=0
!      statistics
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
       write(16,*) ' ***QUADRUPOLE (electrostatic)***'
       write(16,*)
       fcpi=fh*180./pi
       if(itvol) write(16,10) ttvols*fcpi,davtot
10     FORMAT(' ** tof for adjustments at input: ',e12.5,
     *        ' deg at position: ',e12.5,' cm in lattice')
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
!  if itwist=.true. skews the quadrupole before misalignments (only if abs(volt) gt 1.e-13)
!     len = 1 level 1 in rlux routine
       len=1
       sqtwist=0.
       if(abs(volt).gt.1.e-13) then
         if(itwist) then
           if(iqrand.eq.0) then
             qtwrad=qtwist
             sqtwist=qtwrad
             call zrotat(qtwrad)
           else
             rdcf=.5
             call rlux(trans,len)
             if(trans(1).le.rdcf) sign=-1.
             if(trans(1).gt.rdcf) sign=1.
             call rlux(trans,len)
             qtwrad=qtwist*sign*trans(1)
             sqtwist=qtwrad
             call zrotat(qtwrad)
           endif
         endif
!   misalignments
         if(ialin) call randali
       endif
       idav=idav+1
       iitem(idav)=18
       dav1(idav,1)=xlqua*10.
       davtot=davtot+xlqua
       dav1(idav,4)=davtot*10.
       fh0=fh/vl
       gpa=0.
       do ii=1,ngood
        gpa=gpa+f(7,ii)/xmat
       enddo
       gpa=gpa/float(ngood)
       bet=sqrt(gpa*gpa-1.)/gpa
       l=xlqua
       eni=gpa*xmat
       qi=qst
!      electric rigidity (kV)
       rigid=eni*bet*bet/qi *1.e03
!     electric field gradient: xgrad (kV/cm-2)
        xgrad=2.*volt/rs**2
        dav1(idav,2)=volt
        dav1(idav,3)=rigid
        dav1(idav,5)=xgrad
!   qk2 (cm-2)
        kq2=xgrad/rigid
        dav1(idav,6)=kq2
        dav1(idav,7)=rs*10.
       write(16,100) xlqua,rs,volt,kq2,xgrad,rigid
100   format(' LENGTH = ',e12.5,' cm   APERTURE RADIUS= ',e12.5,' cm',
     *  /,' VOLTAGE = ',e12.5,' kV  K2 = ',e12.5,' cm-2  GRADIENT = ',
     *  e12.5,' kV/cm2',/,' RIGIDITY = ',e12.5,' kV',/)
        call clear
        call elqua(gpa)
!    print out the transport matrix (cog)
        call matrix
!      first half quadrupole
       l=xlqua/2.
       do ii=1,ngood
        call clear
        gpai=f(7,ii)/xmat
        bet=sqrt(gpai*gpai-1.)/gpai
        qi=f(9,ii)
!      electric rigidity (kV)
        rigi=f(7,ii)*bet*bet/qi *1.e03
!   qk2 (cm-2)
        kq2=xgrad/rigi
        call elqua(gpai)
        call cobeam(ii,l)
       enddo
!      space charge computations (if l >0)
       if(ichaes.and.l.gt.0.) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           iesp=.true.
           write(16,*) 'Space charge at the middle of the lens'
           call cesp(xlqua)
           iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
! Test window after the first half quadrupole (after s.c. computations)
       call cogetc
       bcour=0.
       do i=1,ngood
         gpai=f(7,i)/xmat
         bcour=sqrt(1.-1./(gpai*gpai))+bcour
       enddo
       bcour=bcour/float(ngood)
       gcour=1./sqrt(1.-bcour*bcour)
       wcg=(gcour-1.)*xmat
! ----- window control
       tref=tref+xlqua/(2.*vref)
       PRTLAB='QUAELEC '
       call reject(nlost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!    second half quadrupole
       do ii=1,ngood
         call clear
         gpa=f(7,ii)/xmat
         bet=sqrt(gpa*gpa-1.)/gpa
         qi=f(9,ii)
         rigi=f(7,ii)*bet*bet/qi *1.e03
         kq2=xgrad/rigi
         call elqua(gpa)
         call cobeam(ii,l)
       enddo
! Test window after the second half quadrupole
       call cogetc
       tref=tref+xlqua/(2.*vref)
       call reject(ilost,PRTLAB)
       ilost=ilost+nlost
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!  Change the t.o.f
       if(itvol) ttvols=tref
!  envelope
       PRLAB(IPRF)='QUAELEC '
       call stapl(davtot*10.)
       tcog=0.
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       if(itvol) then
        write(16,11) ttvols*fcpi,davtot,tref*fcpi,tcog*fcpi
11      FORMAT(' ** tof for adjustments: ',e12.5,
     *        ' deg at position: ',e12.5,' cm in the lattice',
     * /,3x,'tof of the reference: ',e12.5,' deg tof of the cog: ',
     * e12.5,' deg')
       else
        write(16,12) tref*fcpi,tcog*fcpi
12      FORMAT(' ** tof of the reference: ',e12.5,
     *        ' deg tof of the cog: ',e12.5,' deg')
       endif
       dav1(idav,36)=ngood
       write(16,*)' particles lost :',ilost
!  returns coordinates to the initial orientation
       if(itwist) then
        if(abs(volt).gt.1.e-13) then
         qtwrad=-sqtwist
         call zrotat(qtwrad)
        endif
       endif
       if(iemgrw) call emiprt(0)
!  envelope
       PRLAB(IPRF)='QUAELEC '
       call stapl(davtot*10.)
       return
       end
!> *******************************************************************
!! SUBROUTINE qfk (ityqu,arg,xlqua,rs)
!! electrostatic or magnetic quadrupole based on the strength K2
!! space charge computation at the middle of the lens
!!       ITYQU: ITYQU = 0 electric quadrupole, otherwise magnetic
!!              quadrupole
!!       ARG: strength K (cm-2)
!!       XLQUA: effective length  (cm)
!!       RS: radial distance of pole tip from the axis (cm)
!< *******************************************************************
       SUBROUTINE qfk (ityqu,arg,xlqua,rs)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/DYN/TREF,VREF
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/RIGID/BORO
       COMMON/FAISC/F(10,iptsz),IMAX,NGOOD
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON/DCSPA/IESP
       LOGICAL IESP
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       LOGICAL ICHAES
       common/tapes/in,ifile,meta,ierr
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/SHIF/DTIPH,SHIFT
       LOGICAL SHIFT
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/rander/ialin
       LOGICAL IALIN
       common/qskew/qtwist,iqrand,itwist,iaqu
       LOGICAL ITWIST
       common/femt/iemgrw,iemqesg
       LOGICAL IEMGRW
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/QSEX/L,KQ2,KS2
       common/tofev/ttvols
       COMMON/ITVOLE/ITVOL,IMAMIN
       common/qfkd/ityq
       logical itvol,imamin,ityq
       REAL(8) L,KQ2,KS2
       dimension trans(1)
       ilost=0
       if(ityqu.eq.0) ityq=.true.
       if(ityqu.ne.0) ityq=.false.
       if(ityq) then
         write(16,*) ' ***QUADRUPOLE (electrostatic)***'
       else
         write(16,*) ' ***QUADRUPOLE (magnetic)***'
       endif
!      statistics
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(davtot*10.)
       endif       
       xfqu=arg
       fcpi=fh*180./pi
       if(itvol) write(16,10) ttvols*fcpi,davtot
10     FORMAT(' ** tof at input: ',e12.5,
     *        ' deg  position in the lattice: ',e12.5,' cm ')
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
!  if itwist=.true. skews the quadrupole before misalignments (only if abs(arg) gt 1.e-13)
!     len = 1 level 1 in rlux routine
       len=1
       sqtwist=0.
       if(abs(xfqu).gt.1.e-13) then
         if(itwist) then
           if(iqrand.eq.0) then
             qtwrad=qtwist
             sqtwist=qtwrad
             call zrotat(qtwrad)
           else
             rdcf=.5
             call rlux(trans,len)
             if(trans(1).le.rdcf) sign=-1.
             if(trans(1).gt.rdcf) sign=1.
             call rlux(trans,len)
             qtwrad=qtwist*sign*trans(1)
             sqtwist=qtwrad
             call zrotat(qtwrad)
           endif
         endif
!     misalignments
         if(ialin) call randali
       endif
       idav=idav+1
       iitem(idav)=19
       dav1(idav,1)=xlqua*10.
       davtot=davtot+xlqua
       dav1(idav,4)=davtot*10.
       fh0=fh/vl
       gpa=0.
       do ii=1,ngood
        gpa=gpa+f(7,ii)/xmat
       enddo
       gpa=gpa/float(ngood)
       bet=sqrt(gpa*gpa-1.)/gpa
       l=xlqua
       eni=gpa*xmat
       qi=qst
       if(ityq) then
!   electrostatic quadrupole
!  rigid: electric momentum (kV)
        rigid=eni*bet*bet/qi * 1.e03
!    compute the electric voltage VOLT (kV) from K(cm-2)
        volt=xfqu*rs*rs*rigid
        volt=volt/2.
!   kq2 (cm-2)
        kq2=xfqu
!     electric field gradient: xgrad (kV/cm2)
        xgrad=kq2*rigid
        dav1(idav,2)=volt
        dav1(idav,3)=rigid
        dav1(idav,5)=xgrad
        dav1(idav,6)=xfqu
        dav1(idav,7)=rs*10.
        call clear
        call elqua(gpa)
       write(16,100) xlqua,rs,volt,xfqu,xgrad,rigid
100   format(' LENGTH = ',e12.5,' cm   APERTURE RADIUS= ',e12.5,' cm',
     * /,' VOLTAGE = ',e12.5,' kV  K2 = ',e12.5,' cm-2  GRADIENT = ',
     *  e12.5,' kV/cm2',/,' MOMENTUM = ',e12.5,' kV',/)
!    print the transport matrix (of the cog)
        call matrix
       else
!     magnetic quadrupole
        xmco=xmat*bet*gpa
!       rigid: magnetic rigidity (kG.cm)
        rigid=33.356*xmco*1.e-01/qst
        kq2=xfqu
!   bgrad: gradient (kG/cm)
        bgrad=kq2*rigid
!       bgaus: field (kG)
        bgaus=bgrad*rs
        dav1(idav,2)=bgaus
        dav1(idav,3)=rigid
        dav1(idav,5)=bgrad
        dav1(idav,6)=xfqu
        dav1(idav,7)=rs*10.
        call clear
        call elqua(gpa)
        write(16,3300) xlqua,rs,bgaus,xfqu,bgrad,rigid
3300   format(' LENGTH = ',e12.5,' cm   APERTURE RADIUS= ',e12.5,' cm',
     * /,' FIELD = ',e12.5,' kG  K2 = ',e12.5,' cm-2  GRADIENT = ',
     *  e12.5,' kG/cm',/,' MOMENTUM = ',e12.5,' kG.cm',/)
        call matrix
       endif
!      first half quadrupole
       l=xlqua/2.
       do ii=1,ngood
        call clear
        gpai=f(7,ii)/xmat
        bet=sqrt(gpai*gpai-1.)/gpai
        qi=f(9,ii)
        if(ityq) then
! electric quadrupole
!   rigi: momentum (kV)
         rigi=f(7,ii)*bet*bet/qi * 1.e03
!   qk2 (cm-2)
         kq2=xgrad/rigi
         call elqua(gpai)
         call cobeam(ii,l)
        else
! magnetic quadrupole
         xmco=xmat*bet*gpa
!    rigi: momentum (kG.cm)
         rigi=3.3356*xmco/f(9,ii)
!    kq2 (cm-2)
         kq2=bgrad/rigi
         call elqua(gpai)
         call cobeam(ii,l)
        endif
       enddo
!      space charge computations (if l >0)
       if(ichaes.and.l.gt.0.) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           iesp=.true.
           write(16,*) 'Space charge at the middle  '
           call cesp(xlqua)
           iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
! Test window after the first half quadrupole (after s.c. computations)
       call cogetc
       bcour=0.
       do i=1,ngood
         gpai=f(7,i)/xmat
         bcour=sqrt(1.-1./(gpai*gpai))+bcour
       enddo
       bcour=bcour/float(ngood)
       gcour=1./sqrt(1.-bcour*bcour)
       wcg=(gcour-1.)*xmat
! ----- convert window control
       tref=tref+xlqua/(2.*vref)
       PRTLAB='QUAFK   '
       call reject(nlost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!    second half quadrupole
       do ii=1,ngood
        call clear
        gpai=f(7,ii)/xmat
        bet=sqrt(gpai*gpai-1.)/gpai
        qi=f(9,ii)
        if(ityq) then
! electric quadrupole
!     rigi (kV)
         rigi=f(7,ii)*bet*bet/qi * 1.e03
!   qk2 (cm-2)
         kq2=xgrad/rigi
         call elqua(gpai)
         call cobeam(ii,l)
        else
! magnetic quadrupole
         xmco=xmat*bet*gpa
!    rigi: momentum (kG.cm)
         rigi=3.3356*xmco/f(9,ii)
!    kq2 (cm-2)
         kq2=bgrad/rigi
         call elqua(gpai)
         call cobeam(ii,l)
        endif
       enddo
! Test window after the second half quadrupole
       call cogetc
       tref=tref+xlqua/(2.*vref)
       call reject(ilost,PRTLAB)
       ilost=ilost+nlost
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!  Change the t.o.f
       if(itvol) ttvols=tref
!  envelope
       PRLAB(IPRF)='QUAFK   '
       call stapl(davtot*10.)
       tcog=0.
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       if(itvol) then
        write(16,11) ttvols*fcpi,davtot,tref*fcpi,tcog*fcpi
11      FORMAT(' ** tof for adjustments: ',e12.5,
     *        ' deg at position: ',e12.5,' cm in the lattice',
     * /,3x,'tof of the reference: ',e12.5,' deg tof of the cog: ',
     * e12.5,' deg')
       else
        write(16,12) tref*fcpi,tcog*fcpi
12      FORMAT(' ** tof of the reference: ',e12.5,
     *        ' deg tof of the cog: ',e12.5,' deg')
       endif
       dav1(idav,36)=ngood
       write(16,*)' particles lost :',ilost
!  returns coordinates to the initial orientation
       if(itwist) then
        if(abs(xfqu).gt.1.e-13) then
         qtwrad=-sqtwist
         call zrotat(qtwrad)
        endif
       endif
       if(iemgrw) call emiprt(0)
!  envelope
       PRLAB(IPRF)='QUAFK   '
       call stapl(davtot*10.)
       return
       end
!> *******************************************************************
!! SUBROUTINE cavnum
!! numerical computations of the dynamic in cavities or gap
!! the field can be read from the disk on the form: (z,E(z)
!! or it can be read in the command list on the form of a Fourier
!! series expansion
!< *******************************************************************
       SUBROUTINE cavnum
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell=3000,maxcell1=4004)
       COMMON/TTFS/DYNT(MAXCELL),DYNTP(MAXCELL),DYNTPP(MAXCELL),
     *   DYNE0(MAXCELL),DYNPH(MAXCELL),DYNLG(MAXCELL),FHPAR,NC
       COMMON/POSI/IST
       COMMON/MIDGAP/ENMIL,VAPMI
       COMMON/AZMTCH/DLG,XMCPH,XMCE
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
!      TRANSIT TIME COEFFICIENTS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/cavnum1/xnh,xpas,ffield,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/rfield/ifield
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/compt1/ndtl,ncavmc,ncavnm
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/speda/dave,idave
       COMMON/SHIF/DTIPH,SHIFT
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/DCSPA/IESP
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       common/appel/irstay,ilost,iavp,ispcel
       common/femt/iemgrw,iemqesg
!       common/mode/eflvl,rflvl
       common/aerp/vphase,vfield,ierpf
       common/tofev/ttvols
       common/elec/jelec
       common/step/istep
!  ****************************************************************
       common/xposi/xpost(10),xlce(2),xpax(2),iscx(2)
       common/kcell/avrg(15)
!********************************************
! reservation for TRACE3D related stuff
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/t3dfld/fldctr(15),zend(15),T3D
       logical T3D
       character trace3h*128,trace3t*128,tif*128,frmt*128
!********************************************
       common/xitrd3/bcour1(15),bcour2(15),tr3dw(15),tr3ph(15),
     *  t0tr3d(15)
       logical iesp,ichaes,irstay,iavp,ispcel,ifield,iemgrw
       LOGICAL SHIFT,CHASIT,ITVOL,IMAMIN,DAVE,JELEC
!************************************************************
!    XESLN : NEGATIVE LENGTH OF THE DRIFT FOLLOWING THE GAP
!    IF XESLN N.E.0 THEN THE CHARGE SPACE EFFECT AFFECTS THE
!    LENGTH (YLG-XESLN)
       NRRES=NRRES+1
       ncavnm=ncavnm+1
! allow for print out on terminal of gap# on one and the same line
       call progress(NRTRE,NRRES)
       WRITE(16,*)' CAVITY N :',NRRES
       ilost=0
       aqst=abs(qst)
       qmoy=aqst
! --- the frequency fh may be changed with delfh
       oldfh=fh
!        IDUM : dummy variable (indicate in input file the number of the cavity)
         READ (IN,*) IDUM
!
!      ielec = 0 acceleration for non relativistic particles with erest < 1 MeV (e.g. non-relativistic electrons)
!                otherwise acceleration for hadrons
!      dphase (deg): phase offset from the phase crest (giving the maximum of energy gain)
!      FFIELD : in percent;
!                    (electric field)=(initial electric field)*(1.+FFIELD/100)
        jelec=.false.
        read (in,*) dielec,dphase,ffield,istep,ielec
! *********************************************************
!  SV  28/10/2015
        if(ncavnm.eq.1) then
          write(13,990)
990       format('#',2x,'ncav',2x,'ncell',2x,'pos I(cm)',4x,
     *    'pos S(cm)',6x,'L cell(cm)',5x,'W(MeV)',7x,'dw(MeV)',6x,
     *    'TOF(dg)',7x,'Ph RF(dg)',5x,'avrg pos(cm)')
          write(13,995)
995       format('#',2x,'ncell',3x,'E0TL(MeV)',5x,'Tk(MeV/q)',5x,
     *    'Sk(MeV/q)',5x,'dW(MeV)',6x,'PHASE(dg)',4x,
     *    'Ph crest(dg)')
!     *    'Ph crest(dg)',5x,'To')
        endif
        write(13,*)
! ***************************************************************
        if(ielec.eq.0) jelec=.true.
        ffield=1.+ffield/100.
        fprec=epsilon(ffield)
!        if(ffield.eq.0.) ffield=1.E-12
        if(abs(ffield).le.fprec) ffield=1.E-12
       if(ifield) then
! --- The field is read from the disk in the form:
!          z   (cm)   E(z) MV/m
!     fhc: frequency of the cavity (Hertz) (read in the file 'field.txt' )
         fh=fhc*2.*pi
         ncel=ncell
         atte=att
         ye0=atte
!    flength : length of the field (cm)
         flength=xspl(npt)-xspl(1)
         ylg=flength
       else
! --- The field is read from the input list in the form of a Fourier series
         ncell=ncel
         oldfh=fh
!     atte: factor acting on the amplitude of the field (read in the input list)
         ye0=atte
       endif
       dphete=dphase
       if(itvol.and.imamin) then
! ---  adjustment of the phase offset w.r.t. the t.o.f.  (deg)
        ottvol=fh*ttvols*180./pi
        attvol=ottvol
        xkpi=ottvol/360.
        ixkpi=int(xkpi)
        xkpi=(xkpi-float(ixkpi))*360.
        dphase=dphase-xkpi
       endif
       WRITE(16,150)FH/(2.*pi),YLG,ATTE,ffield,NCEL,istep
150    FORMAT(4X,'FREQUENCY :',E12.5,' Hertz',/,4x,
     x        'FIELD LENGTH :',e12.5,' cm',/,4x,
     x        'FIELD FACTOR (UNITS CONVERSION) :',e12.5,/,4x,
     x        'FIELD FACTOR (ATTENUATION)      :',E12.5,/,4x,
     X        'FIELD DIVIDED IN: ',I4,' CELLS,  STEPS PER CELL ',i5)
       if(.not.imamin) write(16,*) '   PHASE OFFSET: ',dphete,' DEG'
       if(imamin) write(16,1501)dphete,DPHASE,xkpi
1501   format(4x,
     x        'PHASE OFFSET (before adjustment): ',e12.5,' deg',/,4x,
     x        'PHASE OFFSET (after adjustment): ',e12.5,' deg',/,4x,
     *        'ADJUSTMENT ON THE PHASE OFFSET: ',e12.5,' deg')
       fh0=fh/vl
       BEREF=VREF/VL
! --- ttvol: time of flight at entrance (sec)
       ttvol=0.
       if(itvol)ttvol=ttvols*fh
!  start file 'short.data'
! --- dav1(idav,3)=0: the particle reference and the cog coincide at the input
! --- dav1(idav,3)=1: the particle reference and the cog are independent
       idav=idav+1
       iitem(idav)=1
       dav1(idav,1)=ylg*10.
       dav1(idav,2)=ye0*100.
       davtot=davtot+ylg
       dav1(idav,24)=davtot*10.
       dav1(idav,40)=fh
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(dav1(idav,24))
       endif       
       iarg=1
       call cdg(iarg)
       enold=cog(1)
       encog=enold
       gcog=enold/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       IF(SHIFT) THEN
! --- the reference particle and the cog are independent
         BEREF=VREF/VL
         GAMREF=1./SQRT(1.-(BEREF*BEREF))
         ENREF=XMAT*GAMREF
         TREFDG=TREF*FH*180./PI
         dav1(idav,3)=1.
       ELSE
! --- the reference particle and the cog are coinciding
         beref=bcog
         vref=bcog*vl
         tref=tcog
         gamref=gcog
         enref=cog(1)
         dav1(idav,3)=0.
       ENDIF
       if(int(dav1(idav,3)).eq.1) write(16,*)
     *   ' ****reference and cog evolve independently'
       if(int(dav1(idav,3)).eq.0) write(16,*)
     *   ' **** the reference is the cog '
       WRITE(16,178)
178    FORMAT(/,' Dynamics at the input',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
       WRITE(16,1788) bcog,gcog,encog-xmat,tcog*fh*180./pi,tcog
1788   FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       ENRPRIN=ENREF-XMAT
       WRITE(16,165) beref,gamref,ENRPRIN,tref*fh*180./pi,tref
165    FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       iprint=0
       call statis
       XK1=FH/VREF
! ---  transit time factors TK and SK  based on the velocity at the entrance
       TK=TTA0(BEREF)/2. * FFIELD
       SK=TSB0(BEREF)/2. * FFIELD
! --- prediction of PCREST (phase of RF giving the maximum of energy gain in the cavity)
       PCREST=ATAN(-SK/TK)
       DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
       IF(DDWC.LT.0.) PCREST=PCREST+PI
! --- first correction of pcrest based on an average beta
       call phcrest(pcrest,ylg,ncell,zcrest)
!    avbet: average value of beta
       avbet=fh/(zcrest*vl)
       tk=tta0(avbet)/2. * ffield
       sk=tsb0(avbet)/2. * ffield
       PCREST=ATAN(-SK/TK)
       DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
       IF(DDWC.LT.0.) PCREST=PCREST+PI
!  final correction of the phase crest PCREST
       call phcrest1(pcrest,ylg,ncell,dwmx)
!   phase at the entrance of the cavity
       DPHASE=DPHASE*PI/180.
       phi0=pcrest+dphase+ttvol
! --- compute energy and TOF of reference
! ******************************************
       call dwref(phi0,gams,ts)
! ********************************************
       enrs=gams*xmat
       ddw=enrs-enref
       if(t3d) then
         do klm=1,ncel
           trphase=tr3ph(klm)
           tre0tl=t0tr3d(klm)/aqst
!c split cell into drif-gap-drift
!c debugging to be done: include q/m !! !! protons assumed for now
           kt3t=kt3t+1
! drift
           write(tif,6001) kt3t,kt3t,10.*fldctr(klm)
6001       format('  nt(',i4,')= 1, a(1,',i4,')=',f12.6)
           trace3t(kt3t)=tif
!
           kt3t=kt3t+1
! gap
           write(tif,6005) kt3t,kt3t,tre0tl,trphase,fid
6005       format('  nt(',i4,')=10, a(1,',i4,')=',f9.5,' , ',f9.2,
     &        ', 0., 1.,',f5.3,',')
           trace3t(kt3t)=tif
!
           kt3t=kt3t+1
! drift
           write(tif,6001) kt3t,kt3t,10.*zend(klm)
           trace3t(kt3t)=tif
         enddo
       endif
! end trace3d drift-gap-drift
!
       trefs=ts+tref
       bets=sqrt(gams*gams-1.)/gams
!old       bets=b5
       TREDG=fh*TREFS *180./PI
!  dynamic of the bunch
       call bcnum(phi0,ylg,ncell)
! -----  window control
         gcg=0.
         do i=1,ngood
           gcg=gcg+f(7,i)/xmat
         enddo
         gcg=gcg/float(ngood)
         bcg=sqrt(1.-1./(gcg*gcg))
         wcg=(gcg-1.)*xmat
         call cogetc
!omment  twind=0.
         do i=1,ngood
           gpai=f(7,i)/xmat
           if(gpai.lt.1.) gpai=1.
           bpai=sqrt(1.-1./(gpai*gpai))
           fd(i)=bpai/bcg * gpai/gcg
!omment    twind=twind+f(6,i)
         enddo
!omment  twind=twind/float(ngood)
! ---- window control
       tref=trefs
       vref=bets*vl
       PRTLAB='CAVNUM  '
       call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
       write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
       write(16,*) '***********************************************'
       write(16,*) ' ENERGY GAIN(MeV) ',DDW,' TOF ',tredg,' DEG'
       write(16,*) ' PHASE OF RF AT ENTRANCE(DG) ',phi0*180./pi
       write(16,*) ' CREST PHASE OF RF (DEG) ',PCREST*180./PI
       iarg=1
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       CALL EXT2D(1)
       if(itvol) then
        dav1(idav,38)=dphete
        dav1(idav,39)=dphase*180./pi
       else
        dav1(idav,38)=dphete
       endif
       WRITE(16,3777)
3777   FORMAT(/,' Dynamics at the output',/,
     1 5X,'   BETA     dW(MeV)     ENERGY(MeV) ',
     2 '   TOF(deg)     TOF(sec)')
       engain=encog-enold
       WRITE(16,3473) bets,ddw,enrs-xmat,fh*TREFS *180./PI,TREFS
3473   FORMAT(' REF ',f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)
       WRITE(16,1789) bcog,engain,encog-xmat,tcog*fh*180./pi,tcog
1789   FORMAT(' COG ',f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)
       TESTCA=exten(1)*exten(2)*exten(3)
!       epsil=1.E-20
       epsil=1.E-40
       IF(abs(TESTCA).gt.epsil) THEN
         QDISP=2.*SQRT(exten(1))
         QMD=exten(1)*exten(3)-exten(2)**2
         SQMDV=4.*PI*SQRT(QMD)
         SURM=4.*PI*SQRT(QMD)*180./PI
         QDP=2.*SQRT(exten(3))
         COR12=exten(2)/sqrt(exten(1)*exten(3))
         QDPDE=QDP*180./PI
       ELSE
         QDISP=0.
         QMD=0.
         SQMDV=0.
         SURM=0.
         QDP=0.
         COR12=0.
         PENT12=0.
         PENT21=0.
         QDPDE=0.
       ENDIF
       TRQTX=exten(4)*exten(5)-exten(8)**2
       TRQPY=exten(6)*exten(7)-exten(9)**2
       QDITAX=2.*SQRT(exten(4))
       QDIANT=2.*SQRT(exten(5))
       QDITAY=2.*SQRT(exten(6))
       QDIANP=2.*SQRT(exten(7))
       SURXTH=4.*PI*SQRT(TRQTX)
       SURYPH=4.*PI*SQRT(TRQPY)
       IF(SHIFT) THEN
         vref=bets*vl
         tref=trefs
       ELSE
         vref=bcog*vl
         tref=tcog
       ENDIF
       if(itvol) ttvols=tref
       call statis
!      ENVEL
       PRLAB(IPRF)='CAVNUM  '
       CALL STAPL(dav1(idav,24))
       dav1(idav,16)=bcog*surxth*10./(pi*sqrt(1.-bcog*bcog))
       dav1(idav,21)=bcog*suryph*10./(pi*sqrt(1.-bcog*bcog))
       dav1(idav,25)=nrres
       dav1(idav,30)=ngood
!
!   print to the file: 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!
! --- dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
! --- dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
       emns=1.e12*sqmdv/(pi*fh)
       trfprt=fh*tref*180./pi
       tcgprt=fh*tcog*180./pi
! cavity number, z (m), transmission (%), synchronous phase (deg), time of flight (deg) (within -180 deg and 180 deg),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
       trnsms=100.*float(ngood)/float(imax)
       if(ncavnm.eq.1) write(50,*) '# cavnum.dmp'
       if(ncavnm.eq.1) write(50,*) '# cav     Z       trans   ',
     *   'PHIs     TOF(COG)    COG        Wcog          TOF(REF)   ',
     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
     *   'El,RMS        dWref        EffVolt'
       if(ncavnm.eq.1) write(50,*) '#  #     (m)       (%)    ',
     *  '(deg)     (deg)      beta       (MeV)          (deg)      ',
     *  '   beta       (MeV)       (mm.mrad)    (mm.mrad)    ',
     *  '(ns.keV)      (MeV)          (MV)'
       write(50,7023) nrres,0.001*dav1(idav,24),trnsms,dphete,
     *  tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat,
     *  0.25*dav1(idav,16),0.25*dav1(idav,21),0.25*emns,ddw,dwmx
7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
     *   2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x))
       fh=oldfh
!       new magnetic rigidity of the reference
       gref=1./sqrt(1.-bets*bets)
       xmor=xmat*bets*gref
       BORO=33.356*XMOR*1.E-01/AQST
       WRITE(16,*) ilost,' particles lost in cavity ',nrres
       call emiprt(0)
       return
       end
!> *******************************************************************
!! SUBROUTINE phcrest(phi0,ylg,ncell,zcrest)
!! REFERENCE:
!! average k (cm-1)
!< *******************************************************************
       SUBROUTINE phcrest(phi0,ylg,ncell,zcrest)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       COMMON/DYN/TREF,VREF
!   ylg(cm) length of cavity, xpas(cm): step length
!   8 steps over a cell
       npas=ncell*10
       xpas=ylg/float(npas)
       e0=xmat
       b0=vref/vl
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       t0=0.
       gam0=1./sqrt(1.-b0*b0)
       xnh=0.
       estop=xpas/10.
       DO
         xpat=xnh*xpas
         if(xpat.lt.(ylg-estop)) then
           call fposb
! ---  enegy gain over the step
!   predictor of energy gain
           b1=b0
           b2=b0
           b3=b0
           b4=b0
           b5=b0
           dgam=xi1(phi0,t0,t5)*qst/e0
           gam5=gam0+dgam
!   corrector of energy gain
           xpas2=xpas*xpas
           dgdz=qst/e0 * tspl0
           d2gdz2=dgam/xpas2-dgdz/xpas
           d2gdz2=2.*d2gdz2
           gam1=gam0+dgdz*xpas/5.+d2gdz2*xpas2/50.
           gam2=gam0+dgdz*xpas*2./5.+d2gdz2*xpas2*4./50.
           gam3=gam0+dgdz*xpas*3./5.+d2gdz2*xpas2*9./50.
           gam4=gam0+dgdz*xpas*4./5.+d2gdz2*xpas2*16./50.
           b1=sqrt(gam1*gam1-1.)/gam1
           b2=sqrt(gam2*gam2-1.)/gam2
           b3=sqrt(gam3*gam3-1.)/gam3
           b4=sqrt(gam4*gam4-1.)/gam4
           b5=sqrt(gam5*gam5-1.)/gam5
           dgam=xi1(phi0,t0,t5)*qst/e0
           gam5=gam0+dgam
           b5=sqrt(gam5*gam5-1.)/gam5
           b0=b5
           t0=t5
           gam0=gam5
           xnh=xnh+1.
         else
           exit
         endif
       ENDDO    
!   compute an average k: zcrest
       zcrest=fh*t5/ylg
       return
       end
!> *******************************************************************
!! SUBROUTINE phcrest1(phi0,ylg,ncell)
!! REFERENCE:
!! computation of the phase giving the maximum energy gain)
!< *******************************************************************
       SUBROUTINE phcrest1(phi0,ylg,ncell,dwmx)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       COMMON/DYN/TREF,VREF
       dimension stx(400),sty(400),sts(400),stp(400),stq(400)
       dimension phc(100),wph(100)
!   ylg(cm) length of cavity, xpas(cm): step length
       npas=ncell*10
       xpas=ylg/float(npas)
       e0=xmat
       rad=pi/180.
       dph=rad
       dph1=rad
       dplim=rad*0.01
       pmax=phi0+10.*rad
       pmin=phi0-10.*rad
       ibcl=1
       phi=pmin
       DO
         if(phi.ge.pmax) EXIT
         phc(ibcl)=phi
         b0=vref/vl
         b1=b0
         b2=b0
         b3=b0
         b4=b0
         b5=b0
         t0=0.
         gam0=1./sqrt(1.-b0*b0)
         wwref=(gam0-1.)*e0
         xnh=0.
         DO
           if(xnh*xpas.ge.ylg) EXIT
           call fposb
! ---  energy gain over the step
!   predictor of energy gain
           b1=b0
           b2=b0
           b3=b0
           b4=b0
           b5=b0
           dgam=xi1(phi,t0,t5)*qst/e0
           gam5=gam0+dgam
!   corrector
           xpas2=xpas*xpas
           dgdz=qst/e0 * tspl0
           d2gdz2=dgam/(xpas2)-dgdz/xpas
           d2gdz2=2.*d2gdz2
           gam1=gam0+dgdz*xpas/5.+d2gdz2*xpas2/50.
           gam2=gam0+dgdz*xpas*2./5.+d2gdz2*xpas2*4./50.
           gam3=gam0+dgdz*xpas*3./5.+d2gdz2*xpas2*9./50.
           gam4=gam0+dgdz*xpas*4./5.+d2gdz2*xpas2*16./50.
           b1=sqrt(gam1*gam1-1.)/gam1
           b2=sqrt(gam2*gam2-1.)/gam2
           b3=sqrt(gam3*gam3-1.)/gam3
           b4=sqrt(gam4*gam4-1.)/gam4
           b5=sqrt(gam5*gam5-1.)/gam5
           dgam=xi1(phi,t0,t5)*qst/e0
           gam5=gam0+dgam
           b5=sqrt(gam5*gam5-1.)/gam5
           b0=b5
           t0=t5
           gam0=gam5
           xnh=xnh+1.
         ENDDO
         wwpcr=(gam0-1.)*e0
         dwcpr=wwpcr-wwref
         wph(ibcl)=dwcpr
         phi=phi+dph
         ibcl=ibcl+1
       ENDDO  
       ibcl=ibcl-1
!     save spline areas (partial save)
       do i=1,400
         stx(i)=xspl(i)
         sty(i)=yspl(i)
         sts(i)=s(i)
         stp(i)=p(i)
         stq(i)=q(i)
       enddo
!     padding spline areas
       dwmx=wph(1)
       do i=1,ibcl
         xspl(i)=phc(i)
         yspl(i)=wph(i)
         if(wph(i).gt.dwmx)dwmx=wph(i)
       enddo
       call deriv2(ibcl)
       i=1
       phi=xspl(1)
       yfb=slope(ibcl,phi)/100.
       DO
         if(phi.ge.xspl(ibcl)) EXIT
         if(dph1.le.dplim) EXIT
         yf=slope(ibcl,phi)
         if(yf.gt.0.) then
           phi=phi+dph1
         else
           phi=phi-dph1
           dph1=dph1/2.
           phi=phi+dph1
         endif
       ENDDO  
       phi0=phi
!     restore spline areas (partial save)
       do i=1,400
         xspl(i)=stx(i)
         yspl(i)=sty(i)
         s(i)=sts(i)
         p(i)=stp(i)
         q(i)=stq(i)
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE dwref(phi0,gam5,t5)
!! compute the energy gain and the time of flight of the reference
!! over the cavity(gap) at the exit of the cavity(gap):
!! gam4 = relativistic gamma,  t4 = tof (cavity)
!< *******************************************************************
       SUBROUTINE dwref(phi0,gam5,t5)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/cavnum7/sspl0,sspl1,sspl2,sspl3,sspl4,sspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       COMMON/DYN/TREF,VREF
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/step/istep
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/kcell/avrg(15)
       common/xitrd3/bcour1(15),bcour2(15),tr3dw(15),tr3ph(15),
     *  t0tr3d(15)
       common/sphi/tcour1(15),tcour2(15)
       common/t3dfld/fldctr(15),zend(15),T3D
       logical T3D
!  save previous xpas
       aqst=abs(qst)
       xpcel=xpas
       xlpos=0.
       isce=20
       xlcum=0.
       b0=vref/vl
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       t0=0.
!   xlcel (cm): length of current cell
!   xlim(inc) cm: limits of current cell
!   isce: step number in cell (forced isce = 20)
!   wdgam: energy gain over the cell
! **************************************
       do inc=1,ncell
        bcour1(inc)=b0
        tcour1(inc)=t0
        wdgams=0.
        xnh=0.
        xlcel=xlim(inc+1)-xlim(inc)
        xlpos=xlpos+xlcel
        xpas=xlcel/float(isce)
        e0=xmat
        xnhc=0
        gam0=1./sqrt(1.-b0*b0)
        estop=xpas/10.
        istop=0
        DO
          xpat=xnhc*xpas
          if(xpat.ge.(xlcel-estop)) EXIT
          call fposbb(xlcum)
! ---  energy gain over the step
          b1=b0
          b2=b0
          b3=b0
          b4=b0
          b5=b0
! predictor
          dgam=xi1(phi0,t0,t5)*aqst/e0
          gam5=gam0+dgam
!   corrector
          xpas2=xpas*xpas
          dgdz=aqst/e0 * tspl0
          d2gdz2=dgam/xpas2-dgdz/xpas
          d2gdz2=2.*d2gdz2
          gam1=gam0+dgdz*xpas/5.+d2gdz2*xpas2/50.
          gam2=gam0+dgdz*xpas*2./5.+d2gdz2*xpas2*4./50.
          gam3=gam0+dgdz*xpas*3./5.+d2gdz2*xpas2*9./50.
          gam4=gam0+dgdz*xpas*4./5.+d2gdz2*xpas2*16./50.
          b1=sqrt(gam1*gam1-1.)/gam1
          b2=sqrt(gam2*gam2-1.)/gam2
          b3=sqrt(gam3*gam3-1.)/gam3
          b4=sqrt(gam4*gam4-1.)/gam4
          b5=sqrt(gam5*gam5-1.)/gam5
          dgam=xi1(phi0,t0,t5)*aqst/e0
          gam5=gam0+dgam
          eww=xmat*(gam5-1.)
          wdgam=xmat*dgam
          wdgams=wdgams+wdgam
          b5=sqrt(gam5*gam5-1.)/gam5
          b0=b5
          t0=t5
          gam0=gam5
          xnh=xnh+1.
          xnhc=xnhc+1.
       ENDDO  
       tcour2(inc)=t5
       xlcum=xlcum+xlcel
       ttvol=t5*fh*180./pi
       ttphi=ttvol+tref*fh*180/pi
       bcour2(inc)=b5
       tr3dw(inc)=wdgams
! ************************************************
       write(13,101) NRRES,inc,xlim(inc),xlim(inc+1),
     *  xlcel,eww,wdgams,ttvol,ttphi,avrg(inc)
101    format(2(2x,i4),8(2x,e12.5))
         fldctr(inc)=avrg(inc)-xlim(inc)
         zend(inc)=xlcel-fldctr(inc)
       enddo
       call itrd3
! restore  xpas
       xpas=xpcel
       return
       end
!> *******************************************************************
!! SUBROUTINE itrd3
!< *******************************************************************
       SUBROUTINE itrd3
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/xitrd3/bcour1(15),bcour2(15),tr3dw(15),tr3ph(15),
     *  t0tr3d(15)
       common/cavnum1/xnh,xpas,ffield,npt
       common/sphi/tcour1(15),tcour2(15)
       common/kcell/avrg(15)
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       dimension ttr3d(15),str3d(15)
       do nrc=1,ncell
         bcour=(bcour1(nrc)+bcour2(nrc))/2.
         ttr3d(nrc)=ta0(bcour,nrc)
       enddo
       do nrc=1,ncell
         bcour=(bcour1(nrc)+bcour2(nrc))/2.
         str3d(nrc)=sb0(bcour,nrc)
       enddo
       do nrc=1,ncell
         t0tr3d(nrc)=qst*sqrt(ttr3d(nrc)**2+str3d(nrc)**2)*ffield/2.
         atr3d=0.
         tt=tr3dw(nrc)/t0tr3d(nrc)
         tph=atan(-str3d(nrc)/ttr3d(nrc))
         if(tt.lt.1.) atr3d=acos(tt)
         ddw=ttr3d(nrc)*cos(tph)-str3d(nrc)*sin(tph)
         if(ddw.lt.0.) then
           tph=tph+pi
         endif
!         if(tph.ge.pcrest) atr3d=-atr3d
         drift1=avrg(nrc)-xlim(nrc)
         drift2=xlim(nrc+1)-avrg(nrc)
         xsign1=tcour2(nrc)-tcour1(nrc)
         xsing=xsign1-(drift1/bcour1(nrc)+drift2/bcour2(nrc))/vl
         if(xsing.gt.0.) atr3d=-atr3d
         tr3ph(nrc)=atr3d*180./pi
         write(13,100)nrc,t0tr3d(nrc),ttr3d(nrc),str3d(nrc),tr3dw(nrc)
     *              ,atr3d*180./pi,tph*180./pi
100      format(2x,i4,6(2x,e12.5))
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE fposbbb(xlcum,fposs,jx)
!! electric field at the 6 Bode's positions in the step (see routine
!! dwref)
!< *******************************************************************
       SUBROUTINE fposbbb(xlcum,fposs,jx)
       implicit real(8) (a-h,o-z)
       common/tapes/in,ifile,meta,ierr
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/cavnum6/fpos0,fpos1,fpos2,fpos3,fpos4,fpos5
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/rfield/ifield
       common/xposi/xpost(10),xlce(2),xpax(2),iscx(2)
       logical ifield
       fprec=epsilon(fposs)
!       if(fposs.eq.0.) then
       if(abs(fposs).le.fprec) then
         fpos0=xnh*xpas+xlcum+fposs
         fpos1=(xnh+0.20)*xpas+xlcum+fposs
         fpos2=(xnh+0.40)*xpas+xlcum+fposs
         fpos3=(xnh+0.60)*xpas+xlcum+fposs
         fpos4=(xnh+0.80)*xpas+xlcum+fposs
         fpos5=(xnh+1.0)*xpas+xlcum+fposs
       else
         fpos0=xnh*xpas+fposs
         fpos1=(xnh+0.20)*xpas+fposs
         fpos2=(xnh+0.40)*xpas+fposs
         fpos3=(xnh+0.60)*xpas+fposs
         fpos4=(xnh+0.80)*xpas+fposs
         fpos5=(xnh+1.0)*xpas+fposs
       endif
       if(jx.eq.1)then
         xnh1=xnh+1
!         if(xnh1.eq.float(iscx(jx))) fposs=fpos5
         if(abs(xnh1-float(iscx(jx))).le.fprec) fposs=fpos5
       endif
       if(ifield) then
! --- the field was read from disk in MV/cm
         tspl0=spline(npt,fpos0)*fmult
         tspl1=spline(npt,fpos1)*fmult
         tspl2=spline(npt,fpos2)*fmult
         tspl3=spline(npt,fpos3)*fmult
         tspl4=spline(npt,fpos4)*fmult
         tspl5=spline(npt,fpos5)*fmult
! ****TEST
!cc         write(13,*) 'xnh fpos tspl '
!          write(13,700) xnh,fpos0,tspl0,xpas,fposs
!         write(13,700) xnh,fpos1,tspl1
!         write(13,700) xnh,fpos2,tspl2
!         write(13,700) xnh,fpos3,tspl3
!         write(13,700) xnh,fpos4,tspl4
!         write(13,700) xnh,fpos5,tspl5,xpas,fposs
!700      format(5(2x,e12.5))
! ***********************************
       else
! ++++ THIS OPTION IS NOT AVAILABLE IN THE CODE +++++++++++++
! the field (MV/cm) was given in the form of a Fourier series
         write(6,*)
         write(ierr,*) 'CAVNUM requires field data defined with FIELD'
         write(ierr,*) 'Replace HARM card with FIELD card'
         write(16,*) 'CAVNUM requires field data defined with FIELD'
         write(16,*) 'Replace HARM card with FIELD card'
         STOP
         tspl0=fone(fpos0)*fmult
         tspl1=fone(fpos1)*fmult
         tspl2=fone(fpos2)*fmult
         tspl3=fone(fpos3)*fmult
         tspl4=fone(fpos4)*fmult
         tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
       endif
       return
       end
!> *******************************************************************
!! SUBROUTINE fposbb(xlcum)
!! electric field at the 6 Bode's positions in the step  (see routine
!! dwref1)
!< *******************************************************************
       SUBROUTINE fposbb(xlcum)
       implicit real(8) (a-h,o-z)
       common/tapes/in,ifile,meta,ierr
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/cavnum6/fpos0,fpos1,fpos2,fpos3,fpos4,fpos5
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/rfield/ifield
       logical ifield
! *******************************************
       fpos0=xnh*xpas+xlcum
       fpos1=(xnh+0.20)*xpas+xlcum
       fpos2=(xnh+0.40)*xpas+xlcum
       fpos3=(xnh+0.60)*xpas+xlcum
       fpos4=(xnh+0.80)*xpas+xlcum
       fpos5=(xnh+1.0)*xpas+xlcum
       if(ifield) then
! --- the field was read from disk in MV/cm
         tspl0=spline(npt,fpos0)*fmult
         tspl1=spline(npt,fpos1)*fmult
         tspl2=spline(npt,fpos2)*fmult
         tspl3=spline(npt,fpos3)*fmult
         tspl4=spline(npt,fpos4)*fmult
         tspl5=spline(npt,fpos5)*fmult
! ****TEST
!cc         write(13,*) 'xnh fpos tspl '
!c         write(13,700) xnh,fpos0,tspl0,xpas
!         write(13,700) xnh,fpos1,tspl1
!         write(13,700) xnh,fpos2,tspl2
!         write(13,700) xnh,fpos3,tspl3
!         write(13,700) xnh,fpos4,tspl4
!         write(13,700) xnh,fpos5,tspl5,xpas
!700      format(4(2x,e12.5))
! ***********************************
       else
! the field (MV/cm) was given in the form of a Fourier series
         write(6,*)
         write(ierr,*) 'CAVNUM requires field data defined with FIELD'
         write(ierr,*) 'Replace HARM card with FIELD card'
         write(16,*) 'CAVNUM requires field data defined with FIELD'
         write(16,*) 'Replace HARM card with FIELD card'
         STOP
         tspl0=fone(fpos0)*fmult
         tspl1=fone(fpos1)*fmult
         tspl2=fone(fpos2)*fmult
         tspl3=fone(fpos3)*fmult
         tspl4=fone(fpos4)*fmult
         tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
       endif
       return
       end
!> *******************************************************************
!! SUBROUTINE fposb
!! electric field at the 6 Bode's positions in the step
!< *******************************************************************
       SUBROUTINE fposb
       implicit real(8) (a-h,o-z)
       common/tapes/in,ifile,meta,ierr
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/cavnum6/fpos0,fpos1,fpos2,fpos3,fpos4,fpos5
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/rfield/ifield
       logical ifield
       fpos0=xnh*xpas
       fpos1=(xnh+0.20)*xpas
       fpos2=(xnh+0.40)*xpas
       fpos3=(xnh+0.60)*xpas
       fpos4=(xnh+0.80)*xpas
       fpos5=(xnh+1.0)*xpas
       if(ifield) then
! --- the field was read from disk in MV/cm
         tspl0=spline(npt,fpos0)*fmult
         tspl1=spline(npt,fpos1)*fmult
         tspl2=spline(npt,fpos2)*fmult
         tspl3=spline(npt,fpos3)*fmult
         tspl4=spline(npt,fpos4)*fmult
         tspl5=spline(npt,fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(13,700) xnh,fpos0,tspl0
!c         write(13,700) xnh,fpos1,tspl1
!c         write(13,700) xnh,fpos2,tspl2
!c         write(13,700) xnh,fpos3,tspl3
!c         write(13,700) xnh,fpos4,tspl4
!c         write(13,700) xnh,fpos5,tspl5
!c700      format(3(2x,e12.5))
! ***********************************
       else
! the field (MV/cm) was given in the form of a Fourier series
         write(6,*)
         write(ierr,*) 'CAVNUM requires field data defined with FIELD'
         write(ierr,*) 'Replace HARM card with FIELD card'
         write(16,*) 'CAVNUM requires field data defined with FIELD'
         write(16,*) 'Replace HARM card with FIELD card'
         STOP
         tspl0=fone(fpos0)*fmult
         tspl1=fone(fpos1)*fmult
         tspl2=fone(fpos2)*fmult
         tspl3=fone(fpos3)*fmult
         tspl4=fone(fpos4)*fmult
         tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
       endif
       return
       end
!> *******************************************************************
!! SUBROUTINE sposb
!! derivative of electric field at the 6 Bode's positions in the step
!! not used in the code
!< *******************************************************************
       SUBROUTINE sposb
       implicit real(8) (a-h,o-z)
       common/tapes/in,ifile,meta,ierr
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/cavnum6/fpos0,fpos1,fpos2,fpos3,fpos4,fpos5
       common/cavnum7/sspl0,sspl1,sspl2,sspl3,sspl4,sspl5
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/rfield/ifield
       logical ifield
       fpos0=xnh*xpas
       fpos1=(xnh+0.20)*xpas
       fpos2=(xnh+0.40)*xpas
       fpos3=(xnh+0.60)*xpas
       fpos4=(xnh+0.80)*xpas
       fpos5=(xnh+1.0)*xpas
       if(ifield) then
! --- the field is read from disk in MV/cm
         sspl0=slope(npt,fpos0)*fmult
         sspl1=slope(npt,fpos1)*fmult
         sspl2=slope(npt,fpos2)*fmult
         sspl3=slope(npt,fpos3)*fmult
         sspl4=slope(npt,fpos4)*fmult
         sspl5=slope(npt,fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!cc         write(13,700) xnh,fpos0,sspl0
!cc         write(13,700) xnh,fpos1,sspl1
!cc         write(13,700) xnh,fpos2,sspl2
!cc         write(13,700) xnh,fpos3,sspl3
!cc         write(13,700) xnh,fpos4,sspl4
!cc         write(13,700) xnh,fpos5,sspl5
!cc700      format(3(2x,e12.5))
! ***********************************
       else
! the field (MV/cm) is given in the form of a Fourier series
         write(6,*)
         write(ierr,*) 'CAVNUM requires field data defined with FIELD'
         write(ierr,*) 'Replace HARM card with FIELD card'
         write(16,*) 'CAVNUM requires field data defined with FIELD'
         write(16,*) 'Replace HARM card with FIELD card'
         STOP
         tspl0=fone(fpos0)*fmult
         tspl1=fone(fpos1)*fmult
         tspl2=fone(fpos2)*fmult
         tspl3=fone(fpos3)*fmult
         tspl4=fone(fpos4)*fmult
         tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
       endif
       return
       end
!> *******************************************************************
!! FUNCTION xi1(phi0,t0,t5)
!! energy gain over the step
!< *******************************************************************
       FUNCTION xi1(phi0,t0,t5)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       xi1=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       xspl0=cos(fh*t0+phi0)*tspl0
       xspl1=cos(fh*t1+phi0)*tspl1
       xspl2=cos(fh*t2+phi0)*tspl2
       xspl3=cos(fh*t3+phi0)*tspl3
       xspl4=cos(fh*t4+phi0)*tspl4
       xspl5=cos(fh*t5+phi0)*tspl5
       tspl=19.*xspl0+75.*xspl1+50.*xspl2+50.*xspl3+75.*xspl4
     *     +19.*xspl5
       xi1=xpas/288. * tspl
       return
       end
!> *******************************************************************
!! FUNCTION xi2(phi0,t0)
!! coupling terms in R and R' (energy gain)
!< *******************************************************************
       FUNCTION xi2(phi0,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
!old       xspl0=cos(fh*t0+phi0)*tspl0
       xspl1=cos(fh*t1+phi0)*tspl1
       xspl2=cos(fh*t2+phi0)*tspl2
       xspl3=cos(fh*t3+phi0)*tspl3
       xspl4=cos(fh*t4+phi0)*tspl4
       xspl5=cos(fh*t5+phi0)*tspl5
       tspl=15.*xspl1+20.*xspl2+30.*xspl3+60*xspl4+19.*xspl5
       xi2=xpas*xpas/288. * tspl
       return
       end
!> *******************************************************************
!! FUNCTION xj1(phi0,t0)
!! transverse motion field dE/dt
!< *******************************************************************
       FUNCTION xj1(phi0,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
! --- the field is read from the disk
       xj1=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       xspl0=-fh*sin(fh*t0+phi0)*tspl0/bgt0
       xspl1=-fh*sin(fh*t1+phi0)*tspl1/bgt1
       xspl2=-fh*sin(fh*t2+phi0)*tspl2/bgt2
       xspl3=-fh*sin(fh*t3+phi0)*tspl3/bgt3
       xspl4=-fh*sin(fh*t4+phi0)*tspl4/bgt4
       xspl5=-fh*sin(fh*t5+phi0)*tspl5/bgt5
       tspl=19.*xspl0+75.*xspl1+50.*xspl2+50.*xspl3+75.*xspl4
     *     +19.*xspl5
       xj1=xpas/288. * tspl
       return
       end
!> *******************************************************************
!! FUNCTION xj2(phi0,t0)
!! transverse motion field dE/dt
!< *******************************************************************
       FUNCTION xj2(phi0,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       xj2=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       xspl1=-fh*sin(fh*t1+phi0)*tspl1/bgt1
       xspl2=-fh*sin(fh*t2+phi0)*tspl2/bgt2
       xspl3=-fh*sin(fh*t3+phi0)*tspl3/bgt3
       xspl4=-fh*sin(fh*t4+phi0)*tspl4/bgt4
       xspl5=-fh*sin(fh*t5+phi0)*tspl5/bgt5
       tspl=15.*xspl1+20.*xspl2+30.*xspl3
     *          +60.*xspl4+19.*xspl5
       xj2=xpas*xpas/288. * tspl
       return
       end
!> *******************************************************************
!! FUNCTION xe21(phi0,t0)
!! transverse motion field E*E
!< *******************************************************************
       FUNCTION xe21(phi0,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum4/bge0,bge1,bge2,bge3,bge4,bge5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       xe21=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       xspl0=cos(fh*t0+phi0)*tspl0
       xspl1=cos(fh*t1+phi0)*tspl1
       xspl2=cos(fh*t2+phi0)*tspl2
       xspl3=cos(fh*t3+phi0)*tspl3
       xspl4=cos(fh*t4+phi0)*tspl4
       xspl5=cos(fh*t5+phi0)*tspl5
       xspl0=xspl0*xspl0*bge0
       xspl1=xspl1*xspl1*bge1
       xspl2=xspl2*xspl2*bge2
       xspl3=xspl3*xspl3*bge3
       xspl4=xspl4*xspl4*bge4
       xspl5=xspl5*xspl5*bge5
       tspl=19.*xspl0+75.*xspl1+50.*xspl2+50.*xspl3+75.*xspl4
     *     +19.*xspl5
       xe21=xpas/288. * tspl
       return
       end
!> *******************************************************************
!! FUNCTION xe22(phi0,t0)
!! transverse motion for field E*E
!< *******************************************************************
       FUNCTION xe22(phi0,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum4/bge0,bge1,bge2,bge3,bge4,bge5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       COMMON/DYN/TREF,VREF
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/rfield/ifield
       logical ifield
       xe22=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       xspl1=cos(fh*t1+phi0)*tspl1
       xspl2=cos(fh*t2+phi0)*tspl2
       xspl3=cos(fh*t3+phi0)*tspl3
       xspl4=cos(fh*t4+phi0)*tspl4
       xspl5=cos(fh*t4+phi0)*tspl5
       xspl1=xspl1*xspl1*bge1
       xspl2=xspl2*xspl2*bge2
       xspl3=xspl3*xspl3*bge3
       xspl4=xspl4*xspl4*bge4
       xspl5=xspl5*xspl5*bge5
       tspl=15.*xspl1+20.*xspl2+30.*xspl3
     *          +60.*xspl4+19.*xspl5
       xe22=xpas*xpas/288. * tspl
       return
       end
!> *******************************************************************
!! SUBROUTINE bcnum(phref,ylg,ncell)
!! dynamics of the bunch
!< *******************************************************************
       SUBROUTINE bcnum(phref,ylg,ncell)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/DYN/TREF,VREF
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/dcspa/iesp
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/ vl,pi, xmat,rpel,qst
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum4/bge0,bge1,bge2,bge3,bge4,bge5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/rfield/ifield
       common/TESTREF/trefs,ddw
       common/elec/jelec
       common/step/istep
       common/aerp/vphase,vfield,ierpf
       dimension vecx(1)
       dimension gam(500),xe(500),xpe(500),ye(500),ype(500)
       dimension tcour(iptsz),phi(iptsz)
       logical ifield,flgsc,ichaes,iesp,jelec
       character*(8) PRTLAB
       dimension lossreason(iptsz)
!   ylg(cm) length of cavity, xpas(cm): step length
!   8 steps over a cell (a voir!! !)
       PRTLAB='CAVNUM'
       BEREF=VREF/VL                      !wdk relativistic beta of ref particle
       GAMREF=1./SQRT(1.-(BEREF*BEREF))   !wdk relativistic gamma of ref particle
       ENREF=XMAT*GAMREF                  !wdk total energy of ref particle E=m*c**2
       e0=xmat                            !wdk rest mass of particle
       npas=ncell*istep                   !wdk nbof steps per cell   [cm?]
       xpas=ylg/float(npas)               !wdk step length
       npas1=npas+1                       !wdk Zaunlatte
       xnh=0.
!   flgsc = true ---> s.c. computation
!   eglsc = 2*xpas : acting length of s.c. computation
       eglsc=2.*xpas
       flgsc=.false.
       aqst=abs(qst)  !wdk qst : charge (unit of charge) of the reference
       do i=2,npas1                       !wdk loop over steps
         i1=i-1
! --- seek the field E(z) values in the 6 positions in the step length xh
         call fposb   !wdk SUBR: electric field at the 6 Bode's positions in the step
         tmoy=0.
         do j=1,ngood
           tmoy=tmoy+f(6,j)
         enddo
         tmoy=tmoy/float(ngood)         
! --- systematic or random defaults on the phase amplitude (not for the reference)
         if(ierpf.ne.0) then             !wdk apply systematic or random errors
! --- systematic default on the amplitude
           if(ierpf.eq.1) then
             tspl0=tspl0*(1.+vfield)       !wdk tspl0 ... tspl5  Ez Amplitude
             tspl1=tspl1*(1.+vfield)
             tspl2=tspl2*(1.+vfield)
             tspl3=tspl3*(1.+vfield)
             tspl4=tspl4*(1.+vfield)
             tspl5=tspl5*(1.+vfield)
           endif  
! --- random error on the amplitude
           if(ierpf.gt.1) then
             len=1
             call rlux(vecx,len)
             r1=(2.*vecx(1)-1.)*vfield
             tspl0=tspl0*(1.+r1)
             tspl1=tspl1*(1.+r1)
             tspl2=tspl2*(1.+r1)
             tspl3=tspl3*(1.+r1)
             tspl4=tspl4*(1.+r1)
             tspl5=tspl5*(1.+r1)
           endif
         endif
         do j=1,ngood
!           qc=f(9,j)
           qc=abs(f(9,j))        !wdk charge state
           gam0=f(7,j)/e0        !wdk f(7) total energy , e0 rest mass
           gam(i1)=gam0
           if(i1.eq.1) then      !wdk particle j step 1
             tcour(j)=0.         !wdk current time part j
             tof=f(6,j)          !wdk t-offset part j
! --- rphas: phase delay between the actual particle  and the reference (entrance of the cavity)
             rphas=fh*(tof-tref) !wdk phase delay (fh = omega)
! --- systematic or random defaults on the phase RF (not for the reference)
             if(ierpf.ne.0) then
               vphasi=vphase*pi/180.
! --- systematic default on the phase offset
               if(ierpf.eq.1) rphas=rphas+vphasi
! --- random error on  phase offset
               if(ierpf.gt.1) then
                 len=1
                 call rlux(vecx,len)
                 r1=(2.*vecx(1)-1.)*vphasi
                 rphas=rphas+r1
               endif
             endif
             phi(j)=phref+rphas
           endif
           t0=tcour(j)
           ddt=t0
!  predictor (energy gain)            !wdk predictor delta-gamm gain
           if(gam0.le.1.) then
             f(8,j)=0.                !wdk skip particle with gamma < 1
             cycle
           endif
           b0=sqrt(gam0*gam0-1.)/gam0  !wdk beta**2 = (gamma**2-1)/gamma**2
           b1=b0
           b2=b0
           b3=b0
           b4=b0
           b5=b0
           dgam=xi1(phi(j),t0,t5)*qc/e0
           gam5=gam(i1)+dgam                        !wdk i1 ist step number!
!   corrector (energy gain)
!   tspl0 = dE/dz  (MV/(cm*cm)
           xpas2=xpas*xpas
           dgdz=qst/e0 * tspl0
           d2gdz2=dgam/xpas2-dgdz/xpas
           d2gdz2=2.*d2gdz2
           gam1=gam0+dgdz*xpas/5.+d2gdz2*xpas2/50.
           gam2=gam0+dgdz*xpas*2./5.+d2gdz2*xpas2*4./50.
           gam3=gam0+dgdz*xpas*3./5.+d2gdz2*xpas2*9./50.
           gam4=gam0+dgdz*xpas*4./5.+d2gdz2*xpas2*16./50.
           b1=sqrt(gam1*gam1-1.)/gam1
           b2=sqrt(gam2*gam2-1.)/gam2
           b3=sqrt(gam3*gam3-1.)/gam3
           b4=sqrt(gam4*gam4-1.)/gam4
           b5=sqrt(gam5*gam5-1.)/gam5
           dgam=xi1(phi(j),t0,t5)*qc/e0
           gam5=gam(i1)+dgam
           b5=sqrt(gam5*gam5-1.)/gam5
!      tranverse coordinates in (cm,rad)
           x0=f(2,j)
           y0=f(4,j)
           xt0=f(3,j)*1.e-03
           yp0=f(5,j)*1.e-03
!        Picht transformation: xe0 and ye0 (cm) xpe0 and ype0 (rad)
           gamm0=(gam0*gam0-1.)**0.25      !wdk Picht forward 
           xe0=x0*gamm0
           xpe0=xt0*gamm0
           ye0=y0*gamm0
           ype0=yp0*gamm0
           xpe0=xpe0+.5*xe0*gam0*dgdz/(gam0*gam0-1.)
           ype0=ype0+.5*ye0*gam0*dgdz/(gam0*gam0-1.)
           xe(i1)=xe0
           xpe(i1)=xpe0
           ye(i1)=ye0
           ype(i1)=ype0
!       transverse coupling terms
           gam00=gam0*gam0
           gam11=gam1*gam1
           gam22=gam2*gam2
           gam33=gam3*gam3
           gam44=gam4*gam4
           bgt0=(gam00-1.)**1.5
           xk1=fh*fh/(4.*vl*vl*bgt0)
           red=sqrt(xe(i1)*xe(i1)+ye(i1)*ye(i1))
           red2=red*red
           dred=0.
           if(red.gt.1.e-08) then
             dred=xe(i1)*xpe(i1)+ye(i1)*ype(i1)
             dred=dred/red
           endif
           rk1=xk1*red2*xi1(phi(j),t0,t5)*qc/e0
           rk2=red*dred*xk1*xi2(phi(j),t0)*qc/e0
           gam(i)=gam5+rk1+rk2
           if(gam(i).le.1.) then
             f(8,j)=0.
             ilost=ilost+1
! needs to be on energy
             lossreason(j)=-2
! Relative to cog
             f6i=f(6,j)-tmoy              
             write(49,3928) PRTLAB,NRRES,davtot/100.,i,int(f(1,j)),
     *       f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180./pi,f(7,j)-xmat,
     *       f(9,j),lossreason(j)     
3928         FORMAT(1x,A8,1x,I4,1x,E12.5,i5,1x,i5,1x,6(f12.3,1x),1x,
     *            f5.2,3x,i2)
             cycle
           endif
           gam55=gam(i)*gam(i)
           bgt1=(gam11-1.)**1.5
           bgt2=(gam22-1.)**1.5
           bgt3=(gam33-1.)**1.5
           bgt4=(gam44-1.)**1.5
           bgt5=(gam55-1.)**1.5
           bge0=(gam00+2.)/((gam00-1.)*(gam00-1.))
           bge1=(gam11+2.)/((gam11-1.)*(gam11-1.))
           bge2=(gam22+2.)/((gam22-1.)*(gam22-1.))
           bge3=(gam33+2.)/((gam33-1.)*(gam33-1.))
           bge4=(gam44+2.)/((gam44-1.)*(gam44-1.))
           bge5=(gam55+2.)/((gam55-1.)*(gam55-1.))
! ******************************************************
!   compute the jump of phase over the step
!old         dlt=(1.+red2*xk1)*xi3(phi(j),t0)
!old         dlt=dlt+red*dred*xk1*xi4(phi(j),t0)
!old         dlt=dlt*qc/(e0*vl)
!old         tof=tof+xpas/(vl*b0)+dlt
! *******************************************************
           f(7,j)=gam(i)*e0
           tcour(j)=t5
           ddt1=t5-ddt
           f(6,j)=ddt1+f(6,j)
! -- angular deviation
!    1) terms in dE/dt
           a1=qc/(2.*e0*vl)
           ttt1=xj1(phi(j),t0)
           ttt2=xj2(phi(j),t0)
!old         dxpe=xe(i1)*xj1(phi(j),t0)+xpe(i1)*xj2(phi(j),t0)
!old         dype=ye(i1)*xj1(phi(j),t0)+ype(i1)*xj2(phi(j),t0)
           dxpe1=xe(i1)*ttt1+xpe(i1)*ttt2
           dype1=ye(i1)*ttt1+ype(i1)*ttt2
           xpe(i)=xpe(i1)+a1*dxpe1
           ype(i)=ype(i1)+a1*dype1
! --- 2) terms in E*E (only for no-relativistic electrons)
           if(jelec) then
             ae2=qc/(2.*e0)
             ae2=ae2*ae2
             stt1=xe21(phi(j),t0)
             stt2=xe22(phi(j),t0)
             dxpe2=xe(i1)*stt1+xpe(i1)*stt2
             dype2=ye(i1)*stt1+ype(i1)*stt2
             xpe(i)=xpe(i1)+a1*dxpe1-ae2*dxpe2
             ype(i)=ype(i1)+a1*dype1-ae2*dype2
          endif
!  extension
!old         dxe=xe(i1)*xj2(phi,t0)+xpe(i1)*xj3(phi,t0)
!old         dye=ye(i1)*xj2(phi,t0)+ype(i1)*xj3(phi,t0)
!old         xe(i)=xe(i1)+a1*dxe+xpas*xpe(i1)
!old         ye(i)=ye(i1)+a1*dye+xpas*ype(i1)
           xe(i)=xe(i1)+xpas*(xpe(i1)+xpe(i))/2.
           ye(i)=ye(i1)+xpas*(ype(i1)+ype(i))/2.
!       back to the real variables and convert to (cm,mrad)
           dgdzr=qc/e0 * tspl5
           gamm1=(gam(i)*gam(i)-1.)**0.25
           gamm2=(gam(i)*gam(i)-1.)**1.25
           xi=xe(i)/gamm1
           xpi=xpe(i)/gamm1-xe(i)*gam(i)*dgdzr/(gamm2*2.)
           yi=ye(i)/gamm1
           ypi=ype(i)/gamm1-ye(i)*gam(i)*dgdzr/(gamm2*2.)
!      convert in cm and mrd
           f(2,j)=xi
           f(4,j)=yi
           f(3,j)=xpi*1.e03
           f(5,j)=ypi*1.e03
         enddo                   !wdk end loop over steps
!  space charge computation (only odd step numbers)
         if(.not.flgsc) then
           flgsc=.true.
           call disp
         else
           if(ichaes) then
!      Charge space (only SCHEFF is available)
              iesp=.true.
              call cesp(eglsc)
              iesp=.false.
              flgsc=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           endif
           call disp
         endif
         xnh=xnh+1.
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE reject(ilost,PRTLAB)
!! reject particles outside window set by REJECT card
!!      ifw = 0  ===> wdisp = dW/W relative to cog
!!      ifw = 1  ===> wdisp = dW (MeV) relative to cog
!!      ifw = 10 ===> wdisp = dW/W relative to REF
!!      ifw = 11 ===> wdisp = dW (MeV) relative to REF
!< *******************************************************************
       SUBROUTINE reject(ilost,PRTLAB)
       implicit real(8) (a-h,o-z)
       parameter(iptsz=1000002,maxcell1=4004)
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       common/mcs/imcs,ncstat,cstat(20)
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DYN/TREF,VREF
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       CHARACTER*(8) PRTLAB       
       dimension lossreason(iptsz)
! lossreason= -2 --> energy       
! lossreason= -1 --> phase       
! lossreason=  0 --> not lost       
! lossreason=  1 --> radius       
! lossreason=  2 --> x position       
! lossreason=  3 --> y position       
       ilost=0
       FH0=FH/VL
       fcpi=fh*180./pi
! Test window
       write(16,*)'Check if the ',ngood,' particles are within window'
       write(16,*) 'Number of charge states: ',ncstat
       if(ifw.le.1) then
! Relative to COG
         write(16,3900)
! ---- ifw = 0 ===> wdisp = dW/W
! ---- ifw = 1 ===> wdisp = dW (MeV)
         if (ncstat.gt.1) call cogetc
         bcour=0.
         cgtv=0.
         do i=1,ngood
           gpai=f(7,i)/xmat
           bcour=sqrt(1.-1./(gpai*gpai))+bcour
           cgtv=cgtv+f(6,i)
           lossreason(i)=0 
         enddo
         cgtv=cgtv/float(ngood)
         bcour=bcour/float(ngood)
         bcg=bcour
         gcour=1./sqrt(1.-bcour*bcour)
         gcg=gcour
         wcg=(gcour-1.)*xmat
         do i=1,ngood
           gpai=f(7,i)/xmat
           if(gpai.lt.1.) gpai=1.
           bcour=sqrt(1.-1./(gpai*gpai))
           fd(i)=bcour/bcg * gpai/gcg
         enddo
         if(ifw.eq.0) then
           dispr=gcour*gcour*wdisp/(gcour*(gcour+1.))
         else
           dispr=gcour*gcour*wdisp/(gcour*(gcour+1.)*wcg)
         endif
       else
! Relative to REF
         write(16,3901)
         bref=VREF/VL
         gref=1./sqrt(1.-bref*bref)
         wref=(gref-1.)*xmat
         do i=1,ngood
           gpai=f(7,i)/xmat
           bcour=sqrt(1.-1./(gpai*gpai))
           fd(i)=bcour/bref * gpai/gref
         enddo
         if(ifw.eq.10) then
           dispr=gref*gref*wdisp/(gref*(gref+1.))
         else
           dispr=gref*gref*wdisp/(gref*(gref+1.)*wref)
         endif
       endif
       write(16,3927)   rlim,wx,wy,wphas,wdisp
!     *         ,dispr,f6i*fh*180./pi,f(7,i)-xmat,int(f(9,i))
       f6i=0.
       do i=1,ngood
         ray=f(2,i)*f(2,i)+f(4,i)*f(4,i)
         ray=sqrt(ray)
         if(ray.gt.rlim) then
           f(8,i)=0.
           lossreason(i)=1                      
         endif  
         if(abs(f(2,i)).gt.wx) then
           f(8,i)=0.
           lossreason(i)=2                      
         endif  
         if(abs(f(4,i)).gt.wy) then
           f(8,i)=0.
           lossreason(i)=3                      
         endif  
         if(ifw.le.1) then
! Relative to cog
           if (ncstat.gt.1) then
!---- each charge state has its own COG in phase
             do istc=1,ncstat
               if(int(f(9,i)).eq.int(charm(istc)))then
                 f6i=f(6,i)-cgtdv(istc)
!             tmp=cgtdv(istc)
               endif
             enddo
           else
             f6i=f(6,i)-cgtv
           endif
         else
! Relative to REF
           f6i=f(6,i)-TREF
         endif
         if(fh*abs(f6i).ge.wphas) then
           f(8,i)=0.
           lossreason(i)=-1                      
         endif
         if(abs(fd(i)-1.).ge.dispr) then
           f(8,i)=0.
           lossreason(i)=-2                      
         endif
         if(int(f(8,i)).eq.0) then
           write(49,3928) prtlab,NRRES,davtot/100.,i,int(f(1,i)),
     *      f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180./pi,f(7,i)-xmat,
     *      f(9,i),lossreason(i)     
           ilost=ilost+1
         endif
       enddo
!  Reshuffles f(i,j) array after window
       call shuffle
!cccc       cstat=1
       ncstat=1
       cstat(1)=f(9,1)
       do j=2,ngood
         mcstat=0
         do k=1,ncstat
           if(int(f(9,j)).eq.int(cstat(k))) then
             mcstat=1
           endif
         enddo
         if(mcstat.eq.0) then
           ncstat=ncstat+1
           cstat(ncstat)=f(9,j)
         endif
       enddo
       netac=ncstat
       write(16,*) 'Number of good particles left: ',ngood
       write(16,*) 'Number of charge states left : ',ncstat
       write(16,4030) (cstat(j),j=1,ncstat)
       imcs=0
       if(ncstat.gt.1) imcs=1
3900   FORMAT(' Window w.r.t. COG')
3901   FORMAT(' Window w.r.t. reference particle')
3927   FORMAT(' LIM R,X,Y ',3(f10.2,9x),'P,W ',e12.5,9x,e12.5)
3928   FORMAT(1x,A8,1x,I4,1x,E12.5,1x,i5,1x,i5,1x,6(f12.3,1x),1x,
     *        f5.2,3x,i2)
4030   FORMAT(1x,'Charge state(s): ',20(f5.1,1x))
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE aimalv (ANGL,RMO,BAIM,XN,XB,EK1,EK2,PENT1,RAB1,
!!                    SK1,SK2,PENT2,RAB2)
!! FIRST AND SECOND order Bending Magnet
!! WEDGE BENDING MAGNET
!!   ANGL : DEG  bend angle of the central trajectory
!!   RMO  : CM   radius of curvature of the central trajectory
!!   BAIM : KG   field of the bending magnet
!!     BAIM = 0  the field is computed from the momentum of the
!!               reference; otherwise the momentum is computed from
!!               the field
!!   XN   :      FIELD GRADIENT (dimensionless,TRANSPORT: n)
!!   XB   :      NORMALIZED SECOND DERIVATIVE OF B (TRANSPORT : beta)
!!   AP(1) = AP(2) CM vertical half aperture (only if IPOLE = 0)
!! ENTRANCE FACE
!!  PENT1 EK1 EK2 RAB1
!!   PENT1: DEG   angle of pole face rotation  (deg)
!!   RAB1 : CM    radius of curvature
!!   EK1  :       integral related to the extent of the fringing field
!!                (TRANSPORT K1)
!!   EK2  :       integral related to the extent of the fringing field
!!                (TRANSPORT K2)
!!   AP(1) : CM   vertical half aperture
!! EXIT FACE
!!  PENT2 SK1 SK2  RAB2
!!   PENT2: DEG   angle of pole face rotation
!!   RAB2 : CM  radius of curvature
!!   SK1  :     integral related to the extent of the fringing field
!!   SK2  :     integral related to the extent of the fringing field
!!   AP(2) : CM   vertical half aperture
!< *******************************************************************
       SUBROUTINE aimalv (ANGL,RMO,BAIM,XN,XB,EK1,EK2,PENT1,RAB1,
     *                   SK1,SK2,PENT2,RAB2)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/tapes/in,ifile,meta,ierr
       COMMON/DYN/TREF,VREF
       COMMON/RIGID/BORO
       common/faisc/f(10,iptsz),imax,ngood
       common/femt/iemgrw,iemqesg
       LOGICAL IEMGRW
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON /BLOC23/ H, DEVI, NB, BDB,L
       real(8) L,NB
       COMMON/PORO/IROT1,IROT2
       LOGICAL IROT1,IROT2
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       COMMON /BLOC21/ BE, APB(2), LAYL, LAYX, RABT
       real(8) LAYL, LAYX
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       common/rander/ialin
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/RADIA/TRT,RSYNC,XINTF,CRAE
       COMMON/RAYSHY/IRAYSH
       LOGICAL IRAYSH
       common/itvole/itvol,imamin
       common/tofev/ttvols
       common/mcs/imcs,ncstat,cstat(20)
! nsprint: control
       common/isector/nsector,nsprint
! --------------------------------------
       logical itvol,imamin,ichaes
       logical ialin
       dimension xmoy(20),ymoy(20),rmoy(20),rig(20),ncs(20)
       dimension xpmoy(20),ypmoy(20)
       dimension xcl1(20),xcl2(20),alp(20),sxeb1(20),charge(20)
       dimension xsa1b1(20),baims(20)
       dimension sbeta(20)
       fprec=epsilon(baim)
       WRITE(16,100)
100    FORMAT(' ****** BENDING MAGNET: input list ****** ')
!       if(baim.eq.0.0) then
       if(abs(baim).le.fprec) then
!     BORO: momentum of reference (kG.cm)
         ri=boro
! --- BAIM: bend field (KG)
         baim=abs(ri/rmo)
         write(16,'(A,F4.1,A,F12.5,A)')' Based on reference charge ',
     *         qst,' momentum ',boro,' (kG.cm)'
       else
! --- RI momentum kG.cm
         ri=baim*rmo
       endif
       DEVI=ANGL
       NB=XN
       BDB=XB
       RSYNC=rmo
       gap=wy
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
!old       IF(IROT1) WRITE(16,1010) PENT1,RAB1,EK1,EK2,APB(1)
       if(ichaes) then
        write(16,*)'***** beam current: ',beamc,' mA'
       endif
       WRITE(16,1010) PENT1,RAB1,EK1,EK2,APB(1)
1010    FORMAT('    ENTRANCE FACE ******',/,
     1 '  ANGLE OF POLE FACE ROTATION  ',E12.5,' DEG',/,
     1 '  RADIUS OF CURVATURE          ',E12.5,' CM',/,
     1 '  FRINGE FIELD CORECTIONS K1  K2',2(2X,E12.5),/,
     1 '  VERTICAL HALF-APERTURE       ',E12.5,' CM')
       WRITE(16,1020)RMO,DEVI,BAIM,NB,BDB
1020    FORMAT('    WEDGE MAGNET************',/,
     2 '  BENDING RADIUS:  ',E12.5,' CM ',/,
     2 '  BEND ANGLE:      ',E12.5,' DEG',/,
     2 '  FIELD:           ',E12.5,' KG',/,
     2 '  FIELD GRADIENTS: N ',E12.5,' BETA:',E12.5)
!old       IF(IROT2) WRITE(16,1030) PENT2,RAB2,SK1,SK2,APB(2)
        WRITE(16,1030) PENT2,RAB2,SK1,SK2,APB(2)
1030    FORMAT('    EXIT FACE******',/,
     3 '  ANGLE OF POLE FACE ROTATION  ',E12.5,' DEG',/,
     3 '  RADIUS OF CURVATURE          ',E12.5,'CM',/,
     3 '  FRINGE FIELD CORRECTIONS K1  K2',2(2X,E12.5),/,
     3 '  VERTICAL HALF-APERTURE       ',E12.5,' CM')
!  start prints in file 'short.data'
       idav=idav+1
       iitem(idav)=4
       dav1(idav,2)=devi
       dav1(idav,3)=rmo*10.
       dav1(idav,5)=APB(1)*10.
       dav1(idav,6)=PENT1
       dav1(idav,7)=EK1
       dav1(idav,8)=EK2
       dav1(idav,9)=RAB1*10.
       dav1(idav,10)=PENT2
       dav1(idav,11)=SK1
       dav1(idav,12)=SK2
       dav1(idav,13)=RAB2*10.
       dav1(idav,14)=nb
       dav1(idav,15)=bdb
       dav1(idav,16)=baim*.1
       dav1(idav,17)=APB(2)*10.
       FH0=FH/VL
!  Conversion deg--->rad
       radia=pi/180.
       pent1=pent1*radia
       devi=devi*radia
       devr=devi
       l=devr*rmo
       dav1(idav,1)=l*10.
       sdavtot=davtot
       davtot=davtot+l
       dav1(idav,4)=davtot*10.
       pent2=pent2*radia
       devtot=devi
! ----------------------------
!  define the bending angle of the synchronous particle over each sector
       devit=devi/float(nsector)
! --- devit must be different from pent2
!       if(devit.eq.pent2) nsector=nsector+1
       if(abs(devit-pent2).le.fprec) nsector=nsector+1
! --- space charge computation: nsector must be g.t. 1
       if(ichaes.and.(nsector.eq.1) ) nsector = 2
       devi=devi/float(nsector)
       devr=devr/float(nsector)
! ----------------------------------------------------------
! -- scl effective length for space charge computation
!     scl is the path length of the C.T. over two following sectors
       scl=2.*devi*rmo
!   save pent1 , pent2 , devi, ek1, ek2 ,sk1 , sk2 ,
       pent1s=pent1
       pent2s=pent2
       devis=devi
       devrs=devr
       ek1s=ek1
       ek2s=ek2
       sk1s=sk1
       sk2s=sk2
! --------------------
       do ist=1,ncstat
        xcl2(ist)=0.
        rmoy(ist)=0.
        rig(ist)=0.
        baims(ist)=baim
       enddo
! -------------------
! ---- nsector: number of sectors in the bending magnet
      do nsec=1,nsector
!       write(6,*) '********'
!       write(6,*) ' BENDING MAGNET sector ',nsec
       devi=devis
       devr=devrs
       xlsy=devi*rmo
       sdavtot=sdavtot+xlsy
       if(nsector.gt.1) then
         if(nsec.eq.1) then
          pent1=pent1s
          pent2=0.
          ek1=ek1s
          ek2=ek2s
          sk1=0.
          sk2=0.
         endif
         if(nsec.eq.nsector) then
          pent1=0.
          pent2=pent2s
          ek1=0.
          ek2=0.
          sk1=sk1s
          sk2=sk2s
         endif
         if((nsec.gt.1).and.(nsec.lt.nsector)) then
          pent1=0.
          pent2=0.
          ek1=0.0001
          ek2=0.
          sk1=0.0001
          sk2=0.
         endif
        endif
! ------------------------------------------------------------
! --- nsctat: number of charges in the beam
        do ist=1,ncstat
          charge(ist)=cstat(ist)
          devi=devis
          devr=devrs
          xcl1(ist)=pent1-xcl2(ist)
          xmoy(ist)=0.
          xpmoy(ist)=0.
          ymoy(ist)=0.
          ypmoy(ist)=0.
          ncs(ist)=0
          rig(ist)=0.
          sbeta(ist)=0.
          do i=1,ngood
            if(int(f(9,i)).eq.int(charge(ist))) then
              xmoy(ist)=xmoy(ist)+f(2,i)
              ymoy(ist)=ymoy(ist)+f(4,i)
              xpmoy(ist)=xpmoy(ist)+f(3,i)
              ypmoy(ist)=ypmoy(ist)+f(5,i)
              gpai=f(7,i)/xmat
              bpai=sqrt(1.-1./(gpai*gpai))
              sbeta(ist)=sbeta(ist)+bpai
              xmco=xmat*bpai*gpai
              rip=33.356*xmco*1.e-01/f(9,i)
              rig(ist)=rip+rig(ist)
!old            rmoy(ist)=rmoy(ist)+rip
              ncs(ist)=ncs(ist)+1
            endif
          enddo
          sbeta(ist)=sbeta(ist)/float(ncs(ist))
          xmoy(ist)=xmoy(ist)/float(ncs(ist))
          ymoy(ist)=ymoy(ist)/float(ncs(ist))
          xpmoy(ist)=xpmoy(ist)/float(ncs(ist))
          ypmoy(ist)=ypmoy(ist)/float(ncs(ist))
          rig(ist)=rig(ist)/float(ncs(ist))
!old         rmoy(ist)=rig(ist)/baim
          rmoy(ist)=rig(ist)/baims(ist)
! eq.14
          ctan=cos(devi-pent2)/sin(devi-pent2)
          xep=rmo*(sin(devi)*ctan-cos(devi))
          xepc=xep+rmo-rmoy(ist)+xmoy(ist)
! eq.15 and eq.16
          argu=-xmoy(ist)*tan(pent1)/xepc
! eq.16
          omga=atan(argu)
! eq.15
          thet=omga+devi-pent2
! eq.18
          eo1=xepc/cos(omga)
! eq.17
          arg1=eo1*sin(thet)/rmoy(ist)
          eta=asin(arg1)
! eq.13
          xeb1=xepc*cos(thet)/cos(omga)+rmoy(ist)*cos(eta)
          sxeb1(ist)=xeb1
! eq.12
          xk2b1=-xmoy(ist)*tan(xcl1(ist))+xeb1*sin(devi-pent2)
! eq.11  (bend angle)
          alp(ist)=asin(xk2b1/rmoy(ist))
! eq.18
          xeo1=xepc/cos(omga)
! eq.19 (angle of inclination exit)
          argu=eo1/rmoy(ist) * sin(thet)
          xcl2(ist)=asin(argu)
          sa1b1=-rmo*sin(devr)
          sa1b1=sa1b1/sin(devr-pent2)
          xsa1b1(ist)=sa1b1+sxeb1(ist)
! --- field
!      first order
          baims(ist)=baim*(1.-nb*xsa1b1(ist)/rmo)
!       second order
          rih=1./(rmo*rmo)
          baims(ist)=baims(ist)+xb*rih*xsa1b1(ist)*xsa1b1(ist)
! -----------------------------------------------------
! ----  Transport matrix
          sbet=sbeta(ist)
          devi=alp(ist)
          AILONG=devi*rmoy(ist)
          WRITE(16,101) charge(ist),nsec,nsector,baims(ist),
     *         xsa1b1(ist),rmoy(ist),devi*180./pi,AILONG,rig(ist)
101       FORMAT(/,'  **************************************',/,
     *     '  *CENTRAL TRAJECTORY for charge: ',f4.1,' *',/,
     *     '  **************************************',/,
     *     '  SECTOR: ',i4,' SECTORS NUMBER: ',i5, /,
     *     '  BENDING FIELD:   ',e12.5,' kG  at: ',E12.5,' cm',/,
     *     '  BENDING RADIUS:  ',E12.5,' CM ',/,
     *     '  BENDING ANGLE:   ',E12.5,' DEG',/,
     *     '  length: ',e12.5,' cm  rigidity: ',E12.5,' kG.cm')
          L=AILONG
          H=1./rmoy(ist)
!   ENTRANCE FACE OF THE BENDING MAGNET
!   CLEAR R AND T
          CALL CLEAR
          GAP=APB(1)
          BE= xcl1(ist)
          LAYL =EK1
          LAYX =EK2
          RABT=0.
          IF(ABS(RAB1).GT.6.*0)RABT=1./RAB1
! -----------------------------------------
          gcog=0.
          nii=0
          do ii=1,ngood
!            if(f(9,ii).eq.charge(ist)) then
            if(int(f(9,ii)).eq.int(charge(ist))) then
              gcog=gcog+f(7,ii)/xmat
              nii=nii+1
            endif
          enddo
          gcog=gcog/float(nii)
          bcog=sqrt(1.-1./(gcog*gcog))
          fdtot=0.
          DO II=1,NGOOD
!            if(f(9,ii).eq.charge(ist)) then
            if(int(f(9,ii)).eq.int(charge(ist))) then
              tbe=tan(be)
              f(2,ii)=f(2,ii)-xmoy(ist)
              gpai=f(7,ii)/xmat
              bpai=sqrt(1.-1./(gpai*gpai))
              f(6,ii)=f(6,ii)+xmoy(ist)*tbe/(bpai*vl)
              fd(ii)=(gpai*bpai)/(gcog*bcog)
              fdtot=fdtot+fd(ii)
            endif
          enddo
          fdtot=fdtot/float(nii)-1.
! --------------------------------------------------
          CALL POFAR1(GAP)
          write(16,4502) be*180./pi,charge(ist)
4502      format('  ****INPUT FACE*** SLOPE: ',e12.5,' deg ',
     *           'CHARGE: ',f4.1)
          call matrix
          XLL=0.
          DO II=1,NGOOD
!            if(f(9,ii).eq.charge(ist)) then
            if(int(f(9,ii)).eq.int(charge(ist))) then
              CALL COBEAM(II,XLL)
            endif
          enddo
! *******************************************************
!  WEDGE BENDING MAGNET
!   CLEAR R AND T
          CALL CLEAR
          CALL BENMAG(sbet,fdtot)
! ---  :print the transport matrix
          write(16,4101) charge(ist)
4101      format('  ****BENDING MAGNET for charge ',f4.1)
          call matrix
          r51=r(5,1)
!  ----  transport of particles
          DO II=1,NGOOD
!            if(f(9,ii).eq.charge(ist)) then
            if(int(f(9,ii)).eq.int(charge(ist))) then
              CALL COBEAM(II,L)
            endif
!      synchrotron radiation (only for electrons, i.e. erest = 0.511 Mev)
            IF(IRAYSH .and. abs(xmat-0.511).le.0.001) CALL SYROUT(II)
          ENDDO
! *******************************************************
! --- EXIT FACE OF THE BENDING MAGNET
!   CLEAR R AND T
          CALL CLEAR
          xll=0.
          GAP=APB(2)
          BE= xcl2(ist)
          LAYL =SK1
          LAYX =SK2
          RABT=0.
          IF(ABS(RAB2).GT.1.E-10)RABT=1./RAB2
          CALL POFAR2(GAP)
! ---- :print the transport matrix
          write(16,4501) be*180./pi,charge(ist)
4501      format('  ****EXIT FACE*** SLOPE: ',e12.5,' deg CHARGE: ',
     *          f4.1)
          call matrix
!     transport of particles
          XLL=0.
          DO II=1,NGOOD
!            if(f(9,ii).eq.charge(ist)) then
            if(int(f(9,ii)).eq.int(charge(ist))) then
              CALL COBEAM(II,XLL)
            endif
          ENDDO
! -------------------------------------------------------------------------
! --- get back the particles coordinates in the coordinates system of the synchronous particle
          sa1b1=-rmo*sin(devr)
          sa1b1=sa1b1/sin(devr-pent2)
          ttt=xcl2(ist)-pent2
          ttt=ttt*1.e03
          do ii=1,ngood
!            if(f(9,ii).eq.charge(ist)) then
            if(int(f(9,ii)).eq.int(charge(ist))) then
! EQ.29
              a1b1=sa1b1+sxeb1(ist)
! EQ.28
              f(2,ii)=(a1b1+f(2,ii)/cos(xcl2(ist))) * cos(pent2)
! EQ.30
              f(3,ii)=f(3,ii)-ttt
! EQ.31
              gpai=f(7,ii)/xmat
              bpai=sqrt(1.-1./(gpai*gpai))
              f(6,ii)=f(6,ii)+r51*xmoy(ist)/(bpai*vl)
!cc              f(6,ii)=f(6,ii)-r51*xmoy(ist)/(bpai*vl)
! **** allow plotting the beam after the sector number nsprint in file 13 (see the MAIN)
!cc            if(nsec.eq.nsprint) then
!cc       write(13,2587) nsec,ist,charge(ist),f(2,ii),f(3,ii),f(4,ii),
!cc     *                   f(5,ii),xmoy(ist),ymoy(ist),rmoy(ist)
!cc2587   format(2x,i3,2x,i3,8(2x,e12.5))
!cc            endif
! ***************************************************************************
            endif
          enddo
!   enddo for ist (number of charges in the beam)
        enddo
! --------------------------------------------------------------
!  Space charge computation
        if(ichaes) then
! --- check the parity of nsec
          pnsec=float(nsec)/2.-nsec/2
!    nsec is odd:---> space charge computation
!          if((pnsec.ne.0.).and.(nsec.lt.nsector)) then
          if(abs(pnsec).gt.fprec .and. nsec.lt.nsector) then
            call cesp(scl)
            write(16,*) ' space charge after sector: ',nsec
          endif
        endif
! ------------------------------------------------------------
!    synchronous radiation (only for electrons i.e. erest = 0.511 Mev)
        IF(IRAYSH .and. abs(xmat-0.511).le.0.001) CALL SYREF
!     The routine SYREF changes vref and tref (reference)
!  envelope
        PRLAB(IPRF)='BMAGNET '
        CALL STAPL(sdavtot*10.)
!  enddo for nsec (sectors numbers)
       enddo
! ------------------------------------------------------
!  random error in alignment
       if(ialin) call randali
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
       call cogetc
! --- Test window after the bending magnet
       tcog=0.
       gcog=0.
       do i=1,ngood
         gcog=gcog+f(7,i)/xmat
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       gcog=gcog/float(ngood)
       bcog=sqrt(1.-1./(gcog*gcog))
       wcg=(gcog-1.)*xmat
! devtot: total angle of the bending magnet(computation of tref)
       devi=devtot
       ailong=devi*rmo
       IF(IRAYSH .and. abs(xmat-0.511).le.0.001) then
! electrons with synchrotron radiation
       ELSE
! ions
         TREF=TREF+AILONG/VREF
!    ----- window control
         PRTLAB=PRLAB(IPRF)
         call reject(ilost,PRTLAB)
! ---------------------------------------------------
         dav1(idav,37)=ngood
         if(itvol) ttvols=tref
       ENDIF
       BEREF=VREF/VL
       GAMREF=1./SQRT(1.-BEREF*BEREF)
       XMCO=XMAT*BEREF*GAMREF
       BORO=33.356*XMCO*1.E-01/QST
       TLONG = TREF*VREF
       WRITE(16,256) BEREF,GAMREF,TREF,TLONG,BORO,NGOOD
256    FORMAT(//,3X,' *** REFERENCE AT THE EXIT :',/,
     X '   BETA :',E12.5,' GAMMA :',E12.5,/,'   T.O.F (SEC): ',E12.5,
     X '   T.O.F (CM): ',E12.5,/,
     X '   RIGIDITY(KGAUSS.CM) :',E12.5,/,
     X '   NUMBER OF PARTICLES :',I7,/)
       if(itvol) write(16,*) ' tof for adjustments: ',ttvols,' sec'
       if(iemgrw) call emiprt(0)
!old       CALL STAPL(davtot*10.)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE deflect(fdtot)
!! Electrostatic deflector: Transport matrix
!! first order transport matrix (M,RD)
!!     drad: horizontal deflector radius (cm)
!!     l: length of the central trajectory (cm)
!!     kx2, ky2: matrix terms arguments (cm-2)
!!     avb: average relativistic beta
!!        in this routine drad, l kx2, ky2 are converted to m
!! With matrix elements from F.Hinterberger to Triumf note TRI-DN-05-7
!< *******************************************************************
      SUBROUTINE deflect(fdtot)
      implicit real(8)(A-Z)
      COMMON /BLOC11/ R(6,6), T(6,6,6)
      common /edef/avb,drad,kx2,ky2,l
! --- convert drad, kx2 , ky2 in m
      h=100./drad
      h2=h*h
      AL=L*1.E-02
      KX2=KX2*1.e04
      KY2=KY2*1.e04
      fprec=epsilon(kx2)
      KX=SQRT(ABS(KX2))
      KY=SQRT(ABS(KY2))
      ARGX=KX*AL
      ARGY=KY*AL
      avb2=avb*avb
      avg=sqrt(1.-avb2)
      avg=1./avg
      avg2=avg*avg
      dx=(2.-avb2)*h/kx
      dxp=(2.-avb2)*h/kx2
! ***** variante:(???)
!      dx=h/kx
!      dxp=h/kx2
! ************************
!  kx2 < 0
      IF (kx2.lt.6.*0) then
       CX=COSH(ARGX)
       SX=SINH(ARGX)/KX
       SXP=sinh(argx)*kx
! ---------------------------------
!    First order Matrix R (plane (X,XP)
        R(1,1)=CX
        R(1,2)=SX
        R(1,6)=DXP*(1.-cx)
        R(2,1)=SXP
        R(2,2)=CX
        R(2,6)=DX*SX*KX
        R(5,1)=-DX*SX*KX
        R(5,2)=-DXP*(1.-CX)
        R(5,5)=1.
        R(5,6)=fdtot*AL/avg2-(2.-avb2)*DXP*H*(AL-SX)
        R(6,6)=1.
      ENDIF
!  kx2 > 0
      IF (kx2.gt.6.*0) then
       CX=COS(ARGX)
       SX=SIN(ARGX)/KX
       SXP=sin(argx)*kx
!    First order Matrix R (plane (X,XP)
        R(1,1)=CX
        R(1,2)=SX
        R(1,6)=DXP*(1.-cx)
        R(2,1)=-SXP
        R(2,2)=CX
        R(2,6)=DX*SX*KX
        R(5,1)=DX*SX*KX
        R(5,2)=DXP*(1.-CX)
        R(5,5)=1.
        R(5,6)=fdtot*AL/avg2-(2.-avb2)*DXP*H*(AL-SX)
        R(6,6)=1.
      ENDIF
!  kx2 = 0
!      IF (kx2.eq.6.*0) then
      IF (abs(kx2).le.fprec) then
        R(1,1)=1.
        R(1,2)=AL
        R(1,6)=0.
        R(2,1)=0.
        R(2,2)=1.
        R(2,6)=L*H*(2.-avb2)
        R(5,1)=-L*H*(2.-avb2)
        R(5,2)=0.
        R(5,5)=1.
        R(5,6)=AL/avg2
      ENDIF
! ky2 < 0
      IF (ky2.lt.6.*0) then
       CY=COSH(ARGY)
       SY=SINH(ARGY)/KY
       SYP=sinh(argy)*ky
       R(3,3)=CY
       R(3,4)=SY
       R(4,3)=SYP
       R(4,4)=CY
      ENDIF
! ky2 > 0
      IF (ky2.gt.6.*0) then
       CY=COS(ARGY)
       SY=SIN(ARGY)/KY
       SYP=sin(argy)*ky
       R(3,3)=CY
       R(3,4)=SY
       R(4,3)=-SYP
       R(4,4)=CY
      ENDIF
!  ky2 = 0
!      IF (ky2.eq.6.*0) then
      IF (abs(ky2).le.fprec) then
       CY=1.
       SY=AL
       SYP=0.
       R(3,3)=CY
       R(3,4)=SY
       R(4,3)=SYP
       R(4,4)=CY
      ENDIF
      return
      end
!> *******************************************************************
!! SUBROUTINE e_deflec
!! characteristics of the deflector (central trajectory)
!! input parameters
!!   nsector: nombre of sectors in the deflector
!!   rm0: radial radius (cm)
!!   devtot: bend angle (deg)
!!   radii: vertical (radial) radii of curvature (cm)
!!   elecf: nominal electric field
!!   characteristics of the synchronous particle
!!   wt0 :total energy (MeV)
!!   qst: electric charge
!< *******************************************************************
       SUBROUTINE e_deflec
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       common/tapes/in,ifile,meta,ierr
       COMMON/DYN/TREF,VREF
       COMMON/ERIGID/edr0
       common/faisc/f(10,iptsz),imax,ngood
       common/femt/iemgrw,iemqesg
       LOGICAL IEMGRW
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/QMOYEN/QMOY
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       common /edef/avb,drad,kx2,ky2,L
       real(8) L,kx2,ky2
       COMMON /BLOC11/ R(6,6), T(6,6,6)
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       CHARACTER*(8) PRLAB,PRTLAB
       common/rander/ialin
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/itvole/itvol,imamin
       common/tofev/ttvols
       COMMON/SECDR/ISEOR
       LOGICAL ISEOR,sseor
       common/mcs/imcs,ncstat,cstat(20)
       logical itvol,imamin,ichaes
       logical ialin
       dimension xmoy(20),ymoy(20),rmoy(20),rig(20),ncs(20)
       dimension xpmoy(20),ypmoy(20),avbt(20),charge(20),alp(20)
! -----------------------------------------------------------------
! print out on terminal of transport element # on one and the same line
       NRTRE=NRTRE+1
       call PROGRESS(NRTRE,NRRES)
!  ---- save iseor in sseor
        sseor=iseor
!   iseor = false ---> second ordre transport matrix not available for the deflector
       iseor=.false.
!
       read(in,*) nsector
       read(in,*) rm0,devtot,radii,elecf
       bd0=vref/vl
       gd0=sqrt(1.-bd0*bd0)
       gd0=1./gd0
       wt0=gd0*xmat
       wt0c=(wt0-xmat)
!   edr0: electric rigidity (kV)
       edr0=wt0*bd0*bd0*1.e03/qst
!     efd0: radial electric field (in kV/cm)
       efd0=edr0/rm0
       edfnom=efd0
       if(elecf.ge.0.) efd0=elecf
       WRITE(16,1020)RM0,DEVTOT,RADII,EDR0,EDFNOM,EFD0,WT0C
1020    FORMAT('    ELECTROSTATIC DEFLECTOR************',/,
     2 '  BENDING RADIUS:  ',E12.5,' cm ',/,
     2 '  BEND ANGLE:      ',E12.5,' deg',/,
     2 '  VERTICAL RADII OF CURVATURE: ',E12.5,' cm',/,
     2 '  RIGIDITY: ',e12.5,' kV ',/,
     2 '  RADIAL ELECTRIC FIELD (nominal): ',e12.5,' kV/cm',/,
     2 '  RADIAL ELECTRIC FIELD (applied): ',e12.5,' kV/cm',/,
     2 '  INPUT ENERGY: ',e12.5,' MeV',/)
       if(ichaes) then
        write(16,*)'***** beam current: ',beamc,' mA'
        if((iscsp.lt.3).and.(ncstat.gt.1)) then
         write(6,*) '****************************'
         write(6,2748)
2748     format(' CAUTION: In the case of multiple charge states',/,
     *  ' HERSC and SCHERM can not be used for electrostatic bends')
        endif
       endif
!  start prints in file 'short.data'
       findex=1.+rm0/radii
       idav=idav+1
       iitem(idav)=21
       dav1(idav,2)=devtot
       dav1(idav,3)=rm0*10.
       dav1(idav,5)=radii*10.
       dav1(idav,6)=findex
       dav1(idav,7)=edr0
       dav1(idav,8)=efd0*0.1
!   convert bend angle in rad
       devtot=devtot*pi/180.
       l=devtot*rm0
       dav1(idav,1)=l*10.
       sdavtot=davtot
       davtot=davtot+l
       dav1(idav,4)=davtot*10.
! --- space charge computation: nsector must be g.t. 1
       if(ichaes.and.(nsector.eq.1) ) nsector = 2
       devi=devtot/float(nsector)
       devr=devtot/float(nsector)
! ----------------------------------------------------------
! -- scl effective length for space charge computation
!     scl is the path length of the C.T. over two following sectors
       scl=2.*devi*rm0
       do ist=1,ncstat
        rmoy(ist)=0.
        rig(ist)=0.
        alp(ist)=devi
       enddo
! -------------------
! ---- nsector: number of sectors in the deflector
      do nsec=1,nsector
        write(6,*) '********'
        write(6,*) ' deflector sector ',nsec
        xlsy=devi*rm0
        sdavtot=sdavtot+xlsy
! ------------------------------------------------------------
! --- nsctat: number of charge states in the beam
        do ist=1,ncstat
          charge(ist)=cstat(ist)
          xmoy(ist)=0.
          xpmoy(ist)=0.
          ymoy(ist)=0.
          ypmoy(ist)=0.
          ncs(ist)=0
          rig(ist)=0.
          avbt(ist)=0.
          do i=1,ngood
            if(int(f(9,i)).eq.int(charge(ist))) then
              xmoy(ist)=xmoy(ist)+f(2,i)
              ymoy(ist)=ymoy(ist)+f(4,i)
              xpmoy(ist)=xpmoy(ist)+f(3,i)
              ypmoy(ist)=ypmoy(ist)+f(5,i)
              gpai=f(7,i)/xmat
              bpai=sqrt(1.-1./(gpai*gpai))
              avbt(ist)=avbt(ist)+bpai
!      electric rigidity (kV)
              rip=f(7,i)*bpai*bpai/f(9,i) *1.e03
              rig(ist)=rip+rig(ist)
              ncs(ist)=ncs(ist)+1
            endif
          enddo
          xmoy(ist)=xmoy(ist)/float(ncs(ist))
          ymoy(ist)=ymoy(ist)/float(ncs(ist))
          xpmoy(ist)=xpmoy(ist)/float(ncs(ist))
          ypmoy(ist)=ypmoy(ist)/float(ncs(ist))
          rig(ist)=rig(ist)/float(ncs(ist))
          rmoy(ist)=rig(ist)/efd0
          avbt(ist)=avbt(ist)/float(ncs(ist))
!   dispersion in dp/p relative to the cog of the bunch
          gcog=sqrt(1.-avbt(ist)*avbt(ist))
          fdtot=0.
          nii=0
          do i=1,ngood
            if(int(f(9,i)).eq.int(charge(ist))) then
              gpai=f(7,i)/xmat
              bpai=sqrt(1.-1./(gpai*gpai))
              fd(i)=(gpai*bpai)/(gcog*avbt(ist))
              fdtot=fdtot+fd(i)
              nii=nii+1
            endif
          enddo
          fdtot=fdtot/float(nii)
! --- local deflector
!       alp(ist): angle of the local deflector
!        parametres kx2 and ky2
!  eq.11
         oo1=rm0-rmoy(ist)+xmoy(ist)
!  eq.10
         abet=oo1*sin(alp(ist))/rmoy(ist)
         abet=asin(abet)
!  eq.12 (angle of the local central trajectory)
         alp(ist)=alp(ist)+abet
!  eq.14 (field index)
         findex=1.+rmoy(ist)/radii
!  eq.15 (parameters kx, ky)
         kx2=3.-findex-avbt(ist)*avbt(ist)
         rmoy2=rmoy(ist)*rmoy(ist)
         kx2=kx2/rmoy2
         ky2=(findex-1.)/rmoy2
! ----  Transport matrix
         devi=alp(ist)
         AILONG=devi*rmoy(ist)
         L=AILONG
!     drad: horizontal deflector radius (cm)
!     l: length of the central trajectory (cm)
!     kx2, ky2: DIMENSIONLESS coefficients depending on the field indice
!     avb: average relativistic beta
       avb=avbt(ist)
       drad=rmoy(ist)
! --- deflector matrix
         WRITE(16,4101) charge(ist),nsec,nsector,efd0,rig(ist),
     *         findex,kx2,ky2,rmoy(ist),devi*180./pi,AILONG
4101      FORMAT(/,'  **************************************',/,
     *     '  *CENTRAL TRAJECTORY for charge: ',f4.1,' *',/,
     *     '  **************************************',/,
     *     '  SECTOR: ',i4,' SECTORS NUMBER: ',i5, /,
     *     '  RADIAL FIELD:   ',e12.5,' kV*cm-1: ',/,
     *     '  RIGIDITY:   ',e12.5,' kV ',/,
     *     '  FIELD INDEX: ',e12.5,' PARAMETER Kx: ',e12.5,
     *     ' cm-2  PARAMETER Ky: ',e12.5,' cm-2',/,
     *     '  BENDING RADIUS:  ',E12.5,' cm ',
     *     '  BENDING ANGLE:   ',E12.5,' deg',/,
     *     '  LENGTH: ',e12.5,' cm',/)
!   CLEAR R AND T
       CALL CLEAR
       CALL deflect(fdtot)
! ---  :print the transport matrix
        call matrix
        r51=r(5,1)
!  ----  transport of particles
        DO II=1,NGOOD
          if(int(f(9,ii)).eq.int(charge(ist))) then
            CALL COBEAM(II,L)
          endif
         enddo
! -------------------------------------------------------------------------
! --- get back the particles coordinates in the coordinates system of the synchronous particle
!   eq.33
       ec=-rmoy(ist)*cos(abet)-oo1*sin(devi)+rm0
       do ii=1,ngood
         if(int(f(9,ii)).eq.int(charge(ist))) then
!   eq.36
           f(2,ii)=f(2,ii)*cos(abet)-ec
!   eq.41
           f(3,ii)=f(3,ii)-abet*1.e03
!   eq.45
           gpai=f(7,ii)/xmat
           bpai=sqrt(1.-1./(gpai*gpai))
           f(6,ii)=f(6,ii)+r51*xmoy(ist)/(bpai*vl)
         endif
        enddo
!   enddo for ist (number of charges in the beam)
       enddo
! --------------------------------------------------------------
!  Space charge computation
         if(ichaes) then
! --- check the parity of nsec
          pnsec=float(nsec)/2.-nsec/2
          fprec=epsilon(pnsec)
!    nsec is odd:---> space charge computation
!          if((pnsec.ne.0.).and.(nsec.lt.nsector)) then
          if((abs(pnsec).gt.fprec).and.(nsec.lt.nsector)) then
            call cesp(scl)
            write(6,*) ' space charge after sector: ',nsec
          endif
        endif
! ------------------------------------------------------------
!  enveloppe
        PRLAB(IPRF)='EDFLEC  '
        CALL STAPL(sdavtot*10.)
!  enddo for nsec (sectors numbers)
       enddo
! ------------------------------------------------------
!  random error in alignment
       if(ialin) call randali
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
       call cogetc
! --- Test window after the bending magnet
       tcog=0.
       gcog=0.
       do i=1,ngood
         gcog=gcog+f(7,i)/xmat
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/float(ngood)
       gcog=gcog/float(ngood)
       bcog=sqrt(1.-1./(gcog*gcog))
       wcg=(gcog-1.)*xmat
! devtot: total angle of the deflector (computation of tref)
       devi=devtot
       ailong=devi*rm0
       TREF=TREF+AILONG/VREF
!    ----- window control
       PRTLAB=PRLAB(IPRF)
       call reject(ilost,PRTLAB)
! ---------------------------------------------------
       dav1(idav,36)=ngood
       if(itvol) ttvols=tref
       if(itvol) write(16,*) ' tof for adjustments: ',ttvols,' sec'
       if(iemgrw) call emiprt(0)
!old       CALL STAPL(davtot*10.)
!  ---- restore iseor (from sseor)
        iseor=sseor
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE cesp(xlqua)
!! select the space charge method (optical lenses)
!< *******************************************************************
       SUBROUTINE cesp(xlqua)
       implicit real(8) (a-h,o-z)
!       parameter (iptsz=1000002,maxcell=3000,maxcell1=4004)
       parameter (iptsz=1000002)
       common/tapes/in,ifile,meta,ierr
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/CDEK/DWP(iptsz)
       COMMON/DCSPA/IESP
       common/faisc/f(10,iptsz),imax,ngood
       common/mcs/imcs,ncstat,cstat(20)
       logical ichaes,iesp,isepa
       DO I=1,ngood
         DWP(I)=0.
       enddo
!      Space charge
       SCDIST=0.
       IF(.NOT.ICHAES) RETURN
!       XLQUA: length of space charge effect
        if((iscsp.ne.3).and.(ncstat.gt.1)) then
         write(6,*) '****************************'
         write(ierr,2748)
2748     format(' ERROR: Wrong space charge model chosen',/,
     *          ' With multiple charge states in the beam',/,
     *          ' only the SCHEFF routine should be used')
         write(16,2748)
         STOP
        endif
       SCDIST=XLQUA
       write(16,*) 'space charge length(cm): ',scdist
       iesp=.true.
       if(iscsp.le.1) then
         ini=1
         call hersc(ini)
         ini=2
         call hersc(ini)
       endif
       if(iscsp.eq.2)  call schermi
       if(iscsp.eq.3) then
         if(ncstat.eq.1) call scheff1(1)
! --- otherwise: ncstat > 1 check if the bunches are separated or not
         if(ncstat.gt.1) then
           isepa=.false.
           call b_sep(isepa)
! isepa = true  call special scheff --->scheff_sep
! isepa = false call usual scheff ----> scheff1(1)
           if(isepa) then
             call scheff_sep
           else  
             call scheff1(1)
           endif
         endif
       endif
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE sizer(ist,xrms,yrms,zrms)
!! partial R.M.S. (called by SCHEFF_sep)
!< *******************************************************************
       SUBROUTINE sizer(ist,xrms,yrms,zrms)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/CGRMS/xsum,ysum,zsum
       common/faisc/f(10,iptsz),imax,ngood
       common/mcs/imcs,ncstat,cstat(20)
       xsum=0.
       ysum=0.
       zsum=0.
       xsqsum=0.
       ysqsum=0.
       zsqsum=0.
       ngist=0
       do i=1,ngood
!        if(f(9,i).eq.cstat(ist)) then
        if(int(f(9,i)).eq.int(cstat(ist))) then
         ngist=ngist+1
         xsum=xsum+xc(i)
         ysum=ysum+yc(i)
         zsum=zsum+zc(i)
         xsqsum=xsqsum+xc(i)*xc(i)
         ysqsum=ysqsum+yc(i)*yc(i)
         zsqsum=zsqsum+zc(i)*zc(i)
        endif
       enddo
       xsum=xsum/float(ngist)
       ysum=ysum/float(ngist)
       zsum=zsum/float(ngist)
       xsqsum=xsqsum/float(ngist)
       ysqsum=ysqsum/float(ngist)
       zsqsum=zsqsum/float(ngist)
       xrms=SQRT(xsqsum-xsum*xsum)
       yrms=SQRT(ysqsum-ysum*ysum)
       zrms=SQRT(zsqsum-zsum*zsum)
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE pintim1(ist)
!! Shifts particle coordinates to a single point in time. Uses
!! a linear shift
!! Divide by 100. to convert from cm to meters
!! called by SCHEFF or SCHERM
!< *******************************************************************
       SUBROUTINE pintim1(ist)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/QMOYEN/QMOY
       COMMON/PART/XC(iptsz),YC(iptsz),ZC(iptsz)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/AZLIST/ICONT,IPRIN
       common/mcs/imcs,ncstat,cstat(20)
       grmoy=0.
       trmoy=0.
       xbax=0.
       ngist=0
       do i=1,ngood
!        if(f(9,i).eq.cstat(ist)) then
        if(int(f(9,i)).eq.int(cstat(ist))) then
         ngist=ngist+1
         grmoy=grmoy+f(7,i)/xmat
         trmoy=trmoy+f(6,i)
         xbax=xbax+f(2,i)
        endif
       enddo
       trmoy=trmoy/float(ngist)
       grmoy=grmoy/float(ngist)
       brmoy=sqrt(1.-1./(grmoy*grmoy))
       xbax=xbax/float(ngist)
!ccc       apl=0.
!  Isochronism correction  (bending magnet) only with SCHERM
!    does not work with  with SCHEFF  (iscsp=3)
!ccc       if(iscsp.eq.2) then
!ccc         xb2x=0.
!ccc         xb2z=0.
!ccc         xbxz=0.
!ccc         do np=1,ngood
!ccc           gpai=f(7,np)/xmat
!ccc           bpai=sqrt(1.-1./(gpai*gpai))
!ccc           zc(np)=(trmoy-f(6,np))*bpai*vl/100.
!ccc           xc(np)=(f(2,np)-xbax)/100.
!ccc           xb2z=xb2z+zc(np)*zc(np)
!ccc           xb2x=xb2x+xc(np)*xc(np)
!ccc           xbxz=xbxz+zc(np)*xc(np)
!ccc         enddo
!ccc         xb2z=xb2z/float(ngood)
!ccc         xb2x=xb2x/float(ngood)
!ccc         xbxz=xbxz/float(ngood)
!ccc         apl=atan(-2.*xbxz/(xb2x-xb2z))/2.
!ccc         write(16,*) 'slope of the bunch in plane(Oz,Ox):',apl,' radian'
!ccc       endif
       do np=1,ngood
!        if(f(9,np).eq.cstat(ist)) then
        if(int(f(9,np)).eq.int(cstat(ist))) then
         gpai=f(7,np)/xmat
         bpai=sqrt(1.-1./(gpai*gpai))
!      iscsp = 3 Lorentz transformation (only with scheff)
!omment         if(iscsp.eq.3) znp=(trmoy-f(6,np))*bpai*vl*grmoy
!omment         if(iscsp.eq.2) znp=(trmoy-f(6,np))*bpai*vl
         znp=(trmoy-f(6,np))*bpai*vl
         xnp=f(2,np)
         zc(np)=znp*cos(apl)+xnp*sin(apl)
         xnp=xnp*cos(apl)-znp*sin(apl)
!        convert from mrad to rad
         f3=f(3,np)*1.e-03
         f5=f(5,np)*1.e-03
!        convert from cm   to m
         xc(np)=(xnp+zc(np)*f3)/100.
         yc(np)=(f(4,np)+zc(np)*f5)/100.
         zc(np)=zc(np)/100.
        endif
       enddo
       xbar=0.
       ybar=0.
       zbar=0.
       do np=1,ngood
!      evaluate xbar , ybar , zbar
!        if(f(9,np).eq.cstat(ist)) then
        if(int(f(9,np)).eq.int(cstat(ist))) then
         xbar=xbar+xc(np)
         ybar=ybar+yc(np)
         zbar=zbar+zc(np)
        endif
       enddo
       xbar=xbar/float(ngist)
       ybar=ybar/float(ngist)
       zbar=zbar/float(ngist)
!  Translate distribution by center of mass coordinates to shift
!  coordinate origin to (0,0,0)
       do np=1,ngood
!        if(f(9,np).eq.cstat(ist)) then
        if(int(f(9,np)).eq.int(cstat(ist))) then
         xc(np)=xc(np)-xbar
         yc(np)=yc(np)-ybar
         zc(np)=zc(np)-zbar
        endif
       enddo
       return
       end
!> *******************************************************************
!! SUBROUTINE b_sep(isepa)
!! check if the bunches in the beam are separated or not
!< *******************************************************************
       SUBROUTINE b_sep(isepa)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/CGRMS/xsum,ysum,zsum
       common/faisc/f(10,iptsz),imax,ngood
       common/mcs/imcs,ncstat,cstat(20)
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       dimension d11(2),d22(2),d12(2),rp12(2),xpint(2),xint(2)
       logical isepa
       csmax1=0.
       icsm1=0
       do i=1,ncstat
        if(cstat(i).gt.csmax1) then
         icsm1=i
         csmax1=cstat(i)
        endif
       enddo
       csmax2=0.
       do i=1,ncstat
        if(i.ne.icsm1) then
         if(cstat(i).gt.csmax2) then
         csmax2=cstat(i)
         endif
        endif
       enddo
       xg1=0.
       xpg1=0.
       xg2=0.
       xpg2=0.
       imax1=0
       imax2=0
!   COG over state charges csmax1 and csmax2
       do i=1,ngood
!        if(f(9,i).eq.csmax1) then
        if(int(f(9,i)).eq.int(csmax1)) then
         xg1=xg1+f(2,i)
         xpg1=xpg1+f(3,i)
         imax1=imax1+1
        endif
!        if(f(9,i).eq.csmax2) then
        if(int(f(9,i)).eq.int(csmax2)) then
         xg2=xg2+f(2,i)
         xpg2=xpg2+f(3,i)
         imax2=imax2+1
        endif
       enddo
       xg1=xg1/float(imax1)
       xpg1=xpg1/float(imax1)
       xg2=xg2/float(imax2)
       xpg2=xpg2/float(imax2)
! ------------------------------------
       d11(1)=0.
       d22(1)=0.
       d12(1)=0.
       d11(2)=0.
       d22(2)=0.
       d12(2)=0.
       do i=1,ngood
!        if(f(9,i).eq.csmax1) then
        if(int(f(9,i)).eq.int(csmax1)) then       
         d11(1)=d11(1)+(f(3,i)-xpg1)**2
         d22(1)=d22(1)+(f(2,i)-xg1)**2
         d12(1)=d12(1)+(f(3,i)-xpg1)*(f(2,i)-xg1)
        endif
!        if(f(9,i).eq.csmax2) then
        if(int(f(9,i)).eq.int(csmax2)) then
         d11(2)=d11(2)+(f(3,i)-xpg2)**2
         d22(2)=d22(2)+(f(2,i)-xg2)**2
         d12(2)=d12(2)+(f(3,i)-xpg2)*(f(2,i)-xg2)
        endif
       enddo
       d11(1)=d11(1)/float(imax1)
       d22(1)=d22(1)/float(imax1)
       d12(1)=d12(1)/float(imax1)
       d11(2)=d11(2)/float(imax2)
       d22(2)=d22(2)/float(imax2)
       d12(2)=d12(2)/float(imax2)
       rp12(1)=d12(1)/sqrt(d11(1)*d22(1))
       rp12(2)=d12(2)/sqrt(d11(2)*d22(2))
       xpint(1)=sqrt(d11(1)*(1.-rp12(1)))
       xint(1)=sqrt(d22(1)*(1.-rp12(1)))
       xpint(2)=sqrt(d11(2)*(1.-rp12(2)))
       xint(2)=sqrt(d22(2)*(1.-rp12(2)))
! ------------------------------------------------------------
       elip1=xpg1+xpint(1)
       elip2=xpg2-xpint(2)
       if(elip1.lt.elip2)isepa=.true.
! TEST*********
!old       write(6,*)'xpg1 xpint(1) elip1 ',xpg1,xpint(1),elip1
!old       write(6,*)'xpg2 xpint(2) elip2 ',xpg2,xpint(2),elip2
!old       write(6,*)'isepa ',isepa
!old       write(6,*) ' ************************************'
! ***************************************************************
       RETURN
       END
!> *******************************************************************
!! SUBROUTINE schefini
!! Set up field tables for SCHEFF1 and SCHEFF_sep
!! input data
!!         sce(2)=radial extension in rms multiples
!!         sce(3)=longitudinal extension in rms multiples
!!         sce(4)=no. of radial mesh intervals (le 20)
!!         sce(5)=no. of longitudinal mesh intervals (le 40)
!!         sce(6)=no. of adjacent bunches, applicable for buncher
!!                studies and should be 0 for linac dynamics
!!         sce(7)=distance between adjacent beam pulses in cm
!!                (transport studies); input zero to get (beta*lambda)
!!                default
!!         sce(8)=deactived
!!         sce(9)=option to integrate space charge forces over box
!!                  if.eq.0. no integration  see sub gaus for further
!!                  explanation.
!!         sce(10) =1 : call in quads,solenoids,accelarating elements
!!         sce(10) =2 : call in drifts,accelarating elements
!!         sce(10) =3 : call at both
!!  standard SCHEFF parameters (see user guide)
!!         sce(2)=4
!!         sce(3)=4
!!         sce(4)=20
!!         sce(5)=40
!!         sce(6)=0
!!         sce(7)=0
!!         sce(9)=0
!< *******************************************************************
       SUBROUTINE schefini
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/DYN/TREF,VREF
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/faisc/f(10,iptsz),imax,ngood
       LOGICAL ichaes
!  common modified *********************
       common/stsc/beami,wavel,freq,btazero,frrms,fzrms,nr,nz
       common/stsc1/beams,im1,im2,im3,nr1,nz1,nq
       common/fldcom/ rp, zp,pl,opt,nip
! ***********************************
       common/rcshef/sce(20)
       common/conti/irfqp
       logical irfqp
         gmoy=0.
         do np=1,ngood
           gmoy=f(7,np)/xmat+gmoy
         enddo
         gmoy=gmoy/float(ngood)
         bgmoy=sqrt(gmoy*gmoy-1.)
         beams=beamc/1000.0
         wavel=2.*pi*vl/fh
         freq=fh/(2.*pi)
         frrms=sce(2)
         fzrms=sce(3)
         nr=idint(sce(4))
         nz=idint(sce(5))
         nip=idint(sce(6))
         opt=sce(9)
         pl=bgmoy*wavel
         if(irfqp) pl=pl/2.
!         sce(7)=pulse length, if not beta lambda.(transport studies), units are cm
         if(sce(7).gt. 0.) pl=sce(7)*gmoy
         nr1=nr+1
         nz1=nz+1
         im1=nr*nz
         im2=nr1*nz1
         im3=nr1*nz
         na=1
         nb=ngood
         nq=nb-na+1
         return
         end
!> *******************************************************************
!! SUBROUTINE scheff1(idum)
!! SCHEFF space charge method
!! remark: In this version int is a dummy parameter
!! This version of SCHEFF, starting from Swenson version, has
!! modifications made to include corrections for relativistic beams.
!! The dynamics have been modified to transform to the beam rest
!! frame, calculate the space-charge kicks in this frame, and then
!! transform back to the lab frame.
!!     input data
!!         sce(1)=beam current in ma.
!!         sce(2)=radial extension in rms multiples
!!         sce(3)=longitudinal extension in rms multiples
!!         sce(4)=no. of radial mesh intervals (le 20)
!!         sce(5)=no. of longitudinal mesh intervals (le 40)
!!         sce(6)=no. of adjacent bunches, applicable for buncher
!!                studies and should be 0 for linac dynamics
!!         sce(7)=distance between adjacent beam pulses in cm 
!!                (transport studies); input zero to get (beta*lambda)
!!                default
!!         sce(8)=deactived
!!         sce(9)=option to integrate space charge forces over box
!!                  if.eq.0. no integration  see sub gaus for further
!!                  explanation.
!!         sce(10) =1 : call in quads,solenoids,accelarating elements
!!         sce(10) =2 : call in drifts,accelarating elements
!!         sce(10) =3 : call at both
!!  standard SCHEFF parameters (see sub schfdyn and user guide)
!!         sce(2)=4
!!         sce(3)=4
!!         sce(4)=20
!!         sce(5)=40
!!         sce(6)=0
!!         sce(7)=0
!!         sce(9)=0
!< *******************************************************************
       SUBROUTINE scheff1(idum)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/DYN/TREF,VREF
       COMMON/CMPTE/IELL
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/DIMENS/zcp(iptsz),xcp(iptsz),ycp(iptsz)
       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/CDEK/DWP(iptsz)
       COMMON/BEAMSA/FS(7,iptsz)
       COMMON/DCSPA/IESP
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/posc/xpsc
       LOGICAL ichaes,iesp,acpt
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/bg/bsc,gsc,phis,wsync
       common/stsc/beami,wavel,freq,btazero,frrms,fzrms,nr,nz
       common/stsc1/beams,im1,im2,im3,nr1,nz1,nq
       common/fldcom/ rp, zp,pl,opt,nip
       common/spacech1/ rm(21), zm(41), rs(20), ers(16800), ezs(16800),
     1 ez(861), aa(800), rssq(20), zzs(41)
     2 ,er(861),rss(20), ismax(40), iemax(41)
       common/rcshef/sce(20)
       common/conti/irfqp
       dimension lossreason(iptsz)
       character*(8) PRTLAB
!********************************************
! v28/04/2015
       common/fcont/ifcont
       logical ifcont
!********************************************
       logical irfqp
       idm=idum
!     set up field tables with int=0
!omment       beami=beamc/1000.0
!********************************************
! v28/04/2015
       if(ifcont) then
         pib=180.
         call compress(pib)
       endif
!********************************************
       PRTLAB='SCHEFF  '
       fhbu=fh
       fh=fhinit
       beamc=beamc*fh/fhbu
       idm=0
       gmoy=0.
       do np=1,ngood
         gmoy=f(7,np)/xmat+gmoy
       enddo
       gmoy=gmoy/float(ngood)
       beami=beams
       fprec=epsilon(beamc)
!       IF (beami.eq.0. .OR. scdist.eq.0.) return
       IF(abs(beami).le.fprec .OR. abs(scdist).le.fprec) return       
       
       IELL=IELL+1
!       write(16,*) ' *call SCHEFF  ',iell
       call pintim
!       write(16,*) ' *after pintim '
       CALL sizrms(0,xrms,yrms,zrms,zz)
!       write(16,*) ' *after sizrms ',zz
       write(16,6875) iell,xrms,yrms,zrms
!   write the rms size to the output file 17
!omment       write(17,25) iell,xrms,yrms,zrms
!omment25     format(2x,i5,3(2x,e12.5))
6875   format(' Cell ',i4,' RMS size(m)',e12.5,2x,e12.5,2x,e12.5)
       rrms=sqrt(xrms*xrms+yrms*yrms)
!    change unit: m==>cm
       zrms1=zrms*100.
       rrms=rrms*100.
       dr=rrms*frrms/float(nr)
       dz=zrms1*fzrms/float(nz)
       rmax=float(nr)*dr
!          load rm, zm, rs, zs
       rm(1)=0.0
       do i=2,nr1
         rm(i)=float(i-1)*dr
         rssq(i-1)=.5*(rm(i-1)**2+rm(i)**2)
         rss(i-1)=0.5*(rm(i-1)+rm(i))
         rs(i-1)=sqrt(rssq(i-1))
       enddo
       zs=.5*dz
       do i=1,nz1
         zm(i)=float(i-1)*dz
         zzs(i)=zm(i)+zs
       enddo
       hl=float(nz)*zs
!          load ers and ezs
!     mesh dimensions are in cm. ers and ezs are in 1/cm.
!     c1, c2 and c3 are in cm., and c4 is in mev-cm.
!     q=coulombs/point.   (2/pi)*e/(4*pi*epsilon)=572167 cm mev/coul.
       q=beami/(freq*float(nq))
       c1=572167.*q/xmat
       l=0
       do k=1,nr
         rfac=(rm(k+1)**2-rm(k)**2)*dz/2.
!         if(opt.eq.0.) rfac=1.
         if(abs(opt).le.fprec) rfac=1.
         do j=1,nz
           zp=zm(j+1)
           do i=1,nr1
             rp=rm(i)
!             if(opt.eq.0.) then
             if(abs(opt).le.fprec) then
               call flds(rs(k),zs,er1,ez1)
             else
               call gaus (rm(k),rm(k+1),zm(1),zm(2),opt,er1,ez1)
             endif
             l=l+1
             ers(l)=c1*er1/rfac
!cc       write(16,*) ' ersl ',ers(l),' er1 ',er1,' l ',l
!cc       write(16,*) ' rsk ',rs(k),' k ',k,' zs ',zs
!cc       pause
             ezs(l)=c1*ez1/rfac
           ENDDO
         ENDDO    
       ENDDO
!       IF (beamc.eq.0. .OR. scdist.eq.0.) return
       IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return       
       dz1=scdist/100.
       dist=scdist
! sup       WRITE(16, *) ' fields acting length(cm): ',DIST
!          evaluate and apply space charge effects.
!     phimc=phi of mesh center.
!   Shifts particle coordinates to a single point in time. Uses
!   a linear shift
!      Beam c.g.
       xbar=0.
       ybar=0.
       zbar=0.
       brmoy=0.
       trmoy=0.
       do np=1,ngood
         gpai=f(7,np)/xmat
         brmoy=brmoy+sqrt(1.-1./(gpai*gpai))
         trmoy=trmoy+f(6,np)
       enddo
       trmoy=trmoy/float(ngood)
       phimc=trmoy*fh
       pbar=phimc
       beta=brmoy/float(ngood)
       gsc=1./sqrt(1.-beta*beta)
       bg=beta*gsc
       c3=dist/bg
! next one c4 not used ?       
       c4=dist*xmat
!          evaluate ng, xbar, ybar, and pbar.
       c2=bg*wavel/(2.*pi)
       gmsq=1.+bg**2
       gam=sqrt(gmsq)
!          evaluate ng, xbar, ybar
       ng=0
       xbar=0.
       ybar=0.
       xsq=0.
       ysq=0.
       do np=1,ngood
         ng=ng+1
         x=f(2,np)
         y=f(4,np)
         xf=f(3,np)
         yf=f(5,np)
         xbar=xbar+x
         ybar=ybar+y
         xsq=xsq+x**2
         ysq=ysq+y**2
       enddo
       eng=float(ngood)
       xbar=xbar/eng
       ybar=ybar/eng
!  the mesh center is phi*syn
       xsq=xsq/eng
       ysq=ysq/eng
       epsq=sqrt((xsq-xbar*xbar)/(ysq-ybar*ybar))
       epsqi=1./epsq
       xfac=2./(epsq + 1.)
       yfac=epsq*xfac
!          clear and load bins
       ng=0
       do i=1,im1
         aa(i)=0.0
       enddo
       do np=1,ngood
         rsq=(f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq
!     i=sqrt(rsq)/dr+1.
         r=sqrt(rsq)
         halfdr=dr*0.5
         i=idint(r/dr+1.0)
         if (i.gt.nr) cycle
         zph=f(6,np)*fh
         z=-c2*(zph-phimc)
         if (abs(z).ge.hl) cycle
!------distribute charge among adjacent bins.
         ng=ng+1
         zz=z+hl
         jm1=idint(zz/dz+1.)
         i1=i+1
         if (rsq.lt.rssq(i)) i1=i-1
!         if (rsq.lt.rss (i)) i1=i-1
         if (i1.lt.1) i1=1
         if (i1.gt.nr) i1=nr
         j1=jm1+1
         if (zz.lt.zzs(jm1)) j1=jm1-1
         if (j1.lt.1) j1=1
         if (j1.gt.nz) j1=nz
         a=1.
!     if (i1.ne.i) a=(rsq-rssq(i1))/(rssq(i)-rssq(i1))
         if (i1.eq.i) then
           a=1.
         else
           rdr2=rsq/dr**2
           if(rdr2.gt.0.25) then
             sqr=sqrt(4.*rdr2-1.)
           else
             f(8,np)=0.
             ilost=ilost+1
! needs to be on energy
             lossreason(np)=1     
             f6i=f(6,np)-trmoy
             write(49,3928) PRTLAB,idm,davtot/100.,i,int(f(1,np)),
     *        f(2,np),f(3,np),f(4,np),f(5,np),f6i*fh*180./pi,
     *        f(7,np)-xmat,f(9,np),lossreason(np)     
3928         FORMAT(1x,A8,1x,I4,1x,E12.5,1x,i5,1x,i5,1x,6(f12.3,1x),
     *              1x,f5.2,3x,i2)
             cycle
           endif   
           rminsq=(halfdr*(sqr-1.))**2
           rmaxsq=(halfdr*(sqr+1.))**2
           if (i1.lt.i) then
             a=(rmaxsq-rm(i)**2)/(rmaxsq-rminsq)
           else
             a=(rm(i1)**2-rminsq)/(rmaxsq-rminsq)
           endif
         endif
!omment         if (r.gt.halfdr)then
!omment           rminsq=(r-halfdr)**2
!omment           rmaxsq=(r+halfdr)**2
!omment           if (i1.lt.i) then
!omment             a=(rmaxsq-rm(i)**2)/(rmaxsq-rminsq)
!omment           else
!omment             a=(rm(i1)**2-rminsq)/(rmaxsq-rminsq)
!omment           endif
!omment         endif
         b=1.-a
         cc=1.
         if (j1.ne.jm1) cc=(zz-zzs(j1))/(zzs(jm1)-zzs(j1))
         d=1.-cc
         k=(jm1-1)*nr+i
         aa(k)=aa(k)+a*cc
         k=k+i1-i
         aa(k)=aa(k)+b*cc
         k=(j1-1)*nr+i
         aa(k)=aa(k)+a*d
         k=k+i1-i
         aa(k)=aa(k)+b*d
       enddo 
       eng=float(ng)
       do j=1,nz
         l=(j-1)*nr
         k=nr
         do i=1,nr
           m=l+k
           if(aa(m).le.0.0) then
             k=k-1
           else
             exit
           endif
         enddo
         ismax(j)=k
       enddo
!   find iemax for each j
       iemax(1)=1+ismax(1)
       do j=2,nz
         iemax(j)=1+max0(ismax(j-1),ismax(j))
       enddo
       iemax(nz1)=1+ismax(nz)
!   set er and ez to zero
       do i=1,im2
         er(i)=0.0
         ez(i)=0.0
       enddo
!          sum up fields
       do js=1,nz
         js1=js+1
         ism=ismax(js)
         if (ism.eq.0) cycle
         do is=1,ism
           l=(js-1)*nr+is
           a1=aa(l)
!           if (a1.eq.0.) cycle
           if (abs(a1).le.fprec) cycle
           l=(is-1)*im3
           do je=1,js
             k1=l+(js-je)*nr1
             n1=(je-1)*nr1
             iem=iemax(je)
             if (iem.le.1) cycle
             do ie=1,iem
               n=n1+ie
               k=k1+ie
               er(n)=er(n)+a1*ers(k)
               ez(n)=ez(n)-a1*ezs(k)
             enddo
           enddo
           do je=js1,nz1
             k1=l+(je-js1)*nr1
             n1=(je-1)*nr1
             iem=iemax(je)
             if (iem.le.1) cycle
             do ie=1,iem
               n=n1+ie
               k=k1+ie
               er(n)=er(n)+a1*ers(k)
               ez(n)=ez(n)+a1*ezs(k)
             enddo
           enddo   
         enddo   
       enddo   
!          evaluate and apply impulse
       rrmax=0.
       zzmax=0.
       zzmin=1000.
       npz=0
       npr=0
       do np=1,ngood
!
!  Transforming to the bunch reference frame
!
         dwc=f(7,np)-xmat
         gm1=dwc/xmat
!    convert xp an yp from mrad to rad
         f3np=f(3,np)*1.e-03
         f5np=f(5,np)*1.e-03
!omment   gm1*(2.+gm1)=(gam-1)*(gam+1)=gam*gam-1=beta*beta*gam*gam
         bgz=sqrt(gm1*(2.+gm1))
         bgx=bgz*f3np
         bgy=bgz*f5np
         gamma=1.+gm1
!  Particle momentum in the bunch frame
!
         bgzstar=gam*(bgz-beta*gamma)
!
!  Particle energy in bunch frame
!
         gstar=gam*(gamma-beta*bgz)
!
         r=sqrt((f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq)
         if(r.ge.rrmax) rrmax=r
!         if(r.eq.0.) r=.000001
         if(abs(r).le.fprec) r=.000001
         xor=(f(2,np)-xbar)*xfac/r
         yor=(f(4,np)-ybar)*yfac/r
         if(r.gt.rmax) then
           npr=npr+1
         else
           zph=f(6,np)*fh
           z=-c2*(zph-phimc)
           if(z.ge.zzmax) zzmax=z
           if(z.lt.zzmin) zzmin=z
           if(abs(z).gt.hl) then
             npz=npz+1
           else
!          interpolate impulse within mesh.
             rb=r/dr
             i=idint(1.+rb)
             a=rb-float(i-1)
             b=1.-a
             zb=(z+hl)/dz
             j=idint(1.+zb)
             c=zb-float(j-1)
             d=1.-c
             l=i+(j-1)*nr1
             m=l+nr1
             cbgr=c3*(d*(a*er(l+1)+b*er(l))+c*(a*er(m+1)+b*er(m)))
             cbgzs=c3*(d*(a*ez(l+1)+b*ez(l))+c*(a*ez(m+1)+b*ez(m)))
! *******************
!cc         write(14,5755)np,cbgr,cbgzs,c3,a,b,c,d
!cc         write(14,5755)np,l,m,er(l+1),er(l),er(m+1),er(m)
!cc5755   format(2x,i5,7(2x,e12.5))
!cc5755   format(3(2x,i5),4(2x,e12.5))
! *******************
!     different charge states in the bunch (valero)
             cbgr=cbgr*abs(f(9,np))
             cbgzs=cbgzs*abs(f(9,np))
           endif
!        estimate impulse based on point charge at xbar,ybar,pbar.
         endif
         if(r.gt.rmax .or. abs(z).gt.hl) then
           z=-c2*(f(6,np)*fh-pbar) 
           d=sqrt(z**2+r**2)
           rod3=r/d**3
           zod3=z/d**3
           if (nip.ne.0) then
!          include neighboring bunches.
             do i=1,nip
               xi=i
               do j=1,2
                 s=z+xi*pl
                 d=sqrt(s**2+r**2)
                 rod3=rod3+r/d**3
                 zod3=zod3+s/d**3
                 xi=-xi
               enddo
             enddo
           endif  
!  Evaluate impulse.
!
           cbgr=eng*c1*c3*rod3*pi/2.
           cbgzs=eng*c1*c3*zod3*pi/2.
!     different charges in the bunch (valero)
           cbgr=cbgr*abs(f(9,np))
           cbgzs=cbgzs*abs(f(9,np))
         endif  
!
!  Apply impulse and transform back to lab frame.
!
         bgx=bgx+cbgr*xor
         bgy=bgy+cbgr*yor
         pbgzstar=bgzstar
         bgzstar=bgzstar+cbgzs
         gstar=1.+0.5*bgzstar**2
         bgzf=gam*(bgzstar+beta*gstar)
         f3=bgx/bgzf
         f5=bgy/bgzf
         dww=f(7,np)-xmat
         dws=dww*((gamma+1.)/gamma)*(bgzf-bgz)/bgz
!cc         write(14,5755)np,pbgzstar,cbgzs,bgzstar
!cc5755   format(2x,i5,3(2x,e12.5))
!  ********************
         if(.not.iesp) then
!     load the entrance beam parameters for cavities or gaps
           do js=1,7
             f(js,np)=fs(js,np)
           enddo
!     dxp and dyp are the jumps of xp and yp (in rad) at the position dz1*xpsc (in m)
           dxp=f3-f3np
           dyp=f5-f5np
!   correction of xp and yp ( in rad)
           f(3,np)=f(3,np)+dxp*1000.
           f(5,np)=f(5,np)+dyp*1000.
           f(2,np)=f(2,np)-dz1*100.*dxp*xpsc
           f(4,np)=f(4,np)-dz1*100.*dyp*xpsc
           dwp(np)=dws
         else
           f(3,np)=f3*1000.
           f(5,np)=f5*1000.
           f(7,np)=f(7,np)+dws
         endif
       enddo
       beamc=beamc*fhbu/fh
       fh=fhbu       
       return
       end
!> *******************************************************************
!! SUBROUTINE scheff_sep
!! SCHEFF_sep special space charge method
!! This version of SCHEFF, starting from the Swenson version, has
!! modifications made to include corrections for relativistic beams.
!! The dynamics have been modified to transform to the beam rest
!! frame, calculate the space-charge kicks in this frame, and then
!! transform back to the lab frame.
!!     input data
!!         sce(1)=beam current in ma.
!!         sce(2)=radial extension in rms multiples
!!         sce(3)=longitudinal extension in rms multiples
!!         sce(4)=no. of radial mesh intervals (le 20)
!!         sce(5)=no. of longitudinal mesh intervals (le 40)
!!         sce(6)=no. of adjacent bunches, applicable for buncher
!!                studies and should be 0 for linac dynamics
!!         sce(7)=distance between adjacent beam pulses in cm
!!                (transport studies); input zero to get (beta*lambda)
!!                default
!!         sce(8)=deactived
!!         sce(9)=option to integrate space charge forces over box
!!                  if.eq.0. no integration  see sub gaus for further
!!                  explanation.
!!         sce(10) =1 : call in quads,solenoids,accelarating elements
!!         sce(10) =2 : call in drifts,accelarating elements
!!         sce(10) =3 : call at both
!!  standard SCHEFF parameters (see sub schfdyn and user guide)
!!         sce(2)=4
!!         sce(3)=4
!!         sce(4)=20
!!         sce(5)=40
!!         sce(6)=0
!!         sce(7)=0
!!         sce(9)=0
!< *******************************************************************
       SUBROUTINE scheff_sep
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
       COMMON/DYN/TREF,VREF
       COMMON/CMPTE/IELL
       COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
       COMMON/DIMENS/zcp(iptsz),xcp(iptsz),ycp(iptsz)
       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       common/faisc/f(10,iptsz),imax,ngood
       COMMON/CDEK/DWP(iptsz)
       COMMON/BEAMSA/FS(7,iptsz)
       COMMON/DCSPA/IESP
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/posc/xpsc
       LOGICAL ichaes,iesp,acpt
       COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
       common/bg/bsc,gsc,phis,wsync
       common/stsc/beami,wavel,freq,btazero,frrms,fzrms,nr,nz
       common/stsc1/beams,im1,im2,im3,nr1,nz1,nq
       common/fldcom/ rp, zp,pl,opt,nip
       common/spacech1/ rm(21), zm(41), rs(20), ers(16800), ezs(16800),
     1 ez(861), aa(800), rssq(20), zzs(41)
     2 ,er(861),rss(20), ismax(40), iemax(41)
       common/rcshef/sce(20)
       common/mcs/imcs,ncstat,cstat(20)
       common/conti/irfqp
       logical irfqp
       character*(8) PRTLAB
!     set up field tables with int=0
!       IF (beams.eq.0. .OR. scdist.eq.0.) return
       fprec=epsilon(beams)
       IF(abs(beams).le.fprec .OR. abs(scdist).le.fprec) return
       PRTLAB='SCHEFF  '
       fhbu=fh
       fh=fhinit
       beamc=beamc*fh/fhbu
!  isepa true ---> the ncstat bunches are separated
       IELL=IELL+1
       write(16,*) ' ****SCHEFF  ',iell
       write(16,*) ' Number of charge states: ',ncstat
       do isp=1,ncstat
         ngisp=0
         gmoy=0.
         do np=1,ngood
           if (int(f(9,np)).eq.int(cstat(isp))) then
             ngisp=ngisp+1
             gmoy=f(7,np)/xmat+gmoy
           endif
         enddo
         gmoy=gmoy/float(ngisp)
         beamc=beams*ngisp/ngood
         beami=beamc
         call pintim1(isp)
         CALL sizer(isp,xrms,yrms,zrms)
         write(16,6875) cstat(isp),beamc,xrms,yrms,zrms
6875     format(' charge: ',f8.0,' bunch intensity: ',e12.5,' amp',/,
     *        ' with RMS size(m)',e12.5,2x,e12.5,2x,e12.5)
         rrms=sqrt(xrms*xrms+yrms*yrms)
!    change unit: m==>cm
         zrms1=zrms*100.
         rrms=rrms*100.
         dr=rrms*frrms/float(nr)
         dz=zrms1*fzrms/float(nz)
         rmax=float(nr)*dr
!          load rm, zm, rs, zs
         rm(1)=0.0
         do i=2,nr1
           rm(i)=float(i-1)*dr
           rssq(i-1)=.5*(rm(i-1)**2+rm(i)**2)
           rss(i-1)=0.5*(rm(i-1)+rm(i))
           rs(i-1)=sqrt(rssq(i-1))
         enddo
         zs=.5*dz
         do i=1,nz1
           zm(i)=float(i-1)*dz
           zzs(i)=zm(i)+zs
         enddo
         hl=float(nz)*zs
!          load ers and ezs
!     mesh dimensions are in cm. ers and ezs are in 1/cm.
!     c1, c2 and c3 are in cm., and c4 is in mev-cm.
!     q=coulombs/point.   (2/pi)*e/(4*pi*epsilon)=572167 cm mev/coul.
         q=beami/(freq*float(nq))
         c1=572167.*q/xmat
         l=0
         do k=1,nr
           rfac=(rm(k+1)**2-rm(k)**2)*dz/2.
!           if(opt.eq.0.) rfac=1.
           if(abs(opt).le.fprec) rfac=1.
           do j=1,nz
             zp=zm(j+1)
             do i=1,nr1
               rp=rm(i)
!               if(opt.eq.0.) then
               if(abs(opt).le.fprec) then
                 call flds(rs(k),zs,er1,ez1)
               else
                 call gaus (rm(k),rm(k+1),zm(1),zm(2),opt,er1,ez1)
               endif
               l=l+1
               ers(l)=c1*er1/rfac
               ezs(l)=c1*ez1/rfac
             ENDDO
           ENDDO    
         ENDDO
!         IF (beamc.eq.0. .OR. scdist.eq.0.) return
         IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return       
         dz1=scdist/100.
         dist=scdist
! sup       WRITE(16, *) ' fields acting length(cm): ',DIST
!          evaluate and apply space charge effects.
!     phimc=phi of mesh center.
!   Shifts particle coordinates to a single point in time. Uses
!   a linear shift
!      Beam c.g.
         xbar=0.
         ybar=0.
         zbar=0.
         brmoy=0.
         trmoy=0.
         do np=1,ngood
           if(int(f(9,np)).eq.int(cstat(isp))) then
             gpai=f(7,np)/xmat
             brmoy=brmoy+sqrt(1.-1./(gpai*gpai))
             trmoy=trmoy+f(6,np)
           endif
         enddo
         trmoy=trmoy/float(ngisp)
         phimc=trmoy*fh
         pbar=phimc
         beta=brmoy/float(ngisp)
         gsc=1./sqrt(1.-beta*beta)
         bg=beta*gsc
         c3=dist/bg
         c4=dist*xmat
!          evaluate ng, xbar, ybar, and pbar.
         c2=bg*wavel/(2.*pi)
         gmsq=1.+bg**2
         gam=sqrt(gmsq)
!          evaluate ng, xbar, ybar
         ng=0
         xbar=0.
         ybar=0.
         xsq=0.
         ysq=0.
         do np=1,ngood
           if(int(f(9,np)).eq.int(cstat(isp))) then
             ng=ng+1
             x=f(2,np)
             y=f(4,np)
             xf=f(3,np)
             yf=f(5,np)
             xbar=xbar+x
             ybar=ybar+y
             xsq=xsq+x**2
             ysq=ysq+y**2
           endif
         enddo
         eng=float(ngisp)
         xbar=xbar/eng
         ybar=ybar/eng
!  the mesh center is phi*syn
         xsq=xsq/eng
         ysq=ysq/eng
         epsq=sqrt((xsq-xbar*xbar)/(ysq-ybar*ybar))
         epsqi=1./epsq
         xfac=2./(epsq + 1.)
         yfac=epsq*xfac
!          clear and load bins
         ng=0
         do i=1,im1
           aa(i)=0.0
         enddo
         do 120 np=1,ngood
           if(int(f(9,np)).eq.int(cstat(isp))) then
             rsq=(f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq
!     i=sqrt(rsq)/dr+1.
             r=sqrt(rsq)
             halfdr=dr*0.5
             i=idint(r/dr+1.0)
             if (i.gt.nr) go to 120
             zph=f(6,np)*fh
             z=-c2*(zph-phimc)
             if (abs(z).ge.hl) go to 120
!------distribute charge among adjacent bins.
             ng=ng+1
             zz=z+hl
             jm1=idint(zz/dz+1.)
             i1=i+1
!     if (rsq.lt.rssq(i)) i1=i-1
             if (rsq.lt.rss (i)) i1=i-1
             if (i1.lt.1) i1=1
             if (i1.gt.nr) i1=nr
             j1=jm1+1
             if (zz.lt.zzs(jm1)) j1=jm1-1
             if (j1.lt.1) j1=1
             if (j1.gt.nz) j1=nz
             a=1.
!     if (i1.ne.i) a=(rsq-rssq(i1))/(rssq(i)-rssq(i1))
             if (i1.eq.i) then
               a=1.
             else
               rdr2=rsq/dr**2
               sqr=sqrt(4.*rdr2-1.)
               rminsq=(halfdr*(sqr-1.))**2
               rmaxsq=(halfdr*(sqr+1.))**2
               if (i1.lt.i) then
                 a=(rmaxsq-rm(i)**2)/(rmaxsq-rminsq)
               else
                 a=(rm(i1)**2-rminsq)/(rmaxsq-rminsq)
               endif
             endif
             b=1.-a
             cc=1.
             if(j1.ne.jm1) cc=(zz-zzs(j1))/(zzs(jm1)-zzs(j1))
             d=1.-cc
             k=(jm1-1)*nr+i
             aa(k)=aa(k)+a*cc
             k=k+i1-i
             aa(k)=aa(k)+b*cc
             k=(j1-1)*nr+i
             aa(k)=aa(k)+a*d
             k=k+i1-i
             aa(k)=aa(k)+b*d
           endif
  120    continue
         eng=float(ng)
!          find ismax for each j
         do j=1,nz
           l=(j-1)*nr
           k=nr
           do i=1,nr
             m=l+k
             if(aa(m).gt.0.0) exit
             k=k-1
           enddo
           ismax(j)=k
         enddo
!        find iemax for each j
         iemax(1)=1+ismax(1)
         do j=2,nz
           iemax(j)=1+max0(ismax(j-1),ismax(j))
         enddo
         iemax(nz1)=1+ismax(nz)
!        set er and ez to zero
         do i=1,im2
           er(i)=0.0
           ez(i)=0.0
         enddo
c          sum up fields
         do js=1,nz
           js1=js+1
           ism=ismax(js)
           if (ism.eq.0) cycle
           do is=1,ism
             l=(js-1)*nr+is
             a1=aa(l)
!       if (a1.eq.0.) go to 210
             if (abs(a1).le.fprec) cycle
             l=(is-1)*im3
             do je=1,js
               k1=l+(js-je)*nr1
               n1=(je-1)*nr1
               iem=iemax(je)
               if (iem.le.1) cycle
               do ie=1,iem
                 n=n1+ie
                 k=k1+ie
                 er(n)=er(n)+a1*ers(k)
                 ez(n)=ez(n)-a1*ezs(k)
               enddo
             enddo
             do je=js1,nz1
               k1=l+(je-js1)*nr1
               n1=(je-1)*nr1
               iem=iemax(je)
               if (iem.le.1) cycle
               do ie=1,iem
                 n=n1+ie
                 k=k1+ie
                 er(n)=er(n)+a1*ers(k)
                 ez(n)=ez(n)+a1*ezs(k)
               enddo
             enddo
           enddo
         enddo
c          evaluate and apply impulse
         rrmax=0.
         zzmax=0.
         zzmin=1000.
         npz=0
         npr=0
         do np=1,ngood
!  Transforming to the bunch reference frame
!
           if(int(f(9,np)).eq.int(cstat(isp))) then
             dwc=f(7,np)-xmat
             gm1=dwc/xmat
!    convert xp an yp from mrad to rad
             f3np=f(3,np)*1.e-03
             f5np=f(5,np)*1.e-03
!omment   gm1*(2.+gm1)=(gam-1)*(gam+1)=gam*gam-1=beta*beta*gam*gam
             bgz=sqrt(gm1*(2.+gm1))
             bgx=bgz*f3np
             bgy=bgz*f5np
             gamma=1.+gm1
!  Particle momentum in the bunch frame
!
             bgzstar=gam*(bgz-beta*gamma)
!
!  Particle energy in bunch frame
!
             gstar=gam*(gamma-beta*bgz)
!
             r=sqrt((f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq)
             if(r.ge.rrmax) rrmax=r
!         if (r.eq.0.) r=.000001
             if (abs(r).le.fprec) r=.000001
             xor=(f(2,np)-xbar)*xfac/r
             yor=(f(4,np)-ybar)*yfac/r
             if (r.gt.rmax) then
               npr=npr+1
               go to 230
             endif
             zph=f(6,np)*fh
             z=-c2*(zph-phimc)
             if(z.ge.zzmax) zzmax=z
             if(z.lt.zzmin) zzmin=z
             if (abs(z).gt.hl) then
               npz=npz+1
               go to 230
             endif
!          interpolate impulse within mesh.
             rb=r/dr
             i=idint(1.+rb)
             a=rb-float(i-1)
             b=1.-a
             zb=(z+hl)/dz
             j=idint(1.+zb)
             c=zb-float(j-1)
             d=1.-c
             l=i+(j-1)*nr1
             m=l+nr1
             cbgr=c3*(d*(a*er(l+1)+b*er(l))+c*(a*er(m+1)+b*er(m)))
             cbgzs=c3*(d*(a*ez(l+1)+b*ez(l))+c*(a*ez(m+1)+b*ez(m)))
             cbgr=cbgr*abs(f(9,np))
             cbgzs=cbgzs*abs(f(9,np))
             go to 260
!        estimate impulse based on point charge at xbar,ybar,pbar.
230          continue
             z=-c2*(f(6,np)*fh-pbar) 
             d=sqrt(z**2+r**2)
             rod3=r/d**3
             zod3=z/d**3
             if (nip.ne.0) then
!          include neighboring bunches.
               do i=1,nip
                 xi=i
                 do j=1,2
                   s=z+xi*pl
                   d=sqrt(s**2+r**2)
                   rod3=rod3+r/d**3
                   zod3=zod3+s/d**3
                   xi=-xi
                 enddo
               enddo
             endif
!  Evaluate impulse.
!
             cbgr=eng*c1*c3*rod3*pi/2.
             cbgzs=eng*c1*c3*zod3*pi/2.
             cbgr=cbgr*abs(f(9,np))
             cbgzs=cbgzs*abs(f(9,np))
!
!  Apply impulse and transform back to lab frame.
!
260          bgx=bgx+cbgr*xor
             bgy=bgy+cbgr*yor
             bgzstar=bgzstar+cbgzs
             gstar=1.+0.5*bgzstar**2
             bgzf=gam*(bgzstar+beta*gstar)
             f3=bgx/bgzf
             f5=bgy/bgzf
             dww=f(7,np)-xmat
             dws=dww*((gamma+1.)/gamma)*(bgzf-bgz)/bgz
!  ********************
             if(.not.iesp) then
!     load the entrance beam parameters for cavities or gaps
               do js=1,7
                 f(js,np)=fs(js,np)
               enddo
!     dxp and dyp are the jumps of xp and yp (in rad) at the position dz1*xpsc (in m)
               dxp=f3-f3np
               dyp=f5-f5np
!   correction of xp and yp ( in rad)
               f(3,np)=f(3,np)+dxp*1000.
               f(5,np)=f(5,np)+dyp*1000.
               f(2,np)=f(2,np)-dz1*100.*dxp*xpsc
               f(4,np)=f(4,np)-dz1*100.*dyp*xpsc
               dwp(np)=dws
             else
               f(3,np)=f3*1000.
               f(5,np)=f5*1000.
               f(7,np)=f(7,np)+dws
             endif
           endif
         enddo
! big enddo of isp
       enddo
       beamc=beamc*fhbu/fh
       fh=fhbu       
       return
       end
!> *******************************************************************
!! SUBROUTINE rfkick(v,dp,harm,nvf)
!! RFKICK  (NO SPACE CHARGE EFFECT)
!!
!! Contributing Author: Daniel Alt, NSCL/MSU, East Lansing,  MI, USA
!! Date: 23-May-2014
!!
!! Electric RF kicker.  Simulates a sine wave chopper consisting
!! of two plates deflecting the beam in the transverse direction.
!! This is a zero length element.
!!
!! V:    Voltage Factor.  Consists of plate voltage in kV, times
!!       the electrode length divided by the gap between them.
!! DP:   RF phase offset in radians
!! Harm: Kicker harmonic number relative to current reference
!!       frequency
!! NVF:  Kicker axis: 0 = horziontal, 1= vertical (use negative
!!       voltage for negative deflection)
!< *******************************************************************
       SUBROUTINE rfkick(v,dp,harm,nvf)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       common/tapes/in,ifile,meta,ierr
       COMMON/RIGID/BORO
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/etcom/cog(8),exten(17),fd(iptsz)
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/corec/tref1
       COMMON/QMOYEN/QMOY
       common/aerp/vphase,vfield,ierpf
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       COMMON/SHIF/DTIPH,SHIFT
       common/tofev/ttvols
       character cr*1
       CHARACTER*(8) PRTLAB
!       dimension vecx(1)
       LOGICAL chasit,itvol,imamin,shift
!      ENVELOPE
!       PRLAB(IPRF)='RFKICK  '
       call stapl(davtot*10.)
!xx       ilost=0
       twopi=2.*pi
       freq=fh/twopi
       wavel=vl/freq
       fcpi=fh*180./pi
! print out on terminal of transport element # on one and the same line
       cr=char(13)
       WRITE(6,8254,advance='no') nrtre,cr
8254   format('Transport element:',i5,a1)
       if (harm.le.0.) harm=1.
!   test window - unneccesary at START of element - Alt
!       call reject(ilost,PRTLAB)
!   Calculate tof, beta, gamma, k.e. for c.o.g.
       tcog=0.
       bcog=0.
       do np=1,ngood
         tcog=tcog+f(6,np)
         gpa=f(7,np)/xmat
         bcog=sqrt(1.-1./(gpa*gpa))+bcog
       enddo
       tcog=tcog/float(ngood)
       bcog=bcog/float(ngood)
       gcog=1./sqrt(1.-bcog*bcog)
       encog=xmat*gcog-xmat
! adjustement of the phase of RF w.r.t. the T.O.F.
       xkpi=0.
       if(imamin) then
         ttvpi=harm*ttvols*fcpi
         xkpi=ttvpi/360.
         ixkpi=int(xkpi)
         xkpi=(xkpi-float(ixkpi))*360.
         write(16,*) ' *** TOF correction:',-xkpi,' deg'
         dp=dp-xkpi*pi/180.
         write(16,*)' ***phase of RF adjusted : ',dp*180./pi,' deg'
       endif
!  start of write to file '.short' for kicker
       idav=idav+1
       iitem(idav)=22
       dav1(idav,1)=v
       dav1(idav,2)=dp*180./pi
       dav1(idav,3)=nvf
       dav1(idav,4)=davtot*10.
!       if(itvol) dav1(idav,5)=-xkpi
       dav1(idav,5)=harm
!  end
       WRITE(16,178)
178    FORMAT(/,' Longitudinal parameters',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
       WRITE(16,1788) bcog,gcog,encog,tcog*fcpi,tcog
1788   FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       e0t=harm*v/(bcog*wavel)
       cay=harm*twopi/(bcog*gcog*wavel)
       caysq=cay**2
       con=twopi*e0t*qmoy/xmat
       rad=pi/180.
! shift=true => reference and COG seperated, otherwise reference=COG
! --- save the reference
       ovref=vref
       otref=tref
! --- shift = false: the reference particle is the cog
       if(shift) then
         ovref=vref
         beref=vref/vl
         gamref=1./sqrt(1.-beref*beref)
         older=xmat*gamref
       else
         tref=tcog
         vref=bcog*vl
         ovref=vref
         beref=bcog
         gamref=1./sqrt(1.-beref*beref)
         older=xmat*gamref
       endif
! ---  if imamin = false: phase setting has been forced equal to dp, otherwise phase setting has been adjusted
       ENRPRIN=older-xmat
       WRITE(16,165) beref,gamref,ENRPRIN,tref*fh*180./pi,tref
165    FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       wsync=0.
       bcour=0.
       tcog=0.
       do np=1,ngood
         a=harm*(f(6,np)-tref+ttvols)*fh+dp
         s=sin(a)
         w=f(7,np)-xmat
         gpai=f(7,np)/xmat
         bg=sqrt(w/xmat*(2.+w/xmat))
         bpai=bg/gpai
         const=(gpai/(gpai*gpai-1.))*f(9,np)
         disp=const*v/xmat*s
         bcour=bcour+bpai
         tcog=tcog+f(6,np)
         if (nvf.eq.0) then
           f(3,np)=f(3,np)+disp
         else if (nvf.eq.1) then
           f(5,np)=f(5,np)+disp
         else
           write(ierr,*) 'Invalid parameter NVF in RFKICK'
         endif
         wsync=wsync+w
       enddo
       wsync=wsync/float(ngood)
       bcour=bcour/float(ngood)
       tcog=tcog/float(ngood)
! Test window
       PRTLAB='RFKICK  '
       call reject(ilost,PRTLAB)
! dave start for kicker
       dav1(idav,36)=ngood
       call emiprt(0)
       return
       end
!> *******************************************************************
!! FUNCTION dkeBethe(xkeval)
!! Kinetic Energy Decrease in Carbon Stripper
!!
!! Input:  xkeval=particle energy (MeV)
!! Output: dkeBethe=energy loss (MeV)
!! Contributing Author: Ji-Ho Jang, RAON/IBS, Daejeon, South Korea
!! Date: 25-Jan-2016
!!
!! Based on Bethe-Bloch formula in "Energy loss in matter by heavy 
!! particles" by D. Groom, PDG-93-06
!! The charge state of projectile is the statistical net charge on the
!! partially neutralized ion.
!!     Ref: "The Stopping of Energetic light ions in elemental matter"
!!     by J.F. Ziegler in J. Appl. Phys / Rev. Appl. Phys., 85,
!!     1249-1279 (1999)
!< *******************************************************************
       FUNCTION dkeBethe(xkeval)
       implicit real(8) (a-h,o-z)
       common/strip/atm,qs,atms,ths,qop,sqst(6),anp,nqst
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
!--- Parameters to calculate dE/dx for graphite(Z=6,A=12.01115) with density of 2.265 g/cm^3 
!--- xNA: Avogadro's number
       xNA = 6.02214129E23
!--- re: classical electron radius in m
       re = 2.8179403267E-15
!--- xme: mass of electron in eV
       xme = 0.510998928E6
!--- znt  = A of graphite target
       znt=12.011
!--- parameters from appendix.2 in energy loss by D. Groom in PDG-93-06
       xIadj=78
       Cbar=2.8680
       x0=-0.0178
       x1=2.3415
       aval=0.2614
       xkval=2.8697
       d0val=0.12
!----------------------- End of parameters
!--- calculation start the energy loss in carbon stripper
!---------- in unit of eV, m/sec
       XMAS=XMAT*1.E6
       VLM = VL/100.
!--- velBohr: Bohr velocity in m/sec
       velBohr = VLM/137.035999
       gaval = 1. + xkeval/XMAT
       beval = sqrt(1.-1./(gaval*gaval))
       etaval = beval*gaval
!--- statistical net charge on the partially neutralized ion
!--- Ref: "The Stopping of Energetic light ions in elemental matter" 
!--- by J.F. Ziegler in J. Appl. Phys / Rev. Appl. Phys., 85, 1249-1279 (1999)
       znm = anp*(1.-exp(-beval*VLM/(anp**(2./3.)*velBohr)))
!--- xKEmaxval: maximum possible electron recoil kinetic energy
!--- (Energy loss in matter by heavy particles by D. Groom in Particle Data Group Notes, PDG-93-06)
       xKEmaxval=2.*xme*etaval**2./
     *             (1.+2.*gaval*xme/XMAS+(xme/XMAS)**2.)
       xKfactor = 4.*PI*xNA*re**2.*xme
!--- Cadjval: Analytic approximation of shell correction
!---          This formula is valid for beta*gamma > 0.13
!---          (Energy loss in matter by heavy particles by D. Groom in Particle Data Group Notes, PDG-93-06)
       Cadjval=(0.422377*etaval**(-2.)+0.0304043*etaval**(-4.)-
     *          0.00038106*etaval**(-6.))*1.E-6*xIadj**2.+
     *         (3.858019*etaval**(-2.)-0.1667989*etaval**(-4.)+
     *          0.00157955*etaval**(-6.))*1.E-9*xIadj**3.
!--- delden : Density effect correction
!---          (Energy loss in matter by heavy particles by D. Groom in Particle Data Group Notes, PDG-93-06)
       xin = log10(etaval)
       if(xin >= x1) then
         delden = 2.*log(10.)*xin-Cbar
       elseif(xin >= x0 .and. xin < x1) then
         delden = 2*log(10.)*xin-Cbar+aval*(x1-xin)**xkval 
       elseif(xin < x0) then
         delden = d0val*10.**(2*(xin-x0))
       endif
!-----------------------------------------------
       coeff=xKfactor*(znm/beval)**2*(qs/atms)
       factor1=1/2.*log(2*xme*etaval**2.*
     *                      xKEmaxval/xIadj**2.)
       factor2=beval**2.
       factor3=Cadjval/znt
       factor4=1/2.*delden
       factor=factor1-factor2-factor3-factor4
!--- dkeval: kinetic energy decrease in eV/(g/cm**2)
       dkecal=coeff*factor
!--- ths: thickness in g/cm**2 = 1E4*g/m**2
!--- dkeBethe: kinetic energy decrease in MeV
       dkeBethe=dkecal*ths*1.E4/1.E6
       return 
       END
!> *******************************************************************
!! SUBROUTINE buncnum
!! "Thick lens" BUNCHER with multi-harmonic capabilities
!< *******************************************************************
       SUBROUTINE buncnum
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell=3000,maxcell1=4004)
       COMMON/TTFS/DYNT(MAXCELL),DYNTP(MAXCELL),DYNTPP(MAXCELL),
     *   DYNE0(MAXCELL),DYNPH(MAXCELL),DYNLG(MAXCELL),FHPAR,NC
       COMMON/POSI/IST
       COMMON/MIDGAP/ENMIL,VAPMI
       COMMON/AZMTCH/DLG,XMCPH,XMCE
       COMMON/AZLIST/ICONT,IPRIN
       COMMON/ITVOLE/ITVOL,IMAMIN
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       common/cgtof/charm(20),cgtdv(20),nbch(20),netac
!      TRANSIT TIME COEFFICIENTS
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/faisc/f(10,iptsz),imax,ngood
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/cavnum1/xnh,xpas,ffield,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/rfield/ifield
       COMMON/QMOYEN/QMOY
       COMMON/RIGID/BORO
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST
       COMMON/DYN/TREF,VREF
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/compt1/ndtl,ncavmc,ncavnm
       COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
       common/tapes/in,ifile,meta,ierr
       common/etcom/cog(8),exten(17),fd(iptsz)
       common/speda/dave,idave
       COMMON/SHIF/DTIPH,SHIFT
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
       COMMON/DCSPA/IESP
       COMMON/PLTPRF/SPRFX(6001),SPRFY(6001),SPRFL(6001),SPRFW(6001),
     X               SPRFP(6001),SPRNG(6001),PRLAB(6001),IPRF
       common/appel/irstay,ilost,iavp,ispcel
       common/femt/iemgrw,iemqesg
!       common/mode/eflvl,rflvl
       common/aerp/vphase,vfield,ierpf
       common/tofev/ttvols
       common/elec/jelec
       common/step/istep
       common/xposi/xpost(10),xlce(2),xpax(2),iscx(2)
       common/kcell/avrg(15)
!********************************************
! reservation for TRACE3D related stuff
       common/trace3d/trace3h(100),trace3t(maxcell1),tif,kt3h,kt3t,fid
       common/t3dfld/fldctr(15),zend(15),T3D
       logical T3D
       character trace3h*128,trace3t*128,tif*128
!********************************************
       common/xitrd3/bcour1(15),bcour2(15),tr3dw(15),tr3ph(15),
     *  t0tr3d(15)
       common/buspe/ampl(5),phz(5),ifreq
       dimension phzt(5),dphse(5)
       logical iesp,ichaes,irstay,iavp,ispcel,ifield,iemgrw
       LOGICAL SHIFT,CHASIT,ITVOL,IMAMIN,DAVE,JELEC
       CHARACTER cr*1
!************************************************************
       CHARACTER*(8) PRLAB,PRTLAB
!    XESLN : NEGATIVE LENGHT OF THE DRIFT FOLLOWING THE GAP
!    IF XESLN N.E.0 THEN THE CHARGE SPACE EFFECT IMPLIES THE
!    LENGTH (YLG-XESLN)
       NRRES=NRRES+1
       ncavnm=ncavnm+1
! allow for print out on terminal of gap# on one and the same line
       cr=char(13)
       WRITE(6,8254,advance='no') NRTRE,NRRES,cr
8254   format('Transport element:',i5,
     *        '                       MHB:',i5,a1)
       WRITE(16,*)' CAVITY N :',NRRES
       ilost=0
       aqst=abs(qst)
       qmoy=aqst
! --- the frequency fh may be changed with delfh
       oldfh=fh
! --- ifreq: number of harmonic (max 5)
! --- ampl(i),  i = 1 to ifreq: amplitude of the voltage
! --- dphse(i), i = 1 to ifreq: phase offset (deg)
! --- FFIELD : in percent;
!      (electric field)=(initial electric field)*(1.+FFIELD/100)
       read (in,*) ifreq
       read (in,*) (ampl(i),i=1,ifreq)
       read (in,*) (dphse(i),i=1,ifreq)
       read (in,*) ffield,istep
!  *****************************************************************
       if(ncavnm.eq.1) write(13,990)
990    format(3x,'ncav',2x,'ncell',2x,'pos I(cm)',4x,'pos S(cm)',6x,
     * 'L cell(cm)',5x,'W(MeV)',7x,'dw(MeV)',6x,'TOF(dg)',7x,
     * 'Ph RF(dg)',5x,'avrg pos(cm)')
       if(ncavnm.eq.1) write(13,995)
995    format(3x,'ncell',3x,'E0TL(MeV)',4x,'T(k) MeV/q',4x,
     * 'S(k) MeV/q',5x,'dW(MeV)',6x,'PHASE(dg)',5x,
     * 'Ph crest(dg)')
       write(13,*)
! ***************************************************************
       ffield=1.+ffield/100.
       fprec=epsilon(ffield)
!       if(ffield.eq.0.) ffield=1.E-12
       if(abs(ffield).le.fprec) ffield=1.E-12
       if(ifield) then
! --- The field is read from the disk in the form:
!          z   (cm)   E(z) MV/cm
!     fhc: frequency of the cavity (Hertz) (read from the file 'field.txt' )
         fh=fhc*2.*pi
         ncel=ncell
         atte=att
         ye0=atte
!    flength : length of the field (cm)
         flength=xspl(npt)-xspl(1)
         ylg=flength
       else
! --- The field is read from the input list in the form of a Fourier series
         ncell=ncel
         oldfh=fh
!     atte: factor acting on the amplitude of the field (read from the input list)
         ye0=atte
       endif
!       dphete=dphase
! ********************************************************
! the following lignes are not used for the MHB (sv 22/8/2016)
!       if(itvol.and.imamin) then
! ---  adjustment of the phase offset w.r.t. the t.o.f.  (deg)
!        ottvol=fh*ttvols*180./pi
!        attvol=ottvol
!        xkpi=ottvol/360.
!        ixkpi=int(xkpi)
!        xkpi=(xkpi-float(ixkpi))*360.
!        dphase=dphase-xkpi
!       endif
! *******************************************************
       WRITE(16,150)FH/(2.*pi),YLG,ATTE,ffield,NCEL,istep,ifreq
150    FORMAT(4X,'FREQUENCY :',E12.5,' Hertz',/,4x,
     x        'FIELD LENGTH :',e12.5,' cm',/,4x,
     x        'FIELD FACTOR (UNITS CONVERSION) :',e12.5,/,4x,
     x        'FIELD FACTOR (ATTENUATION)      :',E12.5,/,4x,
     X        'FIELD DIVIDED IN: ',I4,' CELLS, STEPS PER CELL ',i5,/,
     X        4x,'Number of frequencies: ',I1)
       WRITE(16,*)'   Amplitude(s)   : ',(ampl(i),i=1,ifreq)  
       WRITE(16,*)'   Phase(s) in deg: ',(dphse(i),i=1,ifreq)   
!       if(.not.imamin) write(16,*) '   PHASE OFFSET: ',dphete,' DEG'
!       if(imamin) write(16,1501)dphete,DPHASE,xkpi
!1501   format(4x,
!     x        'PHASE OFFSET (before adjustment): ',e12.5,' deg',/,4x,
!     x        'PHASE OFFSET (after adjustment): ',e12.5,' deg',/,4x,
!     *        'ADJUSTMENT ON THE PHASE OFFSET: ',e12.5,' deg')
       fh0=fh/vl
       BEREF=VREF/VL
! --- ttvol: time of flight at entrance (sec)
       ttvol=0.
       if(itvol)ttvol=ttvols*fh
!  start file 'short.data'
! --- dav1(idav,3)=0: the particle reference and the cog coincide at the input
! --- dav1(idav,3)=1: the particle reference and the cog are independent
       dav1(idav,3)=0.
       idav=idav+1
       iitem(idav)=1
       dav1(idav,1)=ylg*10.
       dav1(idav,2)=ye0*100.
       davtot=davtot+ylg
       dav1(idav,24)=davtot*10.
       dav1(idav,40)=fh
       IF(IPRF.EQ.1) then
         PRLAB(IPRF)='START   '
         CALL STAPL(dav1(idav,24))
       endif
       iarg=1
       call cdg(iarg)
       enold=cog(1)
       encog=enold
       gcog=enold/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       IF(SHIFT) THEN
! --- the reference particle and the cog are independent
         BEREF=VREF/VL
         GAMREF=1./SQRT(1.-(BEREF*BEREF))
         ENREF=XMAT*GAMREF
         TREFDG=TREF*FH*180./PI
         dav1(idav,3)=1.
       ELSE
! --- the reference particle and the cog are coinciding
         beref=bcog
         vref=bcog*vl
         tref=tcog
         gamref=gcog
         enref=cog(1)
         dav1(idav,3)=0.
       ENDIF
       if(int(dav1(idav,3)).eq.1) write(16,*)
     *   ' **** reference and cog evolve independently'
       if(int(dav1(idav,3)).eq.0) write(16,*)
     *   ' **** the reference is the cog '
       WRITE(16,178)
178    FORMAT(/,' Dynamics at the input',/,
     2 5X,'   BETA     GAMMA      ENERGY(MeV) ',
     3 '       TOF(deg)     TOF(sec)')
       WRITE(16,1788) bcog,gcog,encog-xmat,tcog*fh*180./pi,tcog
1788   FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       ENRPRIN=ENREF-XMAT
       WRITE(16,165) beref,gamref,ENRPRIN,tref*fh*180./pi,tref
165    FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
       iprint=0
       call statis
! --- phases at the entrance w.r.t. frequencies
       do i=1,ifreq
         dphse(i)=dphse(i)*pi/180.
         xkitr=float(i)*fh/vref
! ---  transit time factors TK and SK  based on the velocity at the entrance
         TK=SPTTA0(xkitr)
         SK=SPTSB0(xkitr)
! ---  dW(phz) = 0
         phzt(i)=atan(tk/sk)
         phz(i)=phzt(i)+dphse(i)+ttvol
         dwtest=tk*cos(phz(i))-sk*sin(phz(i))
         write(16,9650) i,xkitr,tk,sk,dwtest,180./pi*phzt(i),
     *    180./pi*phz(i)
       enddo
9650   format(2x,i3,6(2x,e12.5))
! --- compute energy and TOF of reference
       call dwref_bunc(gams,ts)
       enrs=gams*xmat
       ddw=enrs-enref
       trefs=ts+tref
       bets=sqrt(gams*gams-1.)/gams
       TREDG=fh*TREFS *180./PI
!  dynamics of the bunch
       call bcnum_bunc(ylg,ncell)
       gcg=0.
       do i=1,ngood
         gcg=gcg+f(7,i)/xmat
       enddo
       gcg=gcg/float(ngood)
       bcg=sqrt(1.-1./(gcg*gcg))
       wcg=(gcg-1.)*xmat
       call cogetc
       do i=1,ngood
         gpai=f(7,i)/xmat
         if(gpai.lt.1.) gpai=1.
         bpai=sqrt(1.-1./(gpai*gpai))
         fd(i)=bpai/bcg * gpai/gcg
       enddo
! ---- window control
       tref=trefs
       vref=bets*vl
       PRTLAB='MHB     '
       call reject(ilost,PRTLAB)
       write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
       write(16,*) '***********************************************'
       write(16,*) ' ENERGY GAIN(MeV) ',DDW,' TOF ',tredg,' DEG'
       write(16,*) ' PHASES OF RF AT ENTRANCE(DG): '
       write(16,*) '    BFA = BEFORE adjustment  AFA = AFTER adjustment'
       do i =1,ifreq
         write(16,3636) float(i)*fhc,phzt(i)*180./pi,phz(i)*180./pi
       enddo
3636   format(2x,'freq.(Hz) ',e12.5,' phase BFA(deg) ',e12.5,
     *        ' phase AFA(deg)  ',e12.5)
       iarg=1
       call cdg(iarg)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.-1./(gcog*gcog))
       tcog=cog(3)
       CALL EXT2D(1)
! dphse(i)  dphete     
       if(itvol) then
         write(16,*) '    TOF is active'     
         dav1(idav,38)=dphse(1)-90.
! next line to be fixed
         dav1(idav,39)=0.
!         dav1(idav,39)=dphase*180./pi
       else
         dav1(idav,38)=dphse(1)-90.
       endif
       WRITE(16,3777)
3777   FORMAT(/,' Dynamics at the output',/,
     1 5X,'   BETA     dW(MeV)     ENERGY(MeV) ',
     2 '   TOF(deg)     TOF(sec)')
       engain=encog-enold
       WRITE(16,3473) bets,ddw,enrs-xmat,fh*TREFS *180./PI,TREFS
3473   FORMAT(' REF ',f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)
       WRITE(16,1789) bcog,engain,encog-xmat,tcog*fh*180./pi,tcog
1789   FORMAT(' COG ',f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)
       TESTCA=exten(1)*exten(2)*exten(3)
       epsil=1.E-40
       IF(abs(TESTCA).gt.epsil) THEN
         QDISP=2.*SQRT(exten(1))
         QMD=exten(1)*exten(3)-exten(2)**2
         SQMDV=4.*PI*SQRT(QMD)
         SURM=4.*PI*SQRT(QMD)*180./PI
         QDP=2.*SQRT(exten(3))
         COR12=exten(2)/sqrt(exten(1)*exten(3))
         QDPDE=QDP*180./PI
       ELSE
         QDISP=0.
         QMD=0.
         SQMDV=0.
         SURM=0.
         QDP=0.
         COR12=0.
         PENT12=0.
         PENT21=0.
         QDPDE=0.
       ENDIF
       TRQTX=exten(4)*exten(5)-exten(8)**2
       TRQPY=exten(6)*exten(7)-exten(9)**2
       QDITAX=2.*SQRT(exten(4))
       QDIANT=2.*SQRT(exten(5))
       QDITAY=2.*SQRT(exten(6))
       QDIANP=2.*SQRT(exten(7))
       SURXTH=4.*PI*SQRT(TRQTX)
       SURYPH=4.*PI*SQRT(TRQPY)
       IF(SHIFT) THEN
         vref=bets*vl
         tref=trefs
       ELSE
         vref=bcog*vl
         tref=tcog
       ENDIF
       if(itvol) ttvols=tref
       call statis
!      ENVEL
       PRLAB(IPRF)=PRTLAB
       CALL STAPL(dav1(idav,24))
       dav1(idav,16)=bcog*surxth*10./(pi*sqrt(1.-bcog*bcog))
       dav1(idav,21)=bcog*suryph*10./(pi*sqrt(1.-bcog*bcog))
       dav1(idav,25)=nrres
       dav1(idav,30)=ngood
!
!   print to 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!
! --- dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
! --- dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
       emns=1.e12*sqmdv/(pi*fh)
       trfprt=fh*tref*180./pi
       tcgprt=fh*tcog*180./pi
! cavity number, z (m), transmission (%), synchronous phase (deg), time of flight (deg) (within -180 deg and 180 deg),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
       trnsms=100.*float(ngood)/float(imax)
       if(ncavnm.eq.1) write(50,*) '# cavnum.dmp'
       if(ncavnm.eq.1) write(50,*) '# cav     Z       trans   ',
     *   'PHIs     TOF(COG)    COG        Wcog          TOF(REF)   ',
     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
     *   'El,RMS        dWref        EffVolt'
       if(ncavnm.eq.1) write(50,*) '#  #     (m)       (%)    ',
     *  '(deg)     (deg)      beta       (MeV)          (deg)      ',
     *  '   beta       (MeV)       (mm.mrad)    (mm.mrad)    ',
     *  '(ns.keV)      (MeV)          (MV)'
       write(50,7023) nrres,0.001*dav1(idav,24),trnsms,dphete,
     *  tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat,
     *  0.25*dav1(idav,16),0.25*dav1(idav,21),0.25*emns,ddw,dwmx
7023     format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
     *   2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x))
       fh=oldfh
!       new magnetic rigidity of the reference
       gref=1./sqrt(1.-bets*bets)
       xmor=xmat*bets*gref
       BORO=33.356*XMOR*1.E-01/AQST
       WRITE(16,*) ilost,' particles lost in cavity ',nrres
       call emiprt(0)
       return
       end
!> *******************************************************************
!! FUNCTION xf1
!! energy gain over the step
!< *******************************************************************
       FUNCTION xf1(ico,rphas,t0,t5)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/buspe/ampl(5),phz(5),ifreq
       common/tespart/jpart
       xf1=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2
       b34=(b3+b4)/2
       b45=(b4+b5)/2
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       tspl=0.
       do i=1,ifreq
         fhi=fh*float(i)
         phzi=phz(i)+rphas*fhi
! --- rphas = phase particle - phase reference
! --- ico flag
! ----  if ico = 1 ---> coupling terms R and RP (see equations)
         cco=1.
         if(ico.ne.0) cco=float(i)
         xspl0=cos(fhi*t0+phzi)*tspl0
         xspl1=cos(fhi*t1+phzi)*tspl1
         xspl2=cos(fhi*t2+phzi)*tspl2
         xspl3=cos(fhi*t3+phzi)*tspl3
         xspl4=cos(fhi*t4+phzi)*tspl4
         xspl5=cos(fhi*t5+phzi)*tspl5
         tspli=19.*xspl0+75.*xspl1+50.*xspl2+50.*xspl3+75.*xspl4
     *     +19.*xspl5
         tspli=xpas/288. * tspli*ampl(i)*cco*cco
         tspl=tspl+tspli
       enddo
       xf1=tspl
       return
       end
!> *******************************************************************
!> *******************************************************************
!! FUNCTION xf2
!! coupling terms in R and R' (energy gain)
!< *******************************************************************
       FUNCTION xf2(rphas,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/buspe/ampl(5),phz(5),ifreq
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       tspl=0.
       do i =1,ifreq
         fhi=fh*float(i)
         phzi=phz(i)+rphas*fhi
         xspl1=cos(fhi*t1+phz(i))*tspl1
         xspl2=cos(fhi*t2+phz(i))*tspl2
         xspl3=cos(fhi*t3+phz(i))*tspl3
         xspl4=cos(fhi*t4+phz(i))*tspl4
         xspl5=cos(fhi*t5+phz(i))*tspl5
         tspli=15.*xspl1+20.*xspl2+30.*xspl3+60*xspl4+19.*xspl5
         tspli=xpas/288. * tspli*ampl(i)*float(i)*float(i)
         tspl=tspl+tspli
       enddo
       xf2=tspl
       return
       end
!> *******************************************************************
!! FUNCTION xjf1
!! transverse motion field dE/dt
!< *******************************************************************
       FUNCTION xjf1(rphas,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/buspe/ampl(5),phz(5),ifreq
! --- the field is read from the disk
       xjf1=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       tspl=0.
       do i =1,ifreq
         fhi=fh*float(i)
         phzi=phz(i)+rphas*fhi
         xspl0=-fhi*sin(fhi*t0+phzi)*tspl0/bgt0
         xspl1=-fhi*sin(fhi*t1+phzi)*tspl1/bgt1
         xspl2=-fhi*sin(fhi*t2+phzi)*tspl2/bgt2
         xspl3=-fhi*sin(fhi*t3+phzi)*tspl3/bgt3
         xspl4=-fhi*sin(fhi*t4+phzi)*tspl4/bgt4
         xspl5=-fhi*sin(fhi*t5+phzi)*tspl5/bgt5
         tspli=19.*xspl0+75.*xspl1+50.*xspl2+50.*xspl3+75.*xspl4
     *     +19.*xspl5
         tspli=xpas/288. * tspli*ampl(i)
         tspl=tspl+tspli
       enddo
       xjf1= tspl
       return
       end
!> *******************************************************************
!! FUNCTION xjf2
!! transverse motion field dE/dt
!< *******************************************************************
       FUNCTION xjf2(rphas,t0)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/buspe/ampl(5),phz(5),ifreq
       xjf2=0.
       b01=(b0+b1)/2.
       b12=(b1+b2)/2.
       b23=(b2+b3)/2.
       b34=(b3+b4)/2.
       b45=(b4+b5)/2.
       t1=t0+xpas/(5.*b01*vl)
       t2=t1+xpas/(5.*b12*vl)
       t3=t2+xpas/(5.*b23*vl)
       t4=t3+xpas/(5.*b34*vl)
       t5=t4+xpas/(5.*b45*vl)
       tspl=0.
       do i =1,ifreq
         fhi=fh*float(i)
         phzi=phz(i)+rphas*fhi
         xspl1=-fhi*sin(fhi*t1+phzi)*tspl1/bgt1
         xspl2=-fhi*sin(fhi*t2+phzi)*tspl2/bgt2
         xspl3=-fhi*sin(fhi*t3+phzi)*tspl3/bgt3
         xspl4=-fhi*sin(fhi*t4+phzi)*tspl4/bgt4
         xspl5=-fhi*sin(fhi*t5+phzi)*tspl5/bgt5
         tspli=15.*xspl1+20.*xspl2+30.*xspl3
     *          +60.*xspl4+19.*xspl5
         tspli=xpas/288. * tspli*ampl(i)
         tspl=tspl+tspli
       enddo
       xjf2=tspl
       return
       end
!> *******************************************************************
!! FUNCTION spta0
!! Special Transit time factor t(k) (single cell)
!< *******************************************************************
       FUNCTION spta0(xkitr,nrc)
       implicit real(8) (a-h,o-z)
       common/consta/vl,pi,xmat,rpel,qst
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
       common/fcv/jsav
! ---       xk=fhc*2.*pi/(betr*vl)
       ar=0.
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         AR=AR+T1(I)*RFONC*COS(XKitr*XC)
       enddo
       spta0=ar*(xc2-xc1)
       return
       END
!> *******************************************************************
!! FUNCTION sptta0(xkitr)
!! Special Transit time factor t(k) (multi-cells)
!< *******************************************************************
       FUNCTION sptta0(xkitr)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         sptta0=0.
         do i=1,ncell
           sptta0=sptta0+spta0(xkitr,i)
         enddo
        return
       else
! -----         xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         sptta0=0.
         ar=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2)) EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             AR=AR+H(I)*RFONC*COS(XKITR*XC)
           enddo
           AR=AR*(XC2-XC1)
           SPTTA0=SPTTA0+AR
           AR=0.
           IPAS=IPAS+1
         ENDDO
       endif
       return
       end
!> *******************************************************************
!! FUNCTION spsb0(xk,nrc)
!! Special Transit time factor s(k) (single cell)
!< *******************************************************************
       FUNCTION spsb0(xkitr,nrc)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       common/gaus13/H(13),T(13)
       common/gaus17/H1(17),T1(17)
! ---       xk=fhc*2.*pi/(betr*vl)
       xc1=xlim(nrc)
       xc2=xlim(nrc+1)
       br=0.
       DO I=1,17
         XC= (XC2+XC1)/2.+(XC2-XC1)*H1(I)/2.
         rfonc=fcav(xc,nrc)
         BR=BR+T1(I)*RFONC*SIN(XKITR*XC)
       enddo
       SPSB0=BR*(XC2-XC1)
       return
       END
!> *******************************************************************
!! FUNCTION sptsb0(xkitr)
!! Special Transit time factor s(k) (multi-cells)
!< *******************************************************************
       FUNCTION sptsb0(xkitr)
       implicit real(8) (a-h,o-z)
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/consta/vl,pi,xmat,rpel,qst
       COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
       COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
       common/rfield/ifield
       common/gaus13/H(13),T(13)
       dimension xmin(15)
       logical ifield
       fprec=epsilon(xmin(1))
       if(ifield) then
         sptsb0=0.
         do i=1,ncell
           sptsb0=sptsb0+spsb0(xkitr,i)
         enddo
         return
       else
! ---       xk=fh/(betr*vl)
         xmin(1)=0.
         do i=2,ncel+2
           xmin(i)=0.
         enddo
         do i=2,ncel+1
           xmin(i)=ylg*(i-1)/ncel
         enddo
         ipas=1
         sptsb0=0.
         br=0.
         xc1=0.
         xc2=0.
         DO
!           if(xmin(ipas+1).eq.0.or.ipas.gt.(ncel+2)) EXIT
           if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2)) EXIT
           do i=1,13
             xc1=xmin(ipas)
             xc2=xmin(ipas+1)
             XC= (XC2+XC1)/2.+(XC2-XC1)*T(I)/2.
             RFONC= FONE(XC)
             BR=BR+H(I)*RFONC*SIN(XKITR*XC)
           enddo
           BR=BR*(XC2-XC1)
           sptsb0=sptsb0+br
           br=0.
           IPAS=IPAS+1
         ENDDO
       endif
       end
!> *******************************************************************
!> *******************************************************************
!! SUBROUTINE dwref_bunc(gam5,t5)
!! compute the energy gain and the time of flight of the reference
!! over the cavity(gap) at the exit of the cavity(gap):
!! gam5 = relativistic gamma,  t5 = tof (cavity)
!< *******************************************************************
       SUBROUTINE dwref_bunc(gam5,t5)
       implicit real(8) (a-h,o-z)
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/cavnum7/sspl0,sspl1,sspl2,sspl3,sspl4,sspl5
       common/consta/vl,pi,xmat,rpel,qst
       common/spl/xspl(4000),yspl(4000),s(3000),p(3000),q(3000)
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       COMMON/DYN/TREF,VREF
       common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att,
     *             npoint(15),ncell
       common/step/istep
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/kcell/avrg(15)
       common/xitrd3/bcour1(15),bcour2(15),tr3dw(15),tr3ph(15),
     *  t0tr3d(15)
       common/sphi/tcour1(15),tcour2(15)
       common/t3dfld/fldctr(15),zend(15),T3D
       logical T3D
!  save previous xpas
       xpcel=xpas
       xlpos=0.
       isce=20
       xlcum=0.
       b0=vref/vl
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       t0=0.
!   xlcel (cm): length of current cell
!   xlim(inc) cm: limits of current cell
!   isce: step number in cell (forced isce = 20)
!   wdgam: energy gain over the cell
! **************************************
       do inc=1,ncell
         bcour1(inc)=b0
         tcour1(inc)=t0
         wdgams=0.
         xnh=0.
         xlcel=xlim(inc+1)-xlim(inc)
         xlpos=xlpos+xlcel
         xpas=xlcel/float(isce)
         e0=xmat
         xnhc=0
         gam0=1./sqrt(1.-b0*b0)
         estop=xpas/10.
         istop=0
         DO
           xpat=xnhc*xpas
           if(xpat.ge.(xlcel-estop)) EXIT
           call fposbb(xlcum)
! ---  energy gain over the step
           b1=b0
           b2=b0
           b3=b0
           b4=b0
           b5=b0
           rphas=0.
           ico=0
! predictor
           dgam=xf1(ico,rphas,t0,t5)*qst/e0
           gam5=gam0+dgam
! corrector
           xpas2=xpas*xpas
           dgdz=qst/e0 * tspl0
           d2gdz2=dgam/xpas2-dgdz/xpas
           d2gdz2=2.*d2gdz2
           gam1=gam0+dgdz*xpas/5.+d2gdz2*xpas2/50.
           gam2=gam0+dgdz*xpas*2./5.+d2gdz2*xpas2*4./50.
           gam3=gam0+dgdz*xpas*3./5.+d2gdz2*xpas2*9./50.
           gam4=gam0+dgdz*xpas*4./5.+d2gdz2*xpas2*16./50.
           b1=sqrt(gam1*gam1-1.)/gam1
           b2=sqrt(gam2*gam2-1.)/gam2
           b3=sqrt(gam3*gam3-1.)/gam3
           b4=sqrt(gam4*gam4-1.)/gam4
           b5=sqrt(gam5*gam5-1.)/gam5
           dgam=xf1(ico,rphas,t0,t5)*qst/e0
           gam5=gam0+dgam
           eww=xmat*(gam5-1.)
           wdgam=xmat*dgam
           wdgams=wdgams+wdgam
           b5=sqrt(gam5*gam5-1.)/gam5
           b0=b5
           t0=t5
           gam0=gam5
           xnh=xnh+1.
           xnhc=xnhc+1.
         ENDDO
         tcour2(inc)=t5
         xlcum=xlcum+xlcel
         ttvol=t5*fh*180./pi
         ttphi=ttvol+tref*fh*180/pi
         bcour2(inc)=b5
         tr3dw(inc)=wdgams
! ************************************************
         write(13,101) NRRES,inc,xlim(inc),xlim(inc+1),
     *   xlcel,eww,wdgams,ttvol,ttphi,avrg(inc)
101      format(2(2x,i4),8(2x,e12.5))
         fldctr(inc)=avrg(inc)-xlim(inc)
         zend(inc)=xlcel-fldctr(inc)
       enddo
!       call itrd3
! restore  xpas
       xpas=xpcel
       return
       end
!> *******************************************************************
!! SUBROUTINE bcnum_bunc(ylg,ncell)
!! dynamics in the thick buncher
!< *******************************************************************
       SUBROUTINE bcnum_bunc(ylg,ncell)
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002,maxcell1=4004)
       COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
       COMMON/DYN/TREF,VREF
       COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
       COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
       common/dcspa/iesp
       common/ttfc/tk,t1k,t2k,sk,s1k,s2k,fh
       common/faisc/f(10,iptsz),imax,ngood
       common/consta/ vl,pi, xmat,rpel,qst
       common/cavnum1/xnh,xpas,fmult,npt
       common/cavnum2/b0,b1,b2,b3,b4,b5
       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
       common/cavnum4/bge0,bge1,bge2,bge3,bge4,bge5
       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
       common/rfield/ifield
       common/TESTREF/trefs,ddw
       common/elec/jelec
       common/step/istep
       common/tespart/jpart
       dimension gam(500),xe(500),xpe(500),ye(500),ype(500)
       dimension tcour(iptsz),phi(iptsz)
       logical ifield,flgsc,ichaes,iesp,jelec
       character*(8) PRTLAB
       dimension lossreason(iptsz)
!   ylg(cm) length of cavity, xpas(cm): step length
!   8 steps over a cell
       PRTLAB='MHB'
       BEREF=VREF/VL
       GAMREF=1./SQRT(1.-(BEREF*BEREF))
       ENREF=XMAT*GAMREF
       e0=xmat
       npas=ncell*istep
       xpas=ylg/float(npas)
       npas1=npas+1
       xnh=0.
!   flgsc = true ---> s.c. computation
!   eglsc = 2*xpas : acting length of s.c. computation
       eglsc=2.*xpas
       flgsc=.false.
       do i=2,npas1
         i1=i-1
! --- seek the field E(z) values in the 6 positions in the step length xh
         call fposb
         tmoy=0.
         do j=1,ngood
           tmoy=tmoy+f(6,j)
         enddo
         tmoy=tmoy/float(ngood)
         do j=1,ngood
           qc=f(9,j)
           gam0=f(7,j)/e0
           gam(i1)=gam0
           if(i1.eq.1) then
             tcour(j)=0.
             tof=f(6,j)
! ---  phase delay between the actual particle  and the reference (entrance of the cavity)
             phi(j)=(tof-tref)
           endif
           t0=tcour(j)
           ddt=t0
!  predictor (energy gain)
           if(gam0.le.1.) then
             f(8,j)=0.
             cycle
           endif
           b0=sqrt(gam0*gam0-1.)/gam0
           b1=b0
           b2=b0
           b3=b0
           b4=b0
           b5=b0
           ico=0
           dgam=xf1(ico,phi(j),t0,t5)*qc/e0
           gam5=gam(i1)+dgam
!   corrector (energy gain)
!   tspl0 = dE/dz  (MV/(cm*cm)
           xpas2=xpas*xpas
           dgdz=qst/e0 * tspl0
           d2gdz2=dgam/xpas2-dgdz/xpas
           d2gdz2=2.*d2gdz2
           gam1=gam0+dgdz*xpas/5.+d2gdz2*xpas2/50.
           gam2=gam0+dgdz*xpas*2./5.+d2gdz2*xpas2*4./50.
           gam3=gam0+dgdz*xpas*3./5.+d2gdz2*xpas2*9./50.
           gam4=gam0+dgdz*xpas*4./5.+d2gdz2*xpas2*16./50.
           b1=sqrt(gam1*gam1-1.)/gam1
           b2=sqrt(gam2*gam2-1.)/gam2
           b3=sqrt(gam3*gam3-1.)/gam3
           b4=sqrt(gam4*gam4-1.)/gam4
           b5=sqrt(gam5*gam5-1.)/gam5
           dgam=xf1(ico,phi(j),t0,t5)*qc/e0
           gam5=gam(i1)+dgam
           b5=sqrt(gam5*gam5-1.)/gam5
!      tranverse coordinates in (cm,rad)
           x0=f(2,j)
           y0=f(4,j)
           xt0=f(3,j)*1.e-03
           yp0=f(5,j)*1.e-03
!        Picht transformation: xe0 and ye0 (cm) xpe0 and ype0 (rad)
           gamm0=(gam0*gam0-1.)**0.25
           xe0=x0*gamm0
           xpe0=xt0*gamm0
           ye0=y0*gamm0
           ype0=yp0*gamm0
           xpe0=xpe0+.5*xe0*gam0*dgdz/(gam0*gam0-1.)
           ype0=ype0+.5*ye0*gam0*dgdz/(gam0*gam0-1.)
           xe(i1)=xe0
           xpe(i1)=xpe0
           ye(i1)=ye0
           ype(i1)=ype0
!       transverse coupling terms
           gam00=gam0*gam0
           gam11=gam1*gam1
           gam22=gam2*gam2
           gam33=gam3*gam3
           gam44=gam4*gam4
           bgt0=(gam00-1.)**1.5
           xk1=fh*fh/(4.*vl*vl*bgt0)
           red=sqrt(xe(i1)*xe(i1)+ye(i1)*ye(i1))
           red2=red*red
           dred=0.
           ico=1
           if(red.gt.1.e-08) then
             dred=xe(i1)*xpe(i1)+ye(i1)*ype(i1)
             dred=dred/red
           endif
           rk1=xk1*red2*xf1(ico,phi(j),t0,t5)*qc/e0
           rk2=red*dred*xk1*xf2(phi(j),t0)*qc/e0
           gam(i)=gam5+rk1+rk2
           if(gam(i).le.1.) then
             f(8,j)=0.
             ilost=ilost+1
! needs to be on energy
             lossreason(j)=-2
! Relative to cog
             f6i=f(6,j)-tmoy
             write(49,3928) PRTLAB,NRRES,davtot/100.,j,int(f(1,j)),
     *       f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180./pi,f(7,j)-xmat,
     *       f(9,j),lossreason(j)
3928         FORMAT(1x,A8,1x,I4,1x,E12.5,1x,i5,1x,i5,1x,6(f12.3,1x),
     *            1x,f5.2,3x,i2)
             cycle
           endif
           gam55=gam(i)*gam(i)
           bgt1=(gam11-1.)**1.5
           bgt2=(gam22-1.)**1.5
           bgt3=(gam33-1.)**1.5
           bgt4=(gam44-1.)**1.5
           bgt5=(gam55-1.)**1.5
           bge0=(gam00+2.)/((gam00-1.)*(gam00-1.))
           bge1=(gam11+2.)/((gam11-1.)*(gam11-1.))
           bge2=(gam22+2.)/((gam22-1.)*(gam22-1.))
           bge3=(gam33+2.)/((gam33-1.)*(gam33-1.))
           bge4=(gam44+2.)/((gam44-1.)*(gam44-1.))
           bge5=(gam55+2.)/((gam55-1.)*(gam55-1.))
! ******************************************************
!   compute the phase jump over the step
! ******************************************************
           f(7,j)=gam(i)*e0
           tcour(j)=t5
           ddt1=t5-ddt
           f(6,j)=ddt1+f(6,j)
! -- angular deviation
!    1) terms in dE/dt
           a1=qc/(2.*e0*vl)
           ttt1=xjf1(phi(j),t0)
           ttt2=xjf2(phi(j),t0)
           dxpe1=xe(i1)*ttt1+xpe(i1)*ttt2
           dype1=ye(i1)*ttt1+ype(i1)*ttt2
           xpe(i)=xpe(i1)+a1*dxpe1
           ype(i)=ype(i1)+a1*dype1
           xe(i)=xe(i1)+xpas*(xpe(i1)+xpe(i))/2.
           ye(i)=ye(i1)+xpas*(ype(i1)+ype(i))/2.
!       back to the real variables and convert to (cm,mrad)
           dgdzr=qc/e0 * tspl5
           gamm1=(gam(i)*gam(i)-1.)**0.25
           gamm2=(gam(i)*gam(i)-1.)**1.25
           xi=xe(i)/gamm1
           xpi=xpe(i)/gamm1-xe(i)*gam(i)*dgdzr/(gamm2*2.)
           yi=ye(i)/gamm1
           ypi=ype(i)/gamm1-ye(i)*gam(i)*dgdzr/(gamm2*2.)
!      convert in cm and mrd
           f(2,j)=xi
           f(4,j)=yi
           f(3,j)=xpi*1.e03
           f(5,j)=ypi*1.e03
         enddo
!  space charge computation (only odd step numbers)
         if(.not.flgsc) then
           flgsc=.true.
           call disp
         else
           if(ichaes) then
!   space charge (only SCHEFF is available)
             iesp=.true.
             call cesp(eglsc)
             iesp=.false.
             flgsc=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
           endif
           call disp
         endif
         xnh=xnh+1.
       enddo
       return
       end
!*******************************************              
       subroutine hist2d(n,x,y,xmin,xmax,ymin,ymax,nx,ny,array)
! Bin array of values into a 2D grid
       implicit real(8) (a-h,o-z)
       parameter (iptsz=1000002)
! Inputs:
! n=number of values to bin
! x, y = input arrays
! xmin,xmax,ymin,ymax= extrema in input array
! mask_in = type logical (optional)
! nx, ny = number of bins in the 2D histogram
!
! Output:
! array = histogrammed data in form of array
       dimension x(iptsz),y(iptsz)
       dimension array(100,100)
! initialize the array
       do i=1,100
         do j=1,100
           array(i,j)=0.
         enddo
       enddo    
       do i=1,n
          ix=ipos(xmin,xmax,x(i),nx)
          iy=ipos(ymin,ymax,y(i),ny)
          if(ix.ge.1.and.ix.le.nx) then
             if(iy.ge.1.and.iy.le.ny) then
                array(ix,iy) = array(ix,iy) + 1.
             end if
          end if
       end do
       return
       end 
!*******************************************       
       integer function ipos(xmin,xmax,x,nbin)
! Find which histogram bin x falls in
       implicit real(8) (a-h,o-z)
       if(xmax.gt.xmin) then
         if(x.lt.xmin) then
           ipos=0
         else if(x.gt.xmax) then
           ipos=nbin+1
         else if(x.lt.xmax) then
           frac=(x-xmin)/(xmax-xmin)
           ipos=int(frac*real(nbin))+1
         else
           ipos=nbin
         end if
       else
         if(x.lt.xmax) then
           ipos=0
         else if(x.gt.xmin) then
           ipos=nbin+1
         else if(x.lt.xmin) then
           frac=(x-xmin)/(xmax-xmin)
           ipos=int(frac*real(nbin))+1
         else
           ipos=nbin
         end if
       end if
       return
       end
!******************************************
! added by WDK
!******************************************
       SUBROUTINE PROGRESS(NRTRE,NRRES)
       CHARACTER cr*1
       cr=char(13)
       WRITE(6,8254,advance='no') NRTRE,NRRES,cr
8254   format('Transport element:',i5,
     *        '      Accelerating element:',i5,a1)
       RETURN
       END
